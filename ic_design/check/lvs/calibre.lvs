// xCalibre/calibre  RC/LVS command file based on the follow calibre command file//
/////////////////////////////////////////////////////////////////////////////////
//  @(#) TSMC 0.18UM CALIBRE LVS/RC COMMAND FILE 
//  @(#) FOR TSMC 0.18UM CMOS HV MIXED SIGNAL BASED BCD GEN3 SALICIDE 
//  @(#) COMMAND FILE DOCUMENT: T-018-CV-SP-027-C1 
//  @(#) COMMAND FILE VERSION: V1.3a 
//  @(#) COMMAND FILE METAL SCHEME: 1P5M 
//  @(#) COMMAND FILE DATE: 07/27/2018 
//  @(#) EDA TOOL VERSION: Calibre 2007.4_14.15  
// 
//  TSMC has developed this deck using Mentor Graphics proprietary SVRF and TVF formats.  
//  The deck is to be used only in Calibre tools.  
//////////////////////////////////////////////////////////////////////////////// 
// 
// DISCLAIMER 
// 
// This file usually contains the super set of device extraction rule at TSMC
// processes. However, all of device in basic deck may not be offered at current
// SPICE model. PLEASE ALWAYS REFER TO THE CORRESPONDING SPICE MODEL DOCUMENT
// FOR ANY DEVICE YOU WOULD LIKE USE.
// 
// The information contained herein is provided by TSMC on an "AS IS" basis 
// without any warranty, and TSMC has no obligation to support or otherwise 
// maintain the information.  TSMC disclaims any representation that the 
// information does not infringe any intellectual property rights or proprietary 
// rights of any third parties.  There are no other warranties given by TSMC, 
// whether express, implied or statutory, including, without limitation, implied 
// warranties of merchantability and fitness for a particular purpose. 
// 
// STATEMENT OF USE 
// 
// This information contains confidential and proprietary information of TSMC. 
// No part of this information may be reproduced, transmitted, transcribed, 
// stored in a retrieval system, or translated into any human or computer 
// language, in any form or by any means, electronic, mechanical, magnetic, 
// optical, chemical, manual, or otherwise, without the prior written permission 
// of TSMC.  This information was prepared for informational purpose and is for 
// use by TSMC's customers only.  TSMC reserves the right to make changes in the 
// information at any time and without notice. 
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
// 
//////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////// 
// 
// 
// 
// 
//                             DEVICE FORMULA 
//   ----- ----------------------------- ---------------------------------- 
//   NAME  DESCRIPTION                   DEVICE LAYER OPERATION 
//   ----- ----------------------------- ---------------------------------- 
//   M[N]  1.8V core device              (NGATE-OD2-ESD) 
//   M[P]  1.8V core device              (PGATE-OD2-ESD) 
//   M[ND] 5V IO device                  (NGATE*OD2-ESD-NTN) 
//   M[PD] 5V IO device                  (PGATE*OD2-ESD-NTN) 
//   M[NCH_5_FGD_MAC] 5V FGD(P+) NMOS    (OD*POLY1i*PIMP*NIMP-NWELL*OD2*FGDDMY)  
//   M[NCH_5_NGD_MAC] 5V FGD NMOS        (OD*POLY1i*NIMP-NWELL*OD2*FGDDMY)  
//   Q[pnp2_rpo]       CORE  PNP-BJT w/i RPO  area 4		      (BJTDMY*OD*PIMP-OD2*NWELL*RPO-LVSDMY)  
//   Q[pnp5_rpo]       CORE  PNP-BJT w/i RPO  area 25		      (BJTDMY*OD*PIMP-OD2*NWELL*RPO-LVSDMY)  
//   Q[pnp10_rpo]      CORE  PNP-BJT w/i RPO  area 100		      (BJTDMY*OD*PIMP-OD2*NWELL*RPO-LVSDMY)  
//   Q[pnp2_rpo_mis]       CORE  PNP-BJT w/i RPO  area 4		      (BJTDMY*OD*PIMP-OD2*NWELL*RPO*LVSDMY)  
//   Q[pnp5_rpo_mis]       CORE  PNP-BJT w/i RPO  area 25		      (BJTDMY*OD*PIMP-OD2*NWELL*RPO*LVSDMY)  
//   Q[pnp10_rpo_mis]      CORE  PNP-BJT w/i RPO  area 100	      (BJTDMY*OD*PIMP-OD2*NWELL*RPO*LVSDMY) 
//   Q[pnp10_5_rpo]      I/O  PNP-BJT w/i RPO  area 100		      (BJTDMY*OD*PIMP*OD2*NWELL*RPO-LVSDMY)  
//   Q[pnp10_5_rpo_mis]  I/O  PNP-BJT w/i RPO  area 100		      (BJTDMY*OD*PIMP*OD2*NWELL*RPO*LVSDMY) 
//   Q[pnp2_5_poly]       I/O  PNP-BJT w/i poly  area 4		      (BJTDMY*OD*PIMP*OD2*NWELL*POLY1i-LVSDMY)  
//   Q[pnp5_5_poly]       I/O  PNP-BJT w/i poly  area 25		      (BJTDMY*OD*PIMP*OD2*NWELL*POLY1i-LVSDMY)  
//   Q[pnp10_5_poly]      I/O  PNP-BJT w/i poly  area 100		      (BJTDMY*OD*PIMP*OD2*NWELL*POLY1i-LVSDMY)  
//   Q[pnp2_5_poly_mis]   I/O  PNP-BJT w/i poly  area 4		      (BJTDMY*OD*PIMP*OD2*NWELL*POLY1i*LVSDMY)  
//   Q[pnp5_5_poly_mis]   I/O  PNP-BJT w/i poly  area 25		      (BJTDMY*OD*PIMP*OD2*NWELL*POLY1i*LVSDMY)  
//   Q[pnp10_5_poly_mis]  I/O  PNP-BJT w/i poly  area 100		      (BJTDMY*OD*PIMP*OD2*NWELL*POLY1i*LVSDMY)   
//   rppolyhri3d3k     3d3K HRI p-poly w/o silicide	        (RPDMYX*POLY1*RLPPDMY*RPO*PIMP-RFDUMMY*HRI3D3KDMY-SERPDMY) 
//   rppolyhri3d3k_serp  3d3K HRI p-poly w/o silicide(distributed serpentine type)    (RPDMYX*POLY1*RLPPDMY*RPO*PIMP-RFDUMMY*HRI3D3KDMY*SERPDMY*RSEPDUMMY) 
//   rppolyhri3d3k_dis 3d3K HRI p-poly w/o silicide(distributed)	(RPDMY1*POLY1*RLPPDMY*RPO*PIMP-RFDUMMY*HRI3D3KDMY-SERPDMY) 
//   rppolyhri3d3k_serp_dis 3d3K HRI p-poly w/o silicide(distributed serpentine type) (RPDMY1*POLY1*RLPPDMY*RPO*PIMP-RFDUMMY*HRI3D3KDMY*SERPDMY*RSEPDUMMY) 
//   rppolyhri1k     1K HRI p-poly w/o silicide		        (RPDMYX*HRI-RPDMY1*POLY1*RLPPDMY*RPO*PIMP-RFDUMMY)  
//   rppolyhri1k_dis 1K HRI p-poly w/o silicide(distributed)	(RPDMY1*HRI-RPDMYX*POLY1*RLPPDMY*RPO*PIMP-RFDUMMY) 
//   rppo1rpo_serp  P+Poly resistor w/o Silicide(serpentine type) (RPDMYX*POLY1*PIMP*RPO*DMP2V*SERPDMY*RSEPDUMMY) 
//   ndio_sbd_mac   RF 5V schottky barrier diode w/o DNW          (M1*SBDUMMY*RFDUMMY1*PIMP*NIMP*NWELL*OD-DNW*OD2)   
//   R[WO] N-Well resistor under OD      (RWDMYX*NWELL*(OD*RPO)) 
//   R[WR] N-Well resister under STI     (RWDMYX*NWELL-(OD*RPO)) 
//   R[PR] P+Poly resistor w/o Silicide  (RPDMYX*POLY1*PIMP*RPO*DMP2V-SERPDMY) 
//   R[NR] N+Poly resistor w/o Silicide  (RPDMYX*POLY1*NIMP*RPO*DMN2V) 
//   R[PS] P+Poly resistor w/i Silicide  (RPDMYX*POLY1*PIMP-RPO) 
//   R[NS] N+Poly resistor w/i Silicide  (RPDMYX*POLY1*NIMP-RPO) 
//   R[PD] P+diff resistor w/o Silicide  (RPDMYX*NWELL*OD*PIMP*RPO*DMP2V) 
//   R[ND] N+diff resistor w/o Silicide  (RPDMYX*OD*NIMP*RPO*DMN2V) 
//   R[PI] P+diff resistor w/i Silicide  (RPDMYX*NWELL*OD*PIMP-RPO) 
//   R[NI] N+diff resistor w/i Silicide  (RPDMYX*OD*NIMP-RPO) 
//   R[M1] METAL1 resistor               (RMDMY1*METAL1) 
//   R[M2] METAL2 resistor               (RMDMY2*METAL2) 
//   R[M3] METAL3 resistor               (RMDMY3*METAL3) 
//   R[M4] METAL4 resistor               (RMDMY4*METAL4) 
//   R[MT] METAL5 resistor               (RMDMY5*METAL5)  
//   X[mimcap_1p0_sin]     CTM4/M4 capacitor   (CTM4*METAL4*MIM_10F) 
//   X[mimcap_1p0_sin_3t]     CTM4/M4 capacitor   (CTM4*METAL4*MIM_10F*MIM_3T) 
//   X[mimcap_2p0_sin]     CTM4/M4 capacitor   (CTM4*METAL4*MIM_20F) 
//   X[mimcap_2p0_sin_3t]     CTM4/M4 capacitor   (CTM4*METAL4*MIM_20F*MIM_3T) 
//   CRTMOM                RTMOM capacitor       (M1*M2*M3*MOMDMY1*MOMDMY2*MOMDMY3*POLY1) 
//   cfmom          Baseband FMOM w/i poly shielding     (M1*M2*MOMDMY1*MOMDMY2*POLY1*NIMP-RFDUMMY1*MOMDMY100-MOMDMY22) 
//   cfmom_mx                       Baseband FMOM_MX               (M1*M2*MOMDMY1*MOMDMY2*POLY1*NIMP-RFDUMMY1*MOMDMY100*MOMDMY22) 
//   cfmom_tm_m1_0d23_2t   cfmom_tm_m1_0d23_2t   (M1*M2*MOMDMY1*MOMDMY2-RFDUMMY1*MOMDMY100-MOMDMY22*MOMDMYBB*MOMDMY34-MOMDMY35-MOMDMY36-MOMDMY37) 
//   cfmom_tm_m1_0d28_2t   cfmom_tm_m1_0d28_2t   (M1*M2*MOMDMY1*MOMDMY2-RFDUMMY1*MOMDMY100-MOMDMY22*MOMDMYBB-MOMDMY34*MOMDMY35-MOMDMY36-MOMDMY37) 
//   cfmom_tm_m1_0d23   cfmom_tm_m1_0d23   (M1*M2*MOMDMY1*MOMDMY2-RFDUMMY1*MOMDMY100-MOMDMY22-MOMDMYBB*MOMDMY34-MOMDMY35-MOMDMY36-MOMDMY37) 
//   cfmom_tm_m1_0d28   cfmom_tm_m1_0d28   (M1*M2*MOMDMY1*MOMDMY2-RFDUMMY1*MOMDMY100-MOMDMY22-MOMDMYBB-MOMDMY34*MOMDMY35-MOMDMY36-MOMDMY37) 
//   cfmom_m1_0d28_2t      cfmom_m1_0d28_2t      (M1*M2*MOMDMY1*MOMDMY2-RFDUMMY1*MOMDMY100-MOMDMY22*MOMDMYBB-MOMDMY34-MOMDMY35-MOMDMY36*MOMDMY37)  
//   cfmom_m1_0d23_2t      cfmom_m1_0d23_2t      (M1*M2*MOMDMY1*MOMDMY2-RFDUMMY1*MOMDMY100-MOMDMY22*MOMDMYBB-MOMDMY34-MOMDMY35*MOMDMY36-MOMDMY37) 
//   cfmom_m1_0d28      cfmom_m1_0d28      (M1*M2*MOMDMY1*MOMDMY2-RFDUMMY1*MOMDMY100-MOMDMY22-MOMDMYBB-MOMDMY34-MOMDMY35-MOMDMY36*MOMDMY37)  
//   cfmom_m1_0d23      cfmom_m1_0d23      (M1*M2*MOMDMY1*MOMDMY2-RFDUMMY1*MOMDMY100-MOMDMY22-MOMDMYBB-MOMDMY34-MOMDMY35*MOMDMY36-MOMDMY37) 
//   D[DP] diode P+/NW                   (DIODMY*OD*PIMP*NWELL-OD2) 
//   D[DN] diode N+/PW                   (DIODMY*OD*NIMP*PSUB-OD2) 
//   D[DW] diode NW/PW                   (DIODMY*NWELL*NIMP*OD) 
//   D[D1] 5V diode P+/NW            (DIODMY*OD*PIMP*NWELL*OD2) 
//   D[D2] 5V diode N+/PW            (DIODMY*OD*NIMP*PSUB*OD2) 
//   D[D3] 5V diode NW/PW            (DIODMY*OD*NIMP*NWELL*OD2) 
//   rnod_m      3T N+diff resistor w/i Silicide  (RPDMY1*OD*NIMP-RPO) 
//   rnodw_m     3T N+diff resistor w/i Silicide  (RPDMY1*OD*NIMP-RPO)   
//   rnodrpo_m   3T N+diff resistor w/o Silicide  (RPDMY1*OD*NIMP*RPO*DMN2V)   
//   rpod_m      3T P+diff resistor w/i Silicide  (RPDMY1*OD*PIMP-RPO*NWELL)   
//   rpodw_m     3T P+diff resistor w/i Silicide  (RPDMY1*OD*PIMP-RPO*NWELL)   
//   rpodrpo_m   3T P+diff resistor w/o Silicide  (RPDMY1*OD*PIMP*RPO*NWELL*DMP2V)   
//   rnwod_m     3T N-Well resistor under OD      (RWDMY1*NWELL*(OD*RPO)) 
//   rnwsti_m    3T N-Well resistor under STI    (RWDMY1*NWELL-(OD*RPO)) 
//   rnpo1_dis     3T N+Poly resistor w/i Silicide  (RPDMY1*POLY1*NIMP-RPO) 
//   rnpo1w_dis    3T N+Poly resistor w/i Silicide  (RPDMY1*POLY1*NIMP-RPO) 
//   rppo1_dis     3T P+Poly resistor w/i Silicide  (RPDMY1*POLY1*PIMP-RPO) 
//   rppo1w_dis    3T P+Poly resistor w/i Silicide  (RPDMY1*POLY1*PIMP-RPO) 
//   rppo1rpo_dis  3T P+Poly resistor w/o Silicide  (RPDMY1*POLY1*PIMP*RPO*DMP2V-SERPDMY) 
//   rppo1rpo_serp_dis  3T P+Poly resistor w/o Silicide(serpentine type) (RPDMY1*POLY1*PIMP*RPO*DMP2V*SERPDMY*RSEPDUMMY) 
//   rnpo1rpo_dis  3T N+Poly resistor w/o Silicide  (RPDMY1*POLY1*NIMP*RPO*DMN2V) 
//   rnwod_pure5v           N-Well pure5v resistor under OD      (RWDMYX*NWELL*(OD*RPO)*(OD2*RWDMY5)) 
//   rpodrpo_pure5v         P+diff pure5v resistor w/o Silicide  (RPDMYX*NWELL*OD*PIMP*RPO*(OD2*RPDMY5)-RFDUMMY*DMP2V) 
//   rnodrpo_pure5v         N+diff pure5v resistor w/o Silicide  (RPDMYX*OD*NIMP*RPO*(OD2*RPDMY5)-RFDUMMY*DMN2V) 
//   rppo1rpo_pure5v        P+Poly pure5v resistor w/o Silicide  (RPDMYX*POLY1*PIMP*RPO*DMP2V*(OD2*RPDMY5)-RFDUMMY) 
//   rnpo1rpo_pure5v        N+Poly pure5v resistor w/o Silicide  (RPDMYX*POLY1*NIMP*RPO*DMN2V*(OD2*RPDMY5)-RFDUMMY) 
//   rnwsti_pure5v          N-Well pure5v resister under STI     (RWDMYX*NWELL*(OD2*RWDMY5)-(OD*RPO)) 
//   rnwod_pure5v_m         N-Well pure5v resistor under OD      (RWDMY1*NWELL*(OD*RPO)*(OD2*RWDMY5)) 
//   rpodrpo_pure5v_m       P+diff pure5v resistor w/o Silicide  (RPDMY1*OD*PIMP*RPO*NWELL*DMP2V*(OD2*RPDMY5)) 
//   rnodrpo_pure5v_m       N+diff pure5v resistor w/o Silicide  (RPDMY1*OD*NIMP*RPO*DMN2V*(OD2*RPDMY5)) 
//   rnwsti_pure5v_m        N-well pure5v resistor under STI     (RWDMY1*NWELL*(OD2*RWDMY5)-(OD*RPO)) 
//   rnpo1rpo_pure5v_dis    N+Poly pure5v resistor w/o Silicide(distributed)  (RPDMY1*POLY1*NIMP*RPO*DMN2V*(OD2*RPDMY5)) 
//   rppo1rpo_pure5v_dis    P+Poly pure5v resistor w/o Silicide(distributed)  (RPDMY1*POLY1*PIMP*RPO*DMP2V*(OD2*RPDMY5)) 
//   M[nanch5_biso]                 nanch5_biso                                 (NTN*NTNDMY*POLY1i*OD*OD2*NIMP-NT_N2i) 
//   M[nanch5_biso_wo]              nanch5_biso_wo                              (NTN*NTNDMY*POLY1i*OD*OD2*NIMP*NT_N2i) 
//   M[nanch_biso]                  nanch_biso                                  (NTN*NTNDMY*POLY1i*OD-OD2*NIMP) 
//   M[nch_dep5]                    5V depletion NMOS                           (POLY1i*VTDN*OD*OD2*NIMP)      
//   M[nch5_lvt_dd]                 5V LVT NMOS                                 (POLY1i*NDDi*OD*OD2*NIMP) 
//   M[pch5_lvt_dd]		  5V LVT PMOS                                 (POLY1i*PDDi*OD*OD2*PIMP*NWELL) 
//   nmoscap                        1.8V NMOS Varactor                          (POLY1i*VARDMY*NWELL*OD*NIMP)  
//   nmoscap_5                      5V NMOS Varactor                            (POLY1i*VARDMY*NWELL*OD*OD2*NIMP) 
//   nmoscap_5_mis                  5V NMOS Varactor                            (POLY1i*VARDMY*NWELL*OD*OD2*NIMP*LVSDMY) 
//   D[shnnblpsubshp_dio_ga]        NBL/PSUB Diode (GA)                         (HV40DMY*HVGA*NBLi*DIODMY*SH_N*NOPW) 
//   D[shnnblpsubshp_dio_gb]        NBL/PSUB Diode (GB)                         (HV40DMY*HVGB*NBLi*DIODMY*SH_N*NOPW) 
//   D[shnpsubshp_dio_ga]           SHNW/PSUB GA Diode (GA)                     (HV40DMY*HVGA*DIODMY*SH_N*NOPW) 
//   D[npdd_dio_v2_ga]              N+PDD GA Diode (GA)                         (NOPW*PDDi*HV40DMY*HVGA*OD*DIODMY*NIMP) 
//   D[nhvpw_dio_v2_gb]             N+/HVPW Diode (GB)                          (HV40DMY*HVGB*OD*DIODMY*NIMP*NOPW*HVPWi) 
//   shpnblshn_dio_shp_gb_3t        SHPW/SHNW+NBL Diode (GB)                    (SH_Pi*HV40DMY*HVGB*NBLi*OD*DIO3TDMY*PIMP*SH_N*NOPW) 
//   shpshnnbl_esd_dio_shp_ga_3t	  shpshnnbl_esd_dio_shp_ga_3t                 (DIO3TDMY*HV40DMY*HVGA*NBLi*OD*PIMP*SDI*SH_Pi*NOPW*PDDi*SH_N) 
//   zd_dio_ga_nbl_v2_4t            Zener Diode with NBL (GA)                   (NOPW*POLY1i*SH_Pi*HV40DMY*HVGA*NBLi*HVPBi2*OD*DIO4TDMY*NIMP*SH_N) 
//   pbshnnbl_dio_shp_ga_3t         P+PB in SHNW+NBL GA Diode (GA)              (HV40DMY*HVGA*NBLi*HVPBi2*OD*DIO3TDMY*PIMP*SH_N*NOPW) 
//   pbhvnwshnnbl_esd_dio_shp_gb_3t pbhvnwshnnbl_esd_dio_shp_gb_3t	      (DIO3TDMY*HV40DMY*HVGB*HVNWi*HVPBi2*NBLi*OD*PIMP*SDI*SH_N*NOPW*NBLSLOTi) 
//   pddshnnbl_dio_shp_ga_3t        P+PDD in SHNW+NBL GA Diode (GA)             (PDDi*HV40DMY*HVGA*NBLi*OD*DIO3TDMY*PIMP*SH_N*NOPW) 
//   pdio_esd_ga_6_v3_3t            6V_ESD_GA                                   (NOPW*SH_N*HV40DMY*HVGA*HV6DMY*OD*DIO3TDMY*SDI*PIMP*NBLi) 
//   pdio_esd_ga_9_v3_3t            9V_ESD_GA                                   (NOPW*SH_N*HV40DMY*HVGA*HV9DMY*OD*DIO3TDMY*SDI*PIMP*HVPBi2*NBLi) 
//   pdio_esd_ga_12_pdd_3t          12V_ESD_GA                                  (NOPW*SH_N*HV40DMY*HVGA*HV12DMY*OD*DIO3TDMY*SDI*PIMP*NBLi*CFP*PDDi*RPO*SH_Pi) 
//   pdio_esd_ga_16_v3_3t           16V_ESD_GA                                  (NOPW*SH_N*HV40DMY*HVGA*HV16DMY*OD*DIO3TDMY*SDI*PIMP*NBLi*CFP*PDDi*RPO*SH_Pi) 
//   pdio_esd_ga_12_v4_3t           v4 12V_ESD_GA                               (NOPW*SH_N*HV40DMY*HVGA*HV12DMY*OD*DIO3TDMY*SDI*PIMP-PDDi*NBLi) 
//   pdio_esd_ga_20_v3_3t  	  v3 20V_ESD_GA		                      (DIO3TDMY*HV20DMY*HV40DMY*HVGA*NOPW*OD*PIMP*SDI*SH_N-CFP*NBLi*PDDi*RPO*SH_Pi) 
//   pdio_esd_ga_20_pdd_3t  	  PDD 20V_ESD_GA	                      (DIO3TDMY*HV20DMY*HV40DMY*HVGA*NOPW*OD*PIMP*SDI*SH_N*NBLi*RPO*CFP*PDDi*SH_Pi) 
//   pdio_esd_ga_24_v3_3t  	  v3 24V_ESD_GA		                      (DIO3TDMY*HV24DMY*HV40DMY*HVGA*NOPW*OD*PIMP*SDI*SH_N*NBLi*RPO*CFP*PDDi*SH_Pi) 
//   pdio_esd_ga_29_v3_3t  	  v3 29V_ESD_GA		                      (DIO3TDMY*HV29DMY*HV40DMY*HVGA*NOPW*OD*PIMP*SDI*SH_N*NBLi*PDDi*SH_Pi) 
//   pdio_esd_gb_45_cit_v3_3t  	  v3 45V_ESD_GB		                      (DIO3TDMY*HV45DMY*HV40DMY*HVGB*HVPBi2*OD*PIMP*SDI*SH_N-CFP*HVNWi*NBLi*NOPW*SDI_V2*NBLSLOTi) 
//   pdio_esd_gb_36_3t              36V_ESD_GB                                  (DIO3TDMY*HV36DMY*HV40DMY*NBLi*OD*PIMP*HVGB*HVNWi*NOPW*HVPBi2*SDI*SH_N*NBLSLOTi) 
//   sbd_dio_ga_12_v2_3t            12V SBD (GA)                                (NOPW*SH_Pi*PDDi*SH_N*HV40DMY*HVGA*SBDDMY_3T*OD*RPO*PIMP*HV12DMY*NDDi*CFP*NBLi) 
//   sbd_dio_ga_16_v2_3t            16V SBD (GA)                                (NOPW*SH_Pi*PDDi*SH_N*HV40DMY*HVGA*SBDDMY_3T*OD*RPO*PIMP*HV16DMY*NDDi*CFP*NBLi) 
//   sbd_dio_ga_24_v2_3t            24V SBD (GA)                                (NOPW*SH_Pi*PDDi*HV40DMY*HVGA*SBDDMY_3T*NBLi*OD*RPO*PIMP*HV24DMY*NDDi*SH_N*CFP) 
//    na6_g5a_nbl_v2_mac            NA6G5_NBL (GA)                             (POLY1i*SH_Pi*SH_N*HV40DMY*HVGA*HV6DMY*NBLi*MACRODMY*OD*RPO*NIMP*NOPW*NDDi)   
//    nch_hv5_5vnw_ac               IOLDNMOS MACRO model            (POLY1*OD*OD2*NWELL*NLVT*NIMP*MTP_2T2C*H18VNWDMY)     
//   na29_g5a_cfp_mac               NA29G5 (GA)                    (NOPW*POLY1i*SH_Pi*HV40DMY*HVGA*HV29DMY*MACRODMY*OD*NIMP*CFP-NBLi*NDDi*RPO*EOD) 
//   na29_g5a_nbl_cfp_mac           NA29G5 (GA)                    (NOPW*POLY1i*SH_Pi*SH_N*HV40DMY*HVGA*HV29DMY*MACRODMY*OD*NIMP*CFP*NBLi*NDDi*RPO*EOD*NBLSLOTi) 
//   nda29_g3a_nbl_cfp_mac          NA29G3_dep_NBL (GA)            (NOPW*POLY1i*SH_Pi*SH_N*HV40DMY*HVGA*HV29DMY*NBLi*MACRODMY*VTDN*OD*NIMP*CFP*NDDi*RPO*EOD*NBLSLOTi) 
//   na20_g5a_cfp_mac               NA20G5 (GA)                    (NOPW*POLY1i*SH_Pi*HV40DMY*HVGA*HV20DMY*MACRODMY*OD*NIMP*CFP-NBLi*NDDi*RPO*EOD) 
//   na20_g5a_nbl_cfp_mac           NA20G5 (GA)                    (NOPW*POLY1i*SH_Pi*SH_N*HV40DMY*HVGA*HV20DMY*MACRODMY*OD*NIMP*CFP*NBLi*NDDi*RPO*EOD) 
//   nda45_g3b_nbl_cfp_mac          NA45G3_dep_NBL (GB)            (NOPW*POLY1i*SH_N*HVNWi*HVPWi*HV40DMY*HVGB*HV45DMY*NBLi*MACRODMY*VTDN*OD*NIMP*CFP*RPO*SLITDMY*NBLSLOTi) 
//   nld12_g5a_iso_cfp_mac          NLD12G5_fully_iso (GA)         (POLY1i*NDDi*HV40DMY*HVGA*HV12DMY*NBLi*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*NOPW*SLITDMY*SH_N) 
//   nld12_g5a_cfp_mac              NLD12G5 (GA)                   (POLY1i*NDDi*HV40DMY*HVGA*HV12DMY*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*NOPW*SLITDMY) 
//   nld16_g5a_iso_cfp_mac          nld16G5_fully_iso (GA)         (NOPW*POLY1i*NDDi*HV40DMY*HVGA*HV16DMY*NBLi*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*SLITDMY*SH_N) 
//   nld16_g5a_cfp_mac              nld16G5 (GA)                   (NOPW*POLY1i*NDDi*HV40DMY*HVGA*HV16DMY*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*SLITDMY) 
//   nld20_g5a_iso_cfp_mac          NLD20G5_fully_iso (GA)         (NOPW*POLY1i*NDDi*HV40DMY*HVGA*HV20DMY*NBLi*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*SLITDMY*SH_N*EOD) 
//   nld20_g5a_cfp_mac              NLD20G5 (GA)                   (NOPW*POLY1i*NDDi*HV40DMY*HVGA*HV20DMY*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*SLITDMY*EOD) 
//   nld24_g5a_cfp_mac              NLD24G5 (GA)                   (NOPW*POLY1i*NDDi*HV40DMY*HVGA*HV24DMY*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*SLITDMY-HVLOWR*EOD) 
//   nld24_g5a_switch_cfp_mac       NLD24G5 (GA)                   (NOPW*POLY1i*NDDi*HV40DMY*HVGA*HV24DMY*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*SLITDMY*HVLOWR*EOD) 
//   nld24_g5a_iso_switch_cfp_mac   NLD24G5_NBL (GA)               (NOPW*POLY1i*NDDi*HV40DMY*HVGA*HV24DMY*NBLi*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*SLITDMY*SH_N*HVLOWR*EOD*NBLSLOTi) 
//   nld24_g5a_iso_cfp_mac          NLD24G5 (GA)                   (POLY1i*HV40DMY*HVGA*HV24DMY*NBLi*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*NDDi*NOPW*SLITDMY*SH_N*EOD*NBLSLOTi) 
//   nld36_g5b_nbl_cfp_mac          NLD36G5 (GB)                   (POLY1i*SH_N*HV40DMY*HVGB*HV36DMY*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*HVNWi*NOPW*SLITDMY*NBLi*NBLSLOTi) 
//   nld45_g5b_nbl_cfp_mac          NLD45G5 (GB)                   (POLY1i*SH_N*HV40DMY*HVGB*HV45DMY*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*CFP*HVNWi*NOPW*SLITDMY*NBLi*NBLSLOTi) 
//   nld6_g5a_de_mac		  NLD6G5_DE			 (NOPW*POLY1i*SH_N*NDDi*HVPBi2*OD*PIMP*NIMP*RPO*SLITDMY*HVGA*HV6DMY*MACRODMY*HV40DMY)	 
//   nld6_g5a_sa_mac		  NLD6G5_SA	 		 (NOPW*POLY1i-SH_N*NDDi*HVPBi2*OD*PIMP*NIMP-RPO*SLITDMY*HVGA*HV6DMY*MACRODMY*HV40DMY) 	 
//   nld6_g5a_de_iso_v2_mac         NLD6G5_DE_fully_iso (GA)       (POLY1i*SH_N*HV40DMY*HVGA*HV6DMY*NBLi*MACRODMY*HVPBi2*OD*PIMP*NIMP*NDDi*RPO*NOPW*SLITDMY) 
//   nld6_g5a_sa_iso_v2_mac         NLD6G5_SA_fully_iso (GA)       (POLY1i*SH_N*HV40DMY*HVGA*HV6DMY*NBLi*MACRODMY*HVPBi2*OD*PIMP*NIMP*NDDi*NOPW*SLITDMY) 
//   nld5_g5a_iso_switch_mac        NLD5G5_iso_switch (GA)         (POLY1i*HV40DMY*HVGA*HV5DMY*NBLi*MACRODMY*HVPBi2*OD*PIMP*NIMP*NDDi*NOPW*SLITDMY*SH_N) 
//   nld9_g5a_iso_mac               NLD9G5_fully_iso (GA)          (POLY1i*HV40DMY*HVGA*HV9DMY*NBLi*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*NDDi*NOPW*SLITDMY*SH_N) 
//   nld9_g5a_mac                   NLD9G5 (GA)                    (POLY1i*HV40DMY*HVGA*HV9DMY*MACRODMY*HVPBi2*OD*RPO*PIMP*NIMP*NDDi*NOPW*SLITDMY) 
//   pch5_as_switch_mac  		  5V Asymmetric Switch PMOS(GA)  (NBLi*OD*SH_N*POLY1i*PIMP*HV40DMY*HVGA*HV5DMY*NONLDDi*MACRODMY)  
//   pa6_g5a_de_nbl_v2_mac          PA6G5_DE_NBL (GA)              (POLY1i*SH_Pi*SH_N*HV40DMY*HVGA*HV6DMY*NBLi*MACRODMY*OD*RPO*PIMP*NOPW) 
//   pa12_g5a_nbl_v2_mac            PA12G5_NBL (GA)                (POLY1i*SH_N*PDDi*HV40DMY*HVGA*HV12DMY*NBLi*MACRODMY*OD*RPO*PIMP-SLITDMY*NOPW) 
//   pa9_g5a_nbl_mac                PA9G5_NBL (GA)                 (POLY1i*SH_N*PDDi*HV40DMY*HVGA*HV9DMY*NBLi*MACRODMY*OD*RPO*PIMP-SLITDMY*NOPW) 
//   pa9_g5a_nbl_slit_mac           PA9G5_NBL (GA)                 (POLY1i*SH_N*PDDi*HV40DMY*HVGA*HV9DMY*NBLi*MACRODMY*OD*RPO*PIMP*SLITDMY*NOPW) 
//   pa12_g5a_nbl_slit_v2_mac       PA12G5_NBL (GA)                (POLY1i*SH_N*PDDi*HV40DMY*HVGA*HV12DMY*NBLi*MACRODMY*OD*RPO*PIMP*SLITDMY*NOPW) 
//   pa20_g5a_nbl_cfp_mac           PA20G5_NBL (GA)                (POLY1i*SH_N*PDDi*HV40DMY*HVGA*HV20DMY*NBLi*MACRODMY*OD*RPO*PIMP-SLITDMY*CFP*NOPW) 
//   pa16_g5a_nbl_cfp_mac           PA16G5_NBL (GA)                (POLY1i*SH_N*PDDi*HV40DMY*HVGA*HV16DMY*NBLi*MACRODMY*OD*RPO*PIMP-SLITDMY*CFP*NOPW) 
//   pa20_g5a_nbl_slit_cfp_mac      PA20G5_NBL (GA)                (POLY1i*SH_N*PDDi*HV40DMY*HVGA*HV20DMY*NBLi*MACRODMY*OD*RPO*PIMP*SLITDMY*CFP*NOPW) 
//   pa16_g5a_nbl_slit_cfp_mac      PA16G5_NBL (GA)                (POLY1i*SH_N*PDDi*HV40DMY*HVGA*HV16DMY*NBLi*MACRODMY*OD*RPO*PIMP*SLITDMY*CFP*NOPW) 
//   pa29_g5a_nbl_cfp_mac           PA29G5_NBL (GA)                (NOPW*POLY1i*SH_N*PDDi*HV40DMY*HVGA*HV29DMY*NBLi*MACRODMY*OD*RPO*PIMP*CFP) 
//   pa45_g5b_nbl_cfp_mac           PA45G5 (GB)                    (POLY1i*SH_N*HV40DMY*HVGB*HV45DMY*NBLi*MACRODMY*OD*PIMP*NOPW*HVPWi) 
//   pa36_g5b_nbl_cfp_mac           PA36G5 (GB)                    (POLY1i*SH_N*HV40DMY*HVGB*HV36DMY*NBLi*MACRODMY*OD*PIMP*NOPW*HVPWi) 
//   PA6_G5A_SA_NBL_V2_MAC       PA6_G5A_SA_NBL_V2_MAC             (POLY1i*SH_Pi*SH_N*HV40DMY*HVGA*HV6DMY*NBLi*MACRODMY*OD*PIMP*NOPW) 
//   phvnwpsub10_gb_poly            PNP (HV BJT) (P+/HVNW/PSUB) 10x10 (GB)         (HV40DMY*HVGB*OD*BJTDMY*PIMP*POLY1i*HVNWi) 
//   phvnwpsub2_gb_poly             PNP (HV BJT) (P+/HVNW/PSUB) 2x2 (GB)           (HV40DMY*HVGB*OD*BJTDMY*PIMP*POLY1i*HVNWi) 
//   phvnwpsub5_gb_poly             PNP (HV BJT) (P+/HVNW/PSUB) 5x5 (GB)           (HV40DMY*HVGB*OD*BJTDMY*PIMP*POLY1i*HVNWi) 
//   npwshnnbl10_ga_bgr8_7t         8:1 NPN (HV BJT) (N+/PW/SHNW+NBL) 10x10 (GA)  (NOPW*SH_Pi*SH_N*HV40DMY*HVGA*NBLi*OD*BJTMDDMY*BJTSNDMY*BJTDMY_7t*PIMP*NIMP-PDDi*POLY1i) 
//   npddshnnbl10_ga_bgr8_7t        8:1 NPN (HV BJT) (N+/PDD/SHNW+NBL) 10x10 (GA) (NOPW*SH_Pi*SH_N*HV40DMY*HVGA*NBLi*OD*BJTMDDMY*BJTSNDMY*BJTDMY_7t*PIMP*NIMP*PDDi*POLY1i) 
//   npwshnnbl2_ga_poly_4t          NPN (HV BJT) (N+/PW/SHNW+NBL) 2x2 (GA)        (NOPW*SH_Pi*SH_N*HV40DMY*HVGA*OD*BJTDMY_4t*NIMP*POLY1i*NBLi)  
//   npwshnnbl5_ga_poly_4t          NPN (HV BJT) (N+/PW/SHNW+NBL) 5x5 (GA)        (NOPW*SH_Pi*SH_N*HV40DMY*HVGA*OD*BJTDMY_4t*NIMP*POLY1i*NBLi)  
//   npwshnnbl10_ga_poly_4t         NPN (HV BJT) (N+/PW/SHNW+NBL) 10x10 (GA)      (NOPW*SH_Pi*SH_N*HV40DMY*HVGA*OD*BJTDMY_4t*NIMP*POLY1i*NBLi)  
//   npddshnnbl10_ga_poly_4t        NPN(HV BJT)(N+/PDD/NBL)10x10                  (SH_Pi*SH_N*HV40DMY*HVGA*NBLi*OD*BJTDMY_4t*NIMP*NOPW*PDDi*POLY1i) 
//   npddshnnbl2_ga_poly_4t         NPN(HV BJT)(N+/PDD/NBL)2x2                    (SH_Pi*SH_N*HV40DMY*HVGA*NBLi*OD*BJTDMY_4t*NIMP*NOPW*PDDi*POLY1i) 
//   npddshnnbl5_ga_poly_4t         NPN(HV BJT)(N+/PDD/NBL)5x5                    (SH_Pi*SH_N*HV40DMY*HVGA*NBLi*OD*BJTDMY_4t*NIMP*NOPW*PDDi*POLY1i) 
//   pnddpsub10_ga_poly             PNP (HV BJT) (P+/NDD/PSUB) 10x10 (GB)         (HV40DMY*HVGA*OD*BJTDMY*PIMP*NDDi-LVSDMY*POLY1i)  
//   pnddpsub2_ga_poly              PNP (HV BJT) (P+/NDD/PSUB) 2x2 (GB)           (HV40DMY*HVGA*OD*BJTDMY*PIMP*NDDi-LVSDMY*POLY1i)  
//   pnddpsub5_ga_poly              PNP (HV BJT) (P+/NDD/PSUB) 5x5 (GB)           (HV40DMY*HVGA*OD*BJTDMY*PIMP*NDDi-LVSDMY*POLY1i)  
//   pnddshp5_nbl_ga_4t             PNP(HV BJT) (P+/NDD+NBL/SH_P ) 5x5 (GA)       (SH_Pi*SH_N*HV40DMY*HVGA*NBLi*OD*BJTDMY_4t*PIMP*NDDi*NOPW*POLY1i) 
//   ---- ----------------------------- ----------------------------------    
//   * POLY1 = POLY1i 
//   * NGATE = OD * POLY1i * NIMP - NWELL 
//   * PGATE = OD * POLY1i * PIMP * NWELL 
//   * HVPGATE = OD * POLY1i * PIMP * HVNWi 
//   * VARGT = OD * POLY1i * NIMP * NWELL 
//   * HVNW  = HVNWi * HV40DMY 
//   * HVPW  = HV40DMY - HVNWi 
//   * PSUB = BULK 
//   * METAL1 = M1   
//   * METAL2 = M2   
//   * METAL3 = M3   
//   * METAL4 = M4   
//   * METAL5 = M5   
//   * METAL6 = M6   
//   * RMDMY1 = RMDMY1i+RMDMY  
//   * RMDMY2 = RMDMY2i+RMDMY  
//   * RMDMY3 = RMDMY3i+RMDMY  
//   * RMDMY4 = RMDMY4i+RMDMY  
//   * RMDMY5 = RMDMY5i+RMDMY  
//   * RMDMY6 = RMDMY6i+RMDMY  
//   * HVPB = HVPBi 
//////////////////////////////////////////////////////////////////////////////// 
// 
// USER NOTES :   
//   
// 1) mnpg49 mppg49 are obtained in a DRC run, not in an LVS run.   
//   
// 2) For Calibre "EDTEXT" file, use .INCLUDE strings.txt.   
//        LAYOUT TEXT  "text string" [x] [y]  (layer num) (cell name)   
//   
// 3) Input layer 'OD' is defined as thin oxide (OD) area which would    
//    be drawn by one generic od mask or by seperated N+OD and P+OD.    
//    Remove layers in the 'OD' entries you don't want to use at    
//    layer definition block.   
//   
// 4) Default setting for property check is 0%. Users should check with   
//    IP/Designe providers for proper tolerance.   
//   
// 5) It's recommended to run Calibre LVS by hierarchical mode since false   
//    errors have been encountered by only flat mode option '-lvs'.   
//   
// 6) Default property resolution for ambiguity is set to 32. It could be   
//    necessary to increase this setting to resolve serious ambiguity.   
//    Uncomment statement 'LVS PROPERTY RESOLUTION MAXIMUM' in this deck   
//    to reset the capability of property resolution.   
//   
// 7) This deck default not to extracts MOS AS/AD property. To turn on the   
//    extraction of MOS AS/AD property, please uncomment the line   
//    "#DEFINE extract_as_ad". It would cause SEED PROMOTION, and pose   
//    much overhead on layout netlist extraction, erc checks, and lvs comparison. 
// 
// 8) For MOS capacitors, AS and AD values are calculated by combining the  
//    total amount of source and drain area for the device and splitting up  
//    the result evenly between AS and AD. PS and PD values are similarily   
//    calculated by evenly splitting up the total amount of source and drain  
//    perimeter. This is valid since simulation results for MOS capacitors  
//    should not depend on how AS/AD and PS/PD are split up between source  
//    and drain.   
// 
// 9) "VIRTUAL CONNECT COLON YES" : By default, VIRTUAL CONNECT COLON is set  
//    yes. Please set to NO as doing full-chip checking   
// 
// 10) So far, only 0.18um process 2T BB mimcap and rf mimcap w/i shield  
//     support stacking mimcap. If this LVS deck is 0.18um process and  
//     w/i rf devices, it will support device under mimcap. And please  
//     do not put metal resistor w/i RMDMY(69;0) under the mimcap.   
//   
// 11) The resistor value extracted from this deck was just for LVS check.   
//     The exact resistor value should base on spice simulation.   
//  
// 12) There is no difference with ACCURACY switch on/off and the R paramter  
//     is a simple resistance calculation for reference only. The simple R  
//     equation here is "r=rsh*L/W". Please ALWAYS refer to the corresponding  
//     model for real R equation and resistance from post-sim result.  
// 
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
//                      Introduction to each switch  
//  
//   -------------------------	----------------------------------------------------------  
//   SWITCH NAME                  		DESCRIPTION                 
//   -------------------------	----------------------------------------------------------  
//   Accuracy        	          RESISTANCE VALUE VARIABLE SETTING   
//      
//   ZERO_NRS_NRD	          Set nrd=0 and nrs=0 when run RCX extraction flow.    
//  
//   NW_RING                      If turn on this switch, the soft-connect check for nwell   
//                                ring and psub(rwell) inside will not be checked.  
//  
//   WELL_TO_PG_CHECK             ERC_check for ntap connected to ground, default is turned on.  
//    
//   GATE_TO_PG_CHECK             ERC_check for gate connected to ground, default is turned off.  
//    
//   FLOATING_GATE_CHECK          Floating gate check, default is turned on.  
//   
//   FLOATING_WELL_CHECK          Floating well check, default is turned on.  
//    
//   DS_TO_PG_CHECK               ERC_check for MOS connected to both power and ground, default  
//                                turned on.  
// 
//   PATH_CHECK                   PATH_CHECK for net, default is turned off. 
// 
//   MACRO                        By default, macro models are not netlisted. Please turn on this   
//                                switch to enable "_mac" models. 
//  
//   extract_parasitic_diodes     By default, the parasitic diodes are not extracted in this   
//                                command file. Please turn on the this switch to apply the  
//				  extraction of parasitic diodes.     
//  
//   compare_parasitic_diodes     By default, the parasitic diodes are not compared in this   
//                                command file. Please turn on the this switch to apply the  
//				  comparision of parasitic diodes.  
//   top_metal_mim                turn-off this switch while mim cap between top metal-1 and top metal-2				   
//  
//  
//lvs_gen.pl version: 1.302
//calibre.pl version: 1.413

// LVS/RC switch option
// --------------------
//#define RC_DECK    //uncomment this line when this deck would be used as a RC command file
//#define ZERO_NRS_NRD    //uncomment this line when this deck would set NRS=0 and NRD=0 
//#define FILTER_DGS_TIED_MOS // uncomment this line to filter MOS with D, G and S tied together (default filter MOS with all pins tied)
#define WELL_TO_PG_CHECK 
// Default is on. Turn on to highlight if nwell connects to ground or psub connects to power.
//#define GATE_TO_PG_CHECK 
// Default is off. Turn on to highlight if a mos gate directly connects to power or ground.
//#define PATH_CHECK 
// Default is off. Turn on to highlight if
//(1) nodes have a path to power but no path to ground
//(2) nodes have a path to ground but no path to power
//(3) nodes have no path to power or ground
//(4) nodes have no path to any label net
#define DS_TO_PG_CHECK 
// Default is on. Turn on to highlight if drain connects to power and source connects to ground.
#define FLOATING_GATE_CHECK 
// Default is on. Turn on to highlight if there are floating gates.
#define FLOATING_WELL_CHECK 
// Default is on. Turn on to highlight if well does not connect to power or ground. 
//The nwell of moscaps and nwell-resistor are excluded.

VARIABLE WPED 5.0
VARIABLE PRESCALE 1.0

//#define NW_RING	//uncomment this line to enable the NW ring to separate the node from BULK

// POWER and GROUND name string variable setting
VARIABLE POWER_NAME  "AVD33B"  "AVD33G"  "AVD33R"  "AVDD"  "AVDDB"  "AVDDBG"  "AVDDG"  "AVDDR"  "AVDWELL"  "DVDD"  "TAVD33"  "TAVD33PST"  "TAVDD"  "TAVDDPST"  "VD33"  "VD33APST"  "VD33PST"  "VD33REF"  "VDD"  "VDD5V"  "VDDESD"  "VDDG"  "VDDM"  "VDDPST"  "VDDSA"  "VDWELL" 

VARIABLE GROUND_NAME  "AGND"  "AVS33B"  "AVS33G"  "AVS33R"  "AVSS"  "AVSSB"  "AVSSBG"  "AVSSG"  "AVSSR"  "AVSSUB"  "DVSS"  "GND"  "TACVSS"  "TAVSS"  "TAVSSPST"  "VS33APST"  "VSS"  "VSSAPST"  "VSSESD"  "VSSG"  "VSSM"  "VSSPST"  "VSSREF"  "VSSUB" 

//#########################################################################
//# ENVIRONMENT SETTING                              
//#########################################################################
// LVS option
// --------------------
//#define extract_as_ad
//

//  RC_BLOCKING SETTING
LAYOUT CELL LIST pcells "cfmom*" "cfmom_m1_0d23*" "cfmom_m1_0d23_2t*" "cfmom_m1_0d28*" "cfmom_m1_0d28_2t*" "cfmom_mx*" "cfmom_tm_m1_0d23*" "cfmom_tm_m1_0d23_2t*" "cfmom_tm_m1_0d28*" "cfmom_tm_m1_0d28_2t*" "crtmom*" "ndio_sbd_mac*" "mos_var_b*" "mos_var_b5*" "mos_var_b5_mis*" "pdio_esd_ga_12_v4_3t*" "pdio_esd_ga_20_v3_3t*" 
LAYOUT PRESERVE CELL LIST pcells


//  Sheet Resistance table
	VARIABLE	RVLR	1026.123930	//HRI high resistance poly R
	VARIABLE	RVM1	0.078 		//Metal-1  resistor
	VARIABLE	RVM2	0.078		//Metal-2  resistor
	VARIABLE	RVM3	0.078		//Metal-3  resistor
	VARIABLE	RVM4	0.078		//Metal-4  resistor
	VARIABLE	RVM5	0.078		//Metal-5  resistor
	VARIABLE	RVMT	0.036  	        //Top Metal  resistor
	VARIABLE	RV15K	0.01548		//Top Metal  resistor
	VARIABLE	RV30K	0.00897		//Top Metal  resistor
	VARIABLE	RV40K	0.0062		//Top Metal  resistor
	VARIABLE	RVND	88.125		//N+Diff resistor w/o Silicide
	VARIABLE	RVNR	421.5		//N+Poly resistor w/o Silicide
	VARIABLE	RVPD	127.27		//P+Diff resistor w/o Silicide
	VARIABLE	RVPR	350.8		//P+Poly resistor w/o Silicide
	VARIABLE	RVWO	374.55		//NWell resistor under OD
	VARIABLE	RVWR	894.8		//NWell resistor under STI
	VARIABLE	RVNI1	7.28		//N+Diff resistor w/i Silicid
	VARIABLE	RVNI2	7.28		//N+Diff resistor w/i Silicid
	VARIABLE	RVPI1	7.49		//P+Diff resistor w/i Silicide
	VARIABLE	RVPI2	7.49		//P+Diff resistor w/i Silicide
	VARIABLE	RVPS1	8.41		//P+Poly resistor w/i Silicide
	VARIABLE	RVPS2	8.41		//P+Poly resistor w/i Silicide
	VARIABLE	RVNS1	8.23		//N+Poly resistor w/i Silicide
	VARIABLE	RVNS2	8.23		//N+Poly resistor w/i Silicide
    
LVS HEAP DIRECTORY "/tmp"

//#DEFINE ACCURACY
//By default, macro models are not netlisted. Please turn on this switch to enable "_mac" models
//#DEFINE MACRO    
//comment the following line to disable the extraction of parasitic diodes, NW/PSUB, DPW/NBL and NBL/PSUB
#DEFINE extract_parasitic_diodes
//comment the following line to disable the compare parameter of parasitic diodes, NW/PSUB, DPW/NBL and NBL/PSUB
//#DEFINE compare_parasitic_diodes
//uncomment the following line in puure 5V process to select correct WPE calculation
//#DEFINE WPE_PURE5V
//comment the following line if mim device between top metal-1/top mteal-2,only valid in none double UTM case(top2_thick must be off)
#DEFINE top_metal_mim
#IFDEF RC_DECK
#DEFINE ACCURACY
#ENDIF   
    
//#define STD_LIB
#IFDEF STD_LIB       // for tsmc 018 STD library, to estimate well proximity effect on STD cell.
	VARIABLE	NMOS_BOT_EXT 	0.86*1e-6
	VARIABLE	PMOS_TOP_EXT 	1.09*1e-6
	VARIABLE	MOS_LR_EXT 	100.0*1e-6
#ELSE
	VARIABLE	NMOS_BOT_EXT 	0
	VARIABLE	PMOS_TOP_EXT 	0
	VARIABLE	MOS_LR_EXT 	0
#ENDIF

//#DEFINE top2_thick    // 2 thick metal layers

LAYOUT PRIMARY "lvs_top"
LAYOUT PATH "/dshome/techie/LVS/testsuite/018/dev_library/GEN2/v1d3/lvs_top.gds"
LAYOUT SYSTEM GDSII
//LAYOUT PATH "layout.net"
//LAYOUT SYSTEM SPICE

SOURCE PRIMARY "lvs_top"
SOURCE PATH "./lvs_top.cdl"
SOURCE SYSTEM SPICE

DRC RESULTS DATABASE "calibre_drc.db" ASCII // ASCII or GDSII
DRC SUMMARY REPORT "calibre_drc.sum"
ERC RESULTS DATABASE "calibre_erc.db" ASCII // ASCII or GDSII
ERC SUMMARY REPORT "calibre_erc.sum"

LVS REPORT "lvs.rep"
LVS REPORT MAXIMUM 1000 // ALL
MASK RESULTS DATABASE NONE //"mask.db"

#IFDEF RC_DECK
  //MASK SVDB DIRECTORY "svdb" QUERY
#ELSE
  MASK SVDB DIRECTORY "svdb" QUERY
#ENDIF
LVS ISOLATE SHORTS YES
LVS REPORT OPTION S

PRECISION 1000
RESOLUTION 1
UNIT LENGTH U

#IFDEF RC_DECK
  //UNIT CAPACITANCE F
#ELSE
  UNIT CAPACITANCE F
#ENDIF

TEXT DEPTH PRIMARY
PORT DEPTH PRIMARY

FLAG SKEW YES
FLAG OFFGRID YES

LVS SPICE PREFER PINS	       YES
LVS ABORT ON SUPPLY ERROR      NO
LVS ALL CAPACITOR PINS SWAPPABLE YES
LVS RECOGNIZE GATES            NONE
LVS IGNORE PORTS               NO
LVS CHECK PORT NAMES          YES
LVS REDUCE PARALLEL BIPOLAR    YES
LVS REDUCE PARALLEL MOS        YES
LVS REDUCE PARALLEL DIODES     YES
LVS REDUCE PARALLEL CAPACITORS YES
LVS REDUCE PARALLEL RESISTORS  YES
LVS REDUCE SERIES RESISTORS    YES      //Smashes series resistors
LVS REDUCE SERIES CAPACITORS   YES      //Smashes series capacitors
LVS REDUCE SPLIT GATES         YES       //Smashes MOS split-gates.
//LVS FILTER UNUSED OPTION B D E O
//Strongly recommand to comment FILTER_DGS_TIED_MOS switch
//AG is to filter MOS with all pins tied together, AB is to filter MOS with D,G,S tied together
#IFNDEF FILTER_DGS_TIED_MOS
LVS FILTER UNUSED OPTION AG RC RE RG
#ELSE
LVS FILTER UNUSED OPTION AB RC RE RG
#ENDIF
LVS PROPERTY RESOLUTION MAXIMUM 65536 // ALL

//==================================================================================================
// should be modify

LAYOUT BASE LAYER OD POLY1i NIMP PIMP CONT MOMDMY0 MOMDMY100


VIRTUAL CONNECT COLON YES

LVS POWER NAME POWER_NAME 
LVS GROUND NAME GROUND_NAME 
//#############################################
//# MAPPING                                   #
//#############################################
LAYER NWELL           2  //  N-Well
LAYER OD              11  12  3  //  thin oxide
LAYER EOD            300 
LAYER MAP 3 DATATYPE 7 300 //  Define extend OD region on drain side
LAYER OD2             4  //  Thick Oxide
LAYER PIMP            7  //  P+ S/D Implantation
LAYER NIMP            8  //  N+ S/D Implantation
LAYER POLY1i          13  //  Poly Si
LAYER POLY2           14  //  Poly2 for caps and res
LAYER CONT            15  //  Contact
LAYER M1              16  //  Metal-1
LAYER VIA1i           17  //  Via1 Hole
LAYER M2              18  //  Metal-2
LAYER VIA2i           27  //  Via2 Hole
LAYER M3              28  //  Metal-3
LAYER VIA3i           29  //  Via3 Hole
LAYER M4              31  //  Metal-4
LAYER VIA4i           32  //  Via4 Hole
LAYER M5              33  //  Metal-5
LAYER VIA5i           39  //  Via5 Hole
LAYER M6              38  //  Metal-6
LAYER DUM1           301 
LAYER MAP 16 DATATYPE 1 301 //  dummy metal M1
LAYER DUM2           302 
LAYER MAP 18 DATATYPE 1 302 //  dummy metal M2
LAYER DUM3           303 
LAYER MAP 28 DATATYPE 1 303 //  dummy metal M3
LAYER DUM4           304 
LAYER MAP 31 DATATYPE 1 304 //  dummy metal M4
LAYER DUM5           305 
LAYER MAP 33 DATATYPE 1 305 //  dummy metal M5
LAYER DUM6           306 
LAYER MAP 38 DATATYPE 1 306 //  dummy metal M6
LAYER M1SLOT         307 
LAYER MAP 16 DATATYPE 2 307 //  M1 slot
LAYER M2SLOT         308 
LAYER MAP 18 DATATYPE 2 308 //  M2 slot
LAYER M3SLOT         309 
LAYER MAP 28 DATATYPE 2 309 //  M3 slot
LAYER M4SLOT         310 
LAYER MAP 31 DATATYPE 2 310 //  M4 slot
LAYER M5SLOT         311 
LAYER MAP 33 DATATYPE 2 311 //  M5 slot
LAYER M6SLOT         312 
LAYER MAP 38 DATATYPE 2 312 //  M6 slot
LAYER VTDN            26  //  VTD_N implant
LAYER RPO             34  //  Non-salicide OD Area Definition
LAYER HRI             48  //  High value resistor implant. Rename from LPP
LAYER HRI3KDMY       313 
LAYER MAP 48 DATATYPE 1 313 //  dummy layer for HRI 3K resistor
LAYER HRI3D3KDMY     314 
LAYER MAP 48 DATATYPE 3 314 //  dummy layer for HRI 3D3K resistor
LAYER VHRI           315 
LAYER MAP 48 DATATYPE 10 315 //  dummy layer for HRI 40K resistor
LAYER BJTDMY         316 
LAYER MAP 49 DATATYPE 0 316 //  BJT dummy layer to form BJT
LAYER BJTDMY_4t      317 
LAYER MAP 49 DATATYPE 1 317 //  BJT dummy layer to form BJT_4t
LAYER BJTDMY_5t      318 
LAYER MAP 49 DATATYPE 2 318 //  BJT dummy layer to form BJT_5t
LAYER BJTDMY_7t      319 
LAYER MAP 49 DATATYPE 7 319 //  BJT dummy layer to form BJT_7t
LAYER BJTMDDMY       320 
LAYER MAP 49 DATATYPE 3 320 //  BJT dummy layer to form multi device
LAYER BJTMEDMY       321 
LAYER MAP 49 DATATYPE 4 321 //  BJT dummy layer to form multi emtter device
LAYER BJTSNDMY       322 
LAYER MAP 49 DATATYPE 5 322 //  BJT dummy layer to seperate node in multi emiter device
LAYER HVESD1DMY      323 
LAYER MAP 49 DATATYPE 8 323 //  stack BJT dummy layer
LAYER HVESD2DMY      324 
LAYER MAP 49 DATATYPE 9 324 //  High-side BJT dummy layer in stack BJT
LAYER PSUB2           50  //  apply for subtract2 ground
LAYER DIODMY          37  56  //  dummy layer to form diode
LAYER DIO3TDMY       325 
LAYER MAP 56 DATATYPE 1 325 //  dummy layer to form 3t diode
LAYER DIO4TDMY       326 
LAYER MAP 56 DATATYPE 2 326 //  dummy layer to form 4t diode
LAYER HOTWL          327 
LAYER MAP 51 DATATYPE 0 327 //  DRC layer to cover hot-NWEL to check hot_NWEL width 
LAYER RWDMYX          52  //  dummy layer to form N-Well resistor
LAYER RWDMY1         328 
LAYER MAP 52 DATATYPE 1 328 //  dummy layer to form N-Well resistor 3 terminals
LAYER RWDMY2         329 
LAYER MAP 52 DATATYPE 3 329 //  dummy layer to form N-Well resistor 4 terminals
LAYER RWDMY5         330 
LAYER MAP 52 DATATYPE 5 330 //  dummy layer to form PURE 5V N-Well resistor
LAYER RPDMYX          54  //  dummy layer to form OD/POLY resistor
LAYER RPDMY1         331 
LAYER MAP 54 DATATYPE 1 331 //  dummy layer to form OD/POLY resistor 3 terminals
LAYER RPDMY2         332 
LAYER MAP 54 DATATYPE 3 332 //  dummy layer to form OD/POLY resistor 4 terminals
LAYER RPDMY5         333 
LAYER MAP 54 DATATYPE 5 333 //  dummy layer to form PURE 5V OD/POLY resistor
LAYER SERPDMY        334 
LAYER MAP 54 DATATYPE 20 334 //  dummy CAD layer to cover Serpentine type poly resistor
LAYER RES5VDMY       335 
LAYER MAP 54 DATATYPE 50 335 //  dummy layer to cover poly resister with voltage bias <=5v for DRC check
LAYER RESHVDMY       336 
LAYER MAP 54 DATATYPE 51 336 //  dummy layer to cover poly resister with voltage bias > 5v for DRC check 
LAYER CTM1           337 
LAYER MAP 67 DATATYPE 1 337 //  Capacitor Top Metal-2
LAYER CTM2           338 
LAYER MAP 67 DATATYPE 2 338 //  Capacitor Top Metal-2
LAYER CTM3           339 
LAYER MAP 67 DATATYPE 3 339 //  MIM Capacitor Top Metal-4 (between metal3 and metal4)
LAYER CTM4           340 
LAYER MAP 67 DATATYPE 4 340 //  MIM Capacitor Top Metal-5 (between metal4 and metal5)
LAYER CTM5           341 
LAYER MAP 67 DATATYPE 5 341 //  MIM Capacitor Top Metal-6 (between metal5 and metal6)
LAYER RMDMY          342 
LAYER MAP 69 DATATYPE 0 342 //  dummy layer to form METAL resistor
LAYER RMDMY1i        343 
LAYER MAP 69 DATATYPE 1 343 //  dummy layer to form METAL1 resistor
LAYER RMDMY2i        344 
LAYER MAP 69 DATATYPE 2 344 //  dummy layer to form METAL2 resistor
LAYER RMDMY3i        345 
LAYER MAP 69 DATATYPE 3 345 //  dummy layer to form METAL3 resistor
LAYER RMDMY4i        346 
LAYER MAP 69 DATATYPE 4 346 //  dummy layer to form METAL4 resistor
LAYER RMDMY5i        347 
LAYER MAP 69 DATATYPE 5 347 //  dummy layer to form METAL5 resistor
LAYER RMDMY6i        348 
LAYER MAP 69 DATATYPE 6 348 //  dummy layer to form METAL6 resistor
LAYER RMDMYhi        349 
LAYER MAP 69 DATATYPE 10 349 //  dummy layer to form RDL resistor
LAYER RODMY           75  //  dummy layer to remove OD
LAYER CK3DMY         350 
LAYER MAP 93 DATATYPE 1 350 //  dummy layer to define the specific devices which only used in CK3 process  
LAYER HVPWi          351 
LAYER MAP 95 DATATYPE 0 351 //  High voltge PWELL for HV process
LAYER HVNWi           99  //   For HV process
LAYER ROX            352 
LAYER MAP 141 DATATYPE 101 352 //  Define HV resurf oxide region
LAYER NOPW            116  //  LV psub for HV device
LAYER NONLDDi        353 
LAYER MAP 127 DATATYPE 3 353 //  To define MOS without LDD
LAYER NTN            354 
LAYER MAP 129 DATATYPE 0 354 //  Native NMOS blocked implant
LAYER NTNDMY         355 
LAYER MAP 129 DATATYPE 1 355 //  dummy layer to define native device in HV epi process, for LVS used
LAYER NT_N2i         356 
LAYER MAP 129 DATATYPE 2 356 //  Native NMOS without ldd
LAYER MTP_2T2C       357 
LAYER MAP 122 DATATYPE 3 357 //  layer to define MTP_2T2C IP region
LAYER H18VNWDMY      358 
LAYER MAP 122 DATATYPE 4 358 //  layer to define 18V NW region
LAYER MIM_10F        359 
LAYER MAP 131 DATATYPE 10 359 // dummy layer to form MIM capacitor with 1.0fF capacitance per unit area.
LAYER MIM_15F        360 
LAYER MAP 131 DATATYPE 15 360 // dummy layer to form MIM capacitor with 1.5fF capacitance per unit area.
LAYER MIM_20F        361 
LAYER MAP 131 DATATYPE 20 361 // dummy layer to form MIM capacitor with 2.0fF capacitance per unit area.
LAYER MIM_3T         362 
LAYER MAP 131 DATATYPE 21 362 // dummy layer for three terminals capacitor.
LAYER CTMDMYUD       363 
LAYER MAP 131 DATATYPE 50 363 //  Please add CTMDMYUD to allow putting devices under 2T BB mimcap Devices (mimcap use only)
LAYER RLPPDMY         134  //  dummy layer to form hir resistor
LAYER VARDMY          138  //  dummy layer to form mos varactory
LAYER INDDMY          139  //  dummy layer to form spiral inductor
LAYER SH_Pi          364 
LAYER MAP 141 DATATYPE 1 364 //  Shielding Pwell
LAYER SH_N           365 
LAYER MAP 141 DATATYPE 2 365 //  Shielding Nwell
LAYER DPW            366 
LAYER MAP 141 DATATYPE 51 366 //   FOR HV_40 device
LAYER HV40DMY        367 
LAYER MAP 141 DATATYPE 52 367 //  layer to form all HV devices.
LAYER HVDMY2         368 
LAYER MAP 141 DATATYPE 53 368 //  layer to separate different voltage device in the same process 
LAYER PA24DMY        369 
LAYER MAP 141 DATATYPE 60 369 //  dummy layer to form pa24g5 device.
LAYER NLD24DMY       370 
LAYER MAP 141 DATATYPE 61 370 //  dummy layer to form nld24g5 device.
LAYER NLVT           371 
LAYER MAP 141 DATATYPE 63 371 //  dummy layer to define low Vt 5V NMOS for 0.18um BCD process
LAYER HVGA           372 
LAYER MAP 141 DATATYPE 54 372 //   dummy layer to form GA devices
LAYER HVGB           373 
LAYER MAP 141 DATATYPE 55 373 //   dummy layer to form GB devices
LAYER HV6DMY         374 
LAYER MAP 141 DATATYPE 72 374 //   dummy layer to form 6v devices
LAYER HV9DMY         375 
LAYER MAP 141 DATATYPE 92 375 //   dummy layer to form 9v devices
LAYER HV8DMY         376 
LAYER MAP 141 DATATYPE 73 376 //   dummy layer to form 8v devices
LAYER HV12DMY        377 
LAYER MAP 141 DATATYPE 67 377 //   dummy layer to form 12v devices
LAYER HV16DMY        378 
LAYER MAP 141 DATATYPE 74 378 //   dummy layer to form 16v devices
LAYER HV20DMY        379 
LAYER MAP 141 DATATYPE 75 379 //   dummy layer to form 20v devices
LAYER HV24DMY        380 
LAYER MAP 141 DATATYPE 76 380 //   dummy layer to form 24v devices
LAYER HV29DMY        381 
LAYER MAP 141 DATATYPE 77 381 //   dummy layer to form 29v devices
LAYER HV28DMY        382 
LAYER MAP 141 DATATYPE 78 382 //   dummy layer to form 28v devices
LAYER HV36DMY        383 
LAYER MAP 141 DATATYPE 79 383 //   dummy layer to form 36v devices
LAYER HV45DMY        384 
LAYER MAP 141 DATATYPE 80 384 //   dummy layer to form 45v devices
LAYER HV55DMY        385 
LAYER MAP 141 DATATYPE 81 385 //   dummy layer to form 55v devices
LAYER HV65DMY        386 
LAYER MAP 141 DATATYPE 82 386 //   dummy layer to form 65v devices
LAYER HV70DMY        387 
LAYER MAP 141 DATATYPE 83 387 //   dummy layer to form 70v devices
LAYER HV5DMY         388 
LAYER MAP 141 DATATYPE 84 388 //   dummy layer to form 5v devices
LAYER HV7DMY         389 
LAYER MAP 141 DATATYPE 87 389 //   dummy layer to form 7v devices
LAYER SBDUMMY        390 
LAYER MAP 144 DATATYPE 0 390 //  dummy layer to form schottky diode
LAYER SBDDMY_3T      391 
LAYER MAP 144 DATATYPE 2 391 //  dummy layer to form 3t schottky diode
LAYER HVLOWR         392 
LAYER MAP 141 DATATYPE 202 392 //  For HVMOS low Ron device definition
LAYER LVISO          393 
LAYER MAP 141 DATATYPE 154 393 //  Define LV  isolation region
LAYER HV8ISO         394 
LAYER MAP 141 DATATYPE 150 394 //  Define HV8  isolation region
LAYER HV29ISO        395 
LAYER MAP 141 DATATYPE 151 395 //  Define HV29 isolation region
LAYER HV45ISO        396 
LAYER MAP 141 DATATYPE 152 396 //  Define HV45 isolation region
LAYER HV70ISO        397 
LAYER MAP 141 DATATYPE 153 397 //  Define HV70 isolation region
LAYER HV9ISO         398 
LAYER MAP 141 DATATYPE 155 398 //  Define HV9  isolation region
LAYER SDI            399 
LAYER MAP 58 DATATYPE 0 399 //  ESD DMY
LAYER SDI_V2         400 
LAYER MAP 58 DATATYPE 1 400 //  ESD DMY for V2 HV device
LAYER SDI_V3         401 
LAYER MAP 58 DATATYPE 2 401 //  ESD DMY for V3 HV device
LAYER NDDi           402 
LAYER MAP 141 DATATYPE 50 402 // definition of HV device N deep drain (NDD) implantation of HV device
LAYER PDDi           403 
LAYER MAP 141 DATATYPE 49 403 // definition of HV device P deep drain (PDD) implantation of HV device
LAYER MHMDMY         404 
LAYER MAP 141 DATATYPE 66 404 //  dummy layer for MHM device
LAYER HV18DMY        405 
LAYER MAP 141 DATATYPE 68 405 //  To define HV 18V device pattern.
LAYER HV32DMY        406 
LAYER MAP 141 DATATYPE 69 406 //  To define HV 32V device pattern
LAYER HV60DMY        407 
LAYER MAP 141 DATATYPE 70 407 //  To define HV 60V devices pattern.
LAYER MOMDMY0        408 
LAYER MAP 145 DATATYPE 0 408 //  MOM dummy for crtmom
LAYER MOMDMY1        409 
LAYER MAP 145 DATATYPE 1 409 //  MOM dummy for crtmom
LAYER MOMDMY2        410 
LAYER MAP 145 DATATYPE 2 410 //  MOM dummy for crtmom
LAYER MOMDMY3        411 
LAYER MAP 145 DATATYPE 3 411 //  MOM dummy for crtmom
LAYER MOMDMY4        412 
LAYER MAP 145 DATATYPE 4 412 //  MOM dummy for crtmom
LAYER MOMDMY5        413 
LAYER MAP 145 DATATYPE 5 413 //  MOM dummy for crtmom
LAYER MOMDMY6        414 
LAYER MAP 145 DATATYPE 6 414 //  MOM dummy for crtmom
LAYER MOMDMY22       415 
LAYER MAP 145 DATATYPE 22 415 //  MOM dummy for MX mom
LAYER MOMDMY23       416 
LAYER MAP 145 DATATYPE 23 416 //  MOM dummy for MX mom plus1 & minus1
LAYER MOMDMY24       417 
LAYER MAP 145 DATATYPE 24 417 //  MOM dummy for MX mom plus2 & minus2
LAYER MOMDMY25       418 
LAYER MAP 145 DATATYPE 25 418 //  MOM dummy for MX mom plus1 & plus2
LAYER MOMDMY100      419 
LAYER MAP 145 DATATYPE 100 419 //  MOM dummy for cfmom
LAYER MOMDMY34       420 
LAYER MAP 145 DATATYPE 34 420 //  MOM dummy for cfmom_tm_m1_0d23
LAYER MOMDMY35       421 
LAYER MAP 145 DATATYPE 35 421 //  MOM dummy for cfmom_tm_m1_0d28
LAYER MOMDMY36       422 
LAYER MAP 145 DATATYPE 36 422 //  MOM dummy for cfmom_m1_0d23 
LAYER MOMDMY37       423 
LAYER MAP 145 DATATYPE 37 423 //  MOM dummy for cfmom_m1_0d28
LAYER MOMDMYBB       424 
LAYER MAP 145 DATATYPE 27 424 //  MOM dummy for 2t cfmom
LAYER RFDUMMY1       425 
LAYER MAP 160 DATATYPE 1 425 //  FOR RF device additional terminal dummy layer
LAYER DTI            426 
LAYER MAP 171 DATATYPE 0 426 //  DTI RING
LAYER DMP2V           149  //  Dummy layer to ensure P2V in P+ poly resistor when P2V is derived from logic operation
LAYER RFDUMMY         160  //   FOR normal RF device dummy layer
LAYER RFDUMMYUD      427 
LAYER MAP 160 DATATYPE 50 427 //  Please change RFDMY to be RFDMYUD to allow putting devices under w/i shield RF mimcap Devices (mimcap use only)
LAYER PLMIDE         428 
LAYER MAP 89 DATATYPE 0 428 //  Polyimide
LAYER VIAD            167  //  Via above MT to connect MT and MD for redistribution
LAYER MD              168  //  Metal above MT for redistribution (under passivation)
LAYER CBD             169  //  passivation window for bump
LAYER UBM             170  //  Under bump metal
LAYER CB              19  //  passivation-1 via hole between Mu and AP-MD for wire bond
LAYER RV              188  //  Via hole for AlCu Redistributional layer (Al RDL) between AP and Mtop
LAYER AP             429 
LAYER MAP 189 DATATYPE 1 429 //  AlCu bonding Pad, AlCu Redistributional layer (Al RDL)
LAYER NBLi            179  //   Implant with arsenic to form low resistive paths for the NPN collectors, for HV process
LAYER NBLSLOTi       430 
LAYER MAP 179 DATATYPE 1 430 //  NBL slot 
LAYER HVOX            180  //   HVOX for HV process
LAYER MACRODMY       431 
LAYER MAP 182 DATATYPE 1 431 //  dummy layer to form  macro model devices.
LAYER EMRDMY         432 
LAYER MAP 182 DATATYPE 10 432 //  EMDMY
LAYER HVSW28DMY      433 
LAYER MAP 182 DATATYPE 14 433 // dummy layer to define HV BV>28V switch loe Ron device
LAYER HVSW40DMY      434 
LAYER MAP 182 DATATYPE 15 434 // dummy layer to define HV BV>40V switch loe Ron device
LAYER HVSW50DMY      435 
LAYER MAP 182 DATATYPE 16 435 // dummy layer to define HV BV>50V switch loe Ron device
LAYER FGDDMY         436 
LAYER MAP 182 DATATYPE 20 436 // dummy layer to define the FGD  device and the specific NGD devices which paired with FGD devices
LAYER DMN2V           184  //  Dummy layer to ensure N2V in N+ poly resistor when N2V is derived from logic operation
LAYER HVPBi2          202  //  drawing layer for HV P-BODY layer
LAYER LVSDMY         437 
LAYER MAP 208 DATATYPE 1 437 //  dummy layer to form mismatch model devices.
LAYER LDPW           438 
LAYER MAP 141 DATATYPE 32 438 //  P-Well region of LDNMOS.
LAYER HVTP            143  //  FOR HV_40 PMOS
LAYER HVTN            142  //  FOR HV_40 NMOS
LAYER VTMP            23  //  blocking region of PMOS VT implantation
LAYER VTMN            24  //  blocking region of NMOS VT implantation
LAYER DOD            439 
LAYER MAP 3 DATATYPE 1 439 //  OD dummy fill
LAYER DPO            440 
LAYER MAP 13 DATATYPE 1 440 //  Poly Si dummy
LAYER HVFPO          441 
LAYER MAP 13 DATATYPE 4 441 //  HV FLOATING POLY
LAYER DNW             82  //  Deep NWELL 
LAYER CTMDMY         442 
LAYER MAP 131 DATATYPE 0 442 //  dummy layer to form mimcap
LAYER ESD3DMY         234  //  ESD3DMY
LAYER LVGDMY         443 
LAYER MAP 209 DATATYPE 1 443 //  Low Vg model devices dummy layer 
LAYER POFUSE         444 
LAYER MAP 232 DATATYPE 0 444 //  dummy layer for poly fuse
LAYER AP_Cu          445 
LAYER MAP 189 DATATYPE 20 445 //  AP_CU layer
LAYER HLMIMCAP1P0    446 
LAYER MAP 131 DATATYPE 11 446 //  dummy layer for 1p0 hlmim cap
LAYER M0             447 
LAYER MAP 210 DATATYPE 0 447 //  landing pad for SiCr TFR
LAYER MSi            448 
LAYER MAP 210 DATATYPE 1 448 //  resistor for SiCr TFR
LAYER SICR_V1        449 
LAYER MAP 210 DATATYPE 2 449 //  Via1 belog to SiCr TFR
LAYER SLITDMY        450 
LAYER MAP 182 DATATYPE 12 450 //  for 5v switch device
LAYER LVPWRDMY       451 
LAYER MAP 182 DATATYPE 13 451 //  for 5v switch device
LAYER Bias25VNDMY    452 
LAYER MAP 182 DATATYPE 90 452 //  25V biasNDMY layer for isolation, used for HV BV in LV PMOS area
LAYER CFP            453 
LAYER MAP 15 DATATYPE 2 453 // Define HV contact field plate 
LAYER RSEPDUMMY      454 
LAYER MAP 54 DATATYPE 4 454 //  A dummy layer for LVS serpentine resistor length calculation
TEXT LAYER 40 ATTACH 40 metal1
PORT LAYER TEXT 40
TEXT LAYER 41 ATTACH 41 metal2
PORT LAYER TEXT 41
TEXT LAYER 42 ATTACH 42 metal3
PORT LAYER TEXT 42
TEXT LAYER 43 ATTACH 43 metal4
PORT LAYER TEXT 43
TEXT LAYER 44 ATTACH 44 metal5
PORT LAYER TEXT 44
#IFDEF RC_DECK
TEXT LAYER 47 ATTACH 47 poly
PORT LAYER TEXT 47
#ENDIF

#IFNDEF RC_DECK
LAYER MAP 47 TEXTTYPE 1 455
TEXT LAYER 455 ATTACH 455 poly
PORT LAYER TEXT 455
#ENDIF
//#############################################
//# LOGIC OPERATION POOL                      #
//#############################################

//Form BULK layer
DRC:1 = EXTENT
BULK  = SIZE DRC:1 BY 0.005

//* Define device -- nmos N
POLY1_1 = POLY1i OR DPO 
POLY1 = POLY1_1 OR HVFPO 
RPDMYa1 = RPDMYX OR RPDMY1 
RPDMYa = RPDMYa1 OR RPDMY2 
diff1 = OD OR DOD 
diff = diff1 NOT RODMY 
rp1 = RPDMYa NOT INTERACT diff 
p1rdum = rp1 INTERACT POLY1  //  poly1 resistor dummy
respa = POLY1 AND p1rdum 
resp = respa INTERACT POLY1i 
polya = POLY1 NOT resp 
poly = polya NOT POFUSE 
drdum = RPDMYa INTERACT diff  //  diff resistor dummy
resd = diff AND drdum  //  diff resistor layer
mdiff_1 = diff NOT resd 
RWDMYa1 = RWDMYX OR RWDMY1 
RWDMYa2 = RWDMYa1 OR RWDMY2 
SH_P_RWDMY = SH_Pi AND RWDMYa2 
RWDMYa = RWDMYa2 NOT SH_P_RWDMY 
rwdmy_HVPBi = HVPBi2 AND RWDMYa 
rwdmy_pddi = PDDi AND RWDMYa 
rwdmy_hv_1 = rwdmy_HVPBi OR rwdmy_pddi 
rwdmy_nddi = NDDi AND RWDMYa 
rwdmy_hv_2 = rwdmy_hv_1 OR rwdmy_nddi 
rwdmy_hv_3 = rwdmy_hv_2 AND diff 
rwdmy_hv = rwdmy_hv_3 INTERACT RPO 
mdiff = mdiff_1 NOT rwdmy_hv 
gate1a = poly AND mdiff 
mdiff_mos = mdiff INTERACT POLY1i
mdiff_expand = EXPAND EDGE mdiff_mos OUTSIDE BY 0.001
mdiff_inside = mdiff_expand INSIDE POLY1i
mdiff_inside_edge = mdiff_inside TOUCH EDGE mdiff_mos
ldgate_extra = INT mdiff_inside_edge POLY1i < 20 OPPOSITE REGION
ldgate_extra_s = EXPAND EDGE ldgate_extra OUTSIDE BY 0.001
ldgate_extra_up = ldgate_extra_s NOT POLY1i
ldgatecap = ldgate_extra OR ldgate_extra_up
gate_tempa= POLY1i AND mdiff
gate_tempb= SIZE gate_tempa BY 0.005
gate_tempc= gate_tempb AND mdiff
gate_temp = gate_tempa OR gate_tempc
gate = gate_temp OR ldgatecap
gate1 = gate1a INTERACT gate 
DIODMY_1 = DIODMY OR DIO4TDMY 
DIODMYa = DIODMY_1 OR DIO3TDMY 
gate2 = gate1 NOT DIODMYa 
BJTDMY_all_1 = BJTDMY OR BJTDMY_4t 
BJTDMY_all_2 = BJTDMY_all_1 OR BJTDMY_5t 
BJTDMY_all = BJTDMY_all_2 OR BJTDMY_7t 
gate3 = gate2 NOT BJTDMY_all  // exculde bjt_poly
MOMDMY = MOMDMY0 OR MOMDMY100 
BB_UNDER_MOM = MOMDMY INTERACT MOMDMYBB 
REAL_MOMDMY0 = MOMDMY NOT BB_UNDER_MOM 
gate_all = gate3 NOT INTERACT REAL_MOMDMY0 
HVDMY = HV45DMY OR HV40DMY 
gate_lv1 = gate_all NOT HVDMY 
gate_lv = gate_lv1 NOT FGDDMY 
tngate1 = gate_lv AND NIMP 
psub2_ring1 = SIZE PSUB2 BY 0.01 
psub2_ring = psub2_ring1 NOT PSUB2 
n_psub = BULK NOT psub2_ring 
iso_hvnwa1 = HVNWi NOT HVDMY 
HVPBi = HVPBi2 NOT RWDMYa 
iso_hvnwa = iso_hvnwa1 NOT HVPBi 
ANWEL1 = NWELL OR iso_hvnwa 
ANWEL = ANWEL1 OR SH_N 
psuby = n_psub NOT ANWEL 
HVPWa = HVDMY NOT SH_N 
rhvpw1 = HVPWa AND RWDMYa 
psuby1 = psuby NOT rhvpw1 
HVNWia = HVNWi NOT HVPBi 
psub_a = psuby1 NOT HVNWia 
NDD1 = NDDi NOT RWDMYa 
PW5V = OD2 NOT NWELL 
NDD = NDD1 NOT PW5V 
NDDa = NDD NOT HVPBi 
psub = psub_a NOT NDDa 
tngate = tngate1 AND psub 
ngate1 = tngate NOT OD2 
ngate2 = ngate1 NOT NTN 
#IFDEF MACRO 
MAC = COPY OD
#ELSE
MAC = OD NOT (SIZE OD BY 0.005)
#ENDIF
ngate = ngate2 NOT MAC  //  1.8V core normal nmos

//* Define device -- nmos nch_mac
ngate_mis = ngate2 AND MAC  //  mismatch 1.8V core normal nmos

//* Define device -- nmos nch_dep5
ngate_5 = tngate AND OD2 
bngate1_1 = ngate_5 NOT INTERACT H18VNWDMY 
bngate1 = bngate1_1 NOT NLVT 
bngate1_dep = bngate1 AND VTDN 
bngate_dep = bngate1_dep NOT MAC 

//* Define device -- nmos nch_dep5_mac
bngate_dep_mis = bngate1_dep AND MAC 

//* Define device -- nmos ND
bngate2 = bngate1 NOT VTDN 
bngate3 = bngate2 NOT NTN 
bngate4 = bngate3 NOT SLITDMY 
bngate5 = bngate4 NOT LVPWRDMY 
bngate6 = bngate5 NOT NDD1 
bngate = bngate6 NOT MAC  //  5.0V I/O  normal nmos

//* Define device -- nmos nch_5_mac
bngate_mis = bngate6 AND MAC  //  mismatch 5.0V I/O  normal nmos

//* Define device -- nmos nch_5_fgd_mac
gate_lv_fgd = gate_lv1 AND FGDDMY 
tngate_fgd1 = gate_lv_fgd AND psub 
tngate_fgd = tngate_fgd1 INTERACT NIMP 
bngate_ngd1 = tngate_fgd AND OD2 
bngate_fgd = bngate_ngd1 INTERACT PIMP 

//* Define device -- nmos nch_5_ngd_mac
bngate_ngd = bngate_ngd1 NOT INTERACT PIMP 

//* Define device -- nmos nanch_biso
nlgate1 = ngate1 AND NTN 
nlgate1_1 = nlgate1 AND NTNDMY 
nlgate = nlgate1_1 NOT MAC  //  1.8v native NMOS

//* Define device -- nmos nanch_biso_mac
nlgate_mis = nlgate1_1 AND MAC 

//* Define device -- nmos nanch5_biso
bnlgate1 = bngate2 AND NTN 
bnlgate2 = bnlgate1 AND NTNDMY 
bnlgate3 = bnlgate2 NOT INTERACT NT_N2i 
bnlgate = bnlgate3 NOT MAC 

//* Define device -- nmos nanch5_biso_mac
bnlgate_mis = bnlgate3 AND MAC 

//* Define device -- nmos nanch5_biso_wo
bnlgate4 = bnlgate2 INTERACT NT_N2i 
bnlgate_wo = bnlgate4 NOT MAC 

//* Define device -- nmos nanch5_biso_wo_mac
bnlgate_wo_mis = bnlgate4 AND MAC 

//* Define device -- pmos P
tpgate1 = gate_lv AND PIMP 
nxwell = NWELL NOT RWDMYa 
tpgate2 = tpgate1 AND nxwell 
tpgate3 = tpgate2 NOT LVPWRDMY 
tpgate = tpgate3 NOT HVLOWR 
pgate1 = tpgate NOT OD2 
od2_holes = HOLES OD2 
Bias25VN_iso = od2_holes AND Bias25VNDMY 
pgate2 = pgate1 NOT Bias25VN_iso 
pgate = pgate2 NOT MAC  //  1.8V core normal pmos

//* Define device -- pmos pch_mac
pgate_mis = pgate2 AND MAC  //  mismatch 1.8V core normal pmos

//* Define device -- pmos PD
bpgate1 = tpgate AND OD2 
bpgate1_1 = bpgate1 NOT NLVT 
bpgate1_2 = bpgate1_1 NOT Bias25VN_iso 
bpgate1_3 = bpgate1_2 NOT PDDi 
bpgate = bpgate1_3 NOT MAC  //  5.0V I/O  normal pmos

//* Define device -- pmos pch_5_mac
bpgate_mis = bpgate1_3 AND MAC  //  mismatch 5.0V I/O  normal pmos

//* Define device -- xdev nch_hv5_5vnw_ac
ioldnmos_r1 = ngate_5 AND MTP_2T2C 
ioldnmos_r2 = ioldnmos_r1 INTERACT NLVT 
H18NW = nxwell AND H18VNWDMY 
ioldnmos_reg_1 = ioldnmos_r2 INTERACT H18NW  //   NCH_HV5_5VNW_AC reg layer
NBL = NBLi NOT RWDMYa 
shp_region_1 = HVDMY AND HVGA 
shp_region_2 = HOLES shp_region_1 
shp_region = shp_region_1 OR shp_region_2 
HVNWNBLPSUBSHP_ISO = NBL INTERACT shp_region 
psub_in_nbl_1 = BULK AND NBL 
psub_in_nbl_2a = psub_in_nbl_1 NOT HVNWi 
psub_in_nbl_2 = psub_in_nbl_2a NOT SH_N 
psub_in_nbl_3 = psub_in_nbl_2 INTERACT psub 
psub_in_nbl = psub_in_nbl_3 NOT INTERACT DPW 
pwnblhvnw_5_iso_reg = psub_in_nbl AND OD2  //  5V NW/PW diode
nch5_lvt_gb_exclude1 = HVNWNBLPSUBSHP_ISO AND pwnblhvnw_5_iso_reg 
ioldnmos_reg = ioldnmos_reg_1 NOT nch5_lvt_gb_exclude1 

//* Define device -- xdev na20_g5a_cfp_mac
nthin = mdiff AND NIMP  //  define N+ thin oxide
ioldnmos_l = ioldnmos_reg NOT NLVT  //   NCH_HV5_5VNW_AC length

//* Define device -- bjt pnp10_rpo
pthin = mdiff AND PIMP  //  define P+ thin oxide
tpdiff_1 = pthin NOT gate1  //  define P+ diffusion region
bjt_poly = POLY1i AND BJTDMY_all 
tpdiff_all = tpdiff_1 NOT bjt_poly 
ttdiff1 = tpdiff_all AND BJTDMY 
ttdiff = ttdiff1 NOT HVDMY 
nbasea = nxwell AND BJTDMY 
nbaseb = nbasea NOT INTERACT NBL  //  define BJT[PV] base terminal
nbase = nbaseb NOT OD2 
emit1 = ttdiff AND nbase  //  define BJT[PV] emitter
emit_rpo = emit1 INTERACT RPO 
emit10_tmp_rpo = AREA emit_rpo  > 99.999  < 100.001 
emit10_rpo = emit10_tmp_rpo NOT LVSDMY 

//***** Define connectivity/via layer -- coll ****
collsur = psub NOT HVDMY 
colls = collsur TOUCH nbase 
coll1 = colls OR nbase  //   define BJT[PV] collector
emit1_1 = emit1 NOT INTERACT RPO 
emit = emit1_1 NOT INTERACT POLY1i 
coll = coll1 NOT emit 

//* Define device -- bjt pnp5_rpo
emit5_tmp_rpo = AREA emit_rpo  > 24.999  < 25.001 
emit5_rpo = emit5_tmp_rpo NOT LVSDMY 

//* Define device -- bjt pnp2_rpo
emit2_tmp_rpo = AREA emit_rpo  > 3.999  < 4.001 
emit2_rpo = emit2_tmp_rpo NOT LVSDMY 

//* Define device -- bjt pnp10_5_poly
ionbase = nbaseb AND OD2 
ioemit1 = ttdiff AND ionbase  //  define BJT[P1] base terminal 5V
ioemit_poly = ioemit1 INTERACT POLY1i 
ioemit10_1_poly = AREA ioemit_poly  > 99.999  < 100.001 
ioemit10_2_poly = ioemit10_1_poly NOT INTERACT RPO 
ioemit10_poly = ioemit10_2_poly NOT LVSDMY 

//***** Define connectivity/via layer -- iocoll ****
iocolls = collsur TOUCH ionbase 
iocoll1 = iocolls OR ionbase  //   define BJT[PV] collector
ioemit = ioemit1 NOT INTERACT POLY1i 
iocoll = iocoll1 NOT ioemit 

//* Define device -- bjt pnp5_5_poly
ioemit5_1_poly = AREA ioemit_poly  > 24.999  < 25.001 
ioemit5_2_poly = ioemit5_1_poly NOT INTERACT RPO 
ioemit5_poly = ioemit5_2_poly NOT LVSDMY 

//* Define device -- bjt pnp2_5_poly
ioemit2_1_poly = AREA ioemit_poly  > 3.999  < 4.001 
ioemit2_2_poly = ioemit2_1_poly NOT INTERACT RPO 
ioemit2_poly = ioemit2_2_poly NOT LVSDMY 

//* Define device -- xdev pnp10_rpo_mis
emit10_rpo_mis = emit10_tmp_rpo AND LVSDMY 

//* Define device -- xdev pnp5_rpo_mis
emit5_rpo_mis = emit5_tmp_rpo AND LVSDMY 

//* Define device -- xdev pnp2_rpo_mis
emit2_rpo_mis = emit2_tmp_rpo AND LVSDMY 

//* Define device -- xdev pnp10_5_poly_mis
ioemit10_poly_mis = ioemit10_2_poly AND LVSDMY 

//* Define device -- xdev pnp5_5_poly_mis
ioemit5_poly_mis = ioemit5_2_poly AND LVSDMY 

//* Define device -- xdev pnp2_5_poly_mis
ioemit2_poly_mis = ioemit2_2_poly AND LVSDMY 

//* Define device -- bjt pnp10_5_rpo
ioemit10_1 = AREA ioemit  > 99.999  < 100.001 
ioemit10_wiRPO = ioemit10_1 INTERACT RPO 
ioemit10_rpo = ioemit10_wiRPO NOT LVSDMY 

//* Define device -- xdev pnp10_5_rpo_mis
ioemit10_rpo_mis = ioemit10_wiRPO AND LVSDMY 

//* Define device -- diode DP
pdio1 = tpdiff_1 AND DIODMY 
pdio2 = pdio1 AND nxwell 
pdio3 = pdio2 NOT HVDMY 
pdio = pdio3 NOT OD2 

//* Define device -- diode DN
tndiff_1 = nthin NOT gate1  //  define N+ diffusion region
ndio1 = tndiff_1 AND DIODMY 
ndio2 = ndio1 AND psub 
ndio3 = ndio2 NOT HVDMY 
ndio4 = ndio3 NOT ANWEL 
ndio5 = ndio4 NOT OD2 
ndio = ndio5 NOT INTERACT POLY1 

//* Define device -- diode DW
DIONW1 = DIODMY AND ANWEL 
HVNWa = HVNWi AND HVDMY 
HVNWa1 = HVNWa NOT HVPBi 
HVNW = HVNWa1 NOT RWDMYa 
DIONW2 = DIODMY AND HVNW 
DIONW3 = DIONW1 OR DIONW2 
DIONW4 = DIONW3 OUTSIDE tpdiff_1 
DIONW = DIONW4 INTERACT tndiff_1 
nwdio1 = nxwell AND DIONW 
nwdio = nwdio1 NOT OD2  //  1.8V NW/PW diode

//* Define device -- diode D1
pdio_od2 = pdio3 AND OD2 

//* Define device -- diode D2
ndio_od2 = ndio4 AND OD2 

//* Define device -- diode D3
nwdio_od2 = nwdio1 AND OD2  //  5V NW/PW diode

//* Define device -- xdev ndio_sbd_mac
schottky_n1 = mdiff AND NIMP 
schottky_n2 = schottky_n1 AND nxwell 
schottky_n = schottky_n2 AND SBDUMMY 
schottky_body1 = nxwell INTERACT schottky_n 
schottky_p1 = diff CUT PIMP
schottky_p2 = schottky_p1 AND nxwell 
schottky_p = schottky_p2 AND SBDUMMY 
schottky_body2 = schottky_body1 INTERACT schottky_p 
schottky_body3 = schottky_body2 INTERACT SBDUMMY 
schottky_body5 = schottky_body3 AND RFDUMMY1 
sbd_rf_nw1 = schottky_body5 NOT INTERACT DNW 
sbd_rf_nw_od2_1 = sbd_rf_nw1 AND OD2 
sbd_rf_nw_od2 = sbd_rf_nw_od2_1 NOT HVDMY 

//* Define device -- r PR
rpop = resp INTERACT RPO 
prpop1 = rpop AND PIMP 
prpop = prpop1 INTERACT DMP2V 
RPDMY_1 = RPDMYX NOT RPDMY1 
RPDMY = RPDMY_1 NOT RPDMY2 
rpporpo1 = prpop AND RPDMY 
rpporpo2 = rpporpo1 NOT OD2 
rpporpoa = rpporpo2 NOT RPDMY5  //  2T p+po resistor w/o silicide
rpporpo = rpporpoa NOT INTERACT SERPDMY 

//* Define device -- r NR
nrpop1 = rpop AND NIMP 
nrpop = nrpop1 INTERACT DMN2V 
rnporpo1 = nrpop AND RPDMY 
rnporpo2 = rnporpo1 NOT OD2 
rnporpo = rnporpo2 NOT RPDMY5  //  2T n+po resistor w/o silicide

//* Define device -- r PS2
rpip = resp NOT rpop 
prpip = rpip AND PIMP  //  p+po resistor w/i silicide
rppoip_edge = prpip INSIDE EDGE POLY1 
rppoip1 = LENGTH rppoip_edge  >= 2  < 999999 
rppoip2 = prpip WITH EDGE rppoip1 
rppoipw2 = prpip NOT rppoip2 
rppoipw = rppoipw2 AND RPDMY 

//* Define device -- r PS1
rppoip = rppoip2 AND RPDMY 

//* Define device -- r NS2
nrpip = rpip AND NIMP  //  n+po resistor w/i silicide
rnpoip_edge = nrpip INSIDE EDGE POLY1 
rnpoip1 = LENGTH rnpoip_edge  >= 2  < 999999 
rnpoip2 = nrpip WITH EDGE rnpoip1 
rnpoipw2 = nrpip NOT rnpoip2 
rnpoipw = rnpoipw2 AND RPDMY 

//* Define device -- r NS1
rnpoip = rnpoip2 AND RPDMY 

//* Define device -- r PD
resdod = resd INTERACT OD 
rdop = resdod INTERACT RPO 
prdop1 = rdop AND PIMP 
prdop2 = prdop1 INTERACT DMP2V 
prdop3 = prdop2 AND nxwell 
prdop4 = prdop3 AND RPDMY 
prdop5 = prdop4 NOT OD2 
prdop = prdop5 NOT RPDMY5  //  2T P+OD resistor w/o silicide

//* Define device -- r ND
nrdop1 = rdop AND NIMP 
nrdop2 = nrdop1 INTERACT DMN2V 
nrdop3 = nrdop2 NOT nxwell 
nrdop4 = nrdop3 AND RPDMY 
nrdop5 = nrdop4 NOT OD2 
nrdop = nrdop5 NOT RPDMY5  //  2T N+OD resistor w/o silicide

//* Define device -- r PI2
rdip = resdod NOT rdop 
prdip1 = rdip AND PIMP 
prdip = prdip1 AND nxwell  //  P+OD resistor w/i silicide
rpodip_edge = prdip INSIDE EDGE diff 
rpodip1 = LENGTH rpodip_edge  >= 2  < 99999999 
rpodip2 = prdip WITH EDGE rpodip1 
rpodipw2 = prdip NOT rpodip2 
rpodipw = rpodipw2 AND RPDMY 

//* Define device -- r PI1
rpodip = rpodip2 AND RPDMY 

//* Define device -- r NI2
nrdip1 = rdip AND NIMP 
nrdip = nrdip1 NOT nxwell  //  N+OD resistor w/i silicide
rnodip_edge = nrdip INSIDE EDGE diff 
rnodip1 = LENGTH rnodip_edge  >= 2  < 99999999 
rnodip2 = nrdip WITH EDGE rnodip1 
rnodipw2 = nrdip NOT rnodip2 
rnodipw = rnodipw2 AND RPDMY 

//* Define device -- r NI1
rnodip = rnodip2 AND RPDMY 

//* Define device -- r WR
trwell = RWDMYa AND NWELL  //  N-well resistor layer
drpo = diff AND RPO 
nwsti1 = trwell NOT drpo 
RWDMY_1 = RWDMYX NOT RWDMY1 
RWDMY = RWDMY_1 NOT RWDMY2 
nwsti2 = nwsti1 AND RWDMY 
nwsti3 = nwsti2 NOT OD2 
nwsti = nwsti3 NOT RWDMY5  //  2T NWell resistor unter STI

//* Define device -- r WO
nwod1 = trwell AND drpo 
nwod2 = nwod1 AND RWDMY 
nwod3 = nwod2 NOT OD2 
nwod = nwod3 NOT RWDMY5  //  2T NWell resistor unter OD

//* Define device -- xdev rnwod_m
nwod_3t1 = nwod1 AND RWDMY1 
nwod_3t2 = nwod_3t1 NOT OD2 
nwod_3t = nwod_3t2 NOT RWDMY5  //  3T NWell resistor unter OD

//* Define device -- xdev rnwsti_m
nwsti_3t1 = nwsti1 AND RWDMY1 
nwsti_3t2 = nwsti_3t1 NOT OD2 
nwsti_3t = nwsti_3t2 NOT RWDMY5  //  3T NWell resitor unter STI

//* Define device -- xdev rpod_m
rpodip_3t = rpodip2 AND RPDMY1 

//* Define device -- xdev rpodw_m
rpodipw_3t = rpodipw2 AND RPDMY1 

//* Define device -- xdev rpodrpo_m
prdop_3t1 = prdop3 AND RPDMY1 
prdop_3t2 = prdop_3t1 NOT OD2 
prdop_3t = prdop_3t2 NOT RPDMY5  //  3T P+OD resistor w/o silicide

//* Define device -- xdev rnod_m
rnodip_3t = rnodip2 AND RPDMY1 

//* Define device -- xdev rnodw_m
rnodipw_3t = rnodipw2 AND RPDMY1 

//* Define device -- xdev rnodrpo_m
nrdop_3t1 = nrdop3 AND RPDMY1 
nrdop_3t2 = nrdop_3t1 NOT OD2 
nrdop_3t = nrdop_3t2 NOT RPDMY5  //  3T N+OD resistor w/o silicide

//* Define device -- xdev rppo1rpo_dis
rpporpo_3t1 = prpop AND RPDMY1 
rpporpo_3t2 = rpporpo_3t1 NOT OD2 
rpporpo_3t4 = rpporpo_3t2 NOT RPDMY5  //  3T p+po resistor w/o silicide
rpporpo_3t = rpporpo_3t4 NOT INTERACT SERPDMY 

//***** Define connectivity/via layer -- poly_term ****
poly_term1 = POLY1 AND RPDMY1 
poly_term2 = SIZE poly_term1 BY 0.005 
poly_term = poly_term2 NOT poly_term1 

//* Define device -- xdev rppo1w_dis
rppoipw_3t = rppoipw2 AND RPDMY1 

//* Define device -- xdev rppo1_dis
rppoip_3t = rppoip2 AND RPDMY1 

//* Define device -- xdev rnpo1w_dis
rnpoipw_3t = rnpoipw2 AND RPDMY1 

//* Define device -- xdev rnpo1_dis
rnpoip_3t = rnpoip2 AND RPDMY1 

//* Define device -- xdev rnodrpo_pure5v
nrdop6 = nrdop4 AND OD2 
nrdop_p5 = nrdop6 AND RPDMY5  //  2T pure5v N+OD resistor w/o silicide

//* Define device -- xdev rpodrpo_pure5v
prdop6 = prdop4 AND OD2 
prdop_p5 = prdop6 AND RPDMY5  //  2T pure5v P+OD resistor w/o silicide

//* Define device -- xdev rnpo1rpo_pure5v
rnporpo3 = rnporpo1 AND OD2 
rnporpo_p5 = rnporpo3 AND RPDMY5  //  2T pure5v n+po resistor w/o silicide

//* Define device -- xdev rppo1rpo_pure5v
rpporpo3 = rpporpo1 AND OD2 
rpporpo_p5 = rpporpo3 AND RPDMY5  //  2T pure5v p+po resistor w/o silicide

//* Define device -- xdev rnwod_pure5v
nwod4 = nwod2 AND OD2 
nwod_p5 = nwod4 AND RWDMY5  //  2T pure5v NWell resistor under OD

//* Define device -- xdev rnwsti_pure5v
nwsti4 = nwsti2 AND OD2 
nwsti_p5 = nwsti4 AND RWDMY5  //  2T pure5v NWell resitor unter STI

//* Define device -- xdev rnodrpo_pure5v_m
nrdop_3t3 = nrdop_3t1 AND OD2 
nrdop_3t_p5 = nrdop_3t3 AND RPDMY5  //  3T pure5v N+OD resistor w/o silicide

//* Define device -- xdev rpodrpo_pure5v_m
prdop_3t3 = prdop_3t1 AND OD2 
prdop_3t_p5 = prdop_3t3 AND RPDMY5  //  3T pure5v P+OD resistor w/o silicide

//* Define device -- xdev rnpo1rpo_pure5v_dis
rnporpo_3t1 = nrpop AND RPDMY1 
rnporpo_3t3 = rnporpo_3t1 AND OD2 
rnporpo_3t_p5 = rnporpo_3t3 AND RPDMY5  //  3T pure5v n+po resistor w/o silicide

//* Define device -- xdev rppo1rpo_pure5v_dis
rpporpo_3t3 = rpporpo_3t1 AND OD2 
rpporpo_3t_p5 = rpporpo_3t3 AND RPDMY5  //  3T pure5v p+po resistor w/o silicide

//* Define device -- xdev rnwod_pure5v_m
nwod_3t3 = nwod_3t1 AND OD2 
nwod_3t_p5 = nwod_3t3 AND RWDMY5  //  3T pure5v NWell resistor unter OD

//* Define device -- xdev rnwsti_pure5v_m
nwsti_3t3 = nwsti_3t1 AND OD2 
nwsti_3t_p5 = nwsti_3t3 AND RWDMY5  //  3T pure5v NWell resitor unter STI

//* Define device -- xdev rnpo1rpo_dis
rnporpo_3t2 = rnporpo_3t1 NOT OD2 
rnporpo_3t = rnporpo_3t2 NOT RPDMY5  //  3T n+po resistor w/o silicide

//* Define device -- xdev nmoscap
nthin_var1 = nthin AND nxwell 
nthin_var2 = nthin_var1 AND VARDMY 
nthin_var3 = nthin_var2 INTERACT tngate1 
nthin_var = nthin_var3 NOT OD2 
vargt1 = tngate1 AND nxwell 
vargt2 = vargt1 AND VARDMY 
vargt = vargt2 NOT OD2  //  Varactor on thin oxide

//* Define device -- xdev nmoscap_5
nthin_bvar1 = nthin_var3 AND OD2 
nthin_bvar = nthin_bvar1 NOT LVSDMY 
bvargt1 = vargt2 AND OD2 
bvargt = bvargt1 NOT LVSDMY  //  Varactor on thick oxide

//* Define device -- xdev nmoscap_5_mis
nthin_bvar_mis = nthin_bvar1 AND LVSDMY 
bvargt_mis = bvargt1 AND LVSDMY  //  mismatch Varactor on thick oxide

//* Define device -- xdev mimcap_1p0_sin
#IFDEF top_metal_mim
mim_block = CTM4 AND M4
#ELSE
mim_block = CTM3 AND M3
#ENDIF
#IFDEF top_metal_mim
capm4a = mim_block INTERACT VIA4i
#ELSE
capm4a = mim_block INTERACT VIA3i
#ENDIF
#IFDEF top2_thick
capm4b = capm4a NOT INTERACT CTM4
#ELSE
capm4b = COPY capm4a
#ENDIF
RFDUMMYall = RFDUMMY1 OR RFDUMMYUD 
capm4c = capm4b NOT RFDUMMYall 
capm4d = capm4c AND CTMDMY 
capm4 = capm4d NOT CTMDMYUD 
capm4ud1 = capm4b NOT RFDUMMYUD 
capm4ud2 = capm4ud1 NOT CTMDMY 
capm4ud = capm4ud2 AND CTMDMYUD 
capm4udc = capm4 OR capm4ud 
capm4_2t = capm4udc NOT MIM_3T 
capm4_1p0_2t = capm4_2t AND MIM_10F  //  2T M4*CTM5 capacitance is 1.0fF per unit area.

//***** Define connectivity/via layer -- ctm ****
#IFDEF top2_thick 
ctm = COPY CTM3
#ELSE
#IFDEF top_metal_mim 
ctm = COPY CTM4
#ELSE
ctm = COPY CTM3
#ENDIF
#ENDIF

//***** Define connectivity/via layer -- metal3 ****
M3X = M3 OR DUM3 
M3Y = M3X NOT M3SLOT 
RMDMY3 = RMDMY3i OR RMDMY 
M3Z = M3Y AND RMDMY3 
mt3res = M3Z INTERACT M3  //  metal3 resistor
metal3 = M3Y NOT mt3res  //  metal3 interconnect

//***** Define connectivity/via layer -- metal4 ****
M4X = M4 OR DUM4 
M4Y = M4X NOT M4SLOT 
RMDMY4 = RMDMY4i OR RMDMY 
M4Z = M4Y AND RMDMY4 
mt4res = M4Z INTERACT M4  //  metal4 resistor
metal4 = M4Y NOT mt4res 

//***** Define connectivity/via layer -- metal5 ****
M5X = M5 OR DUM5 
M5Y = M5X NOT M5SLOT 
RMDMY5 = RMDMY5i OR RMDMY 
M5Z = M5Y AND RMDMY5 
mt5res = M5Z INTERACT M5  //  metal5 resistor
metal5 = M5Y NOT mt5res 

//***** Define connectivity/via layer -- ctm_via ****
cv4 = VIA4i AND CTM4  //  via for CTM4/M
cv3 = VIA3i AND CTM3  //  via for CTM3/M4
#IFDEF top2_thick 
ctm_via = COPY cv3
#ELSE
#IFDEF top_metal_mim 
ctm_via = COPY cv4
#ELSE
ctm_via = COPY cv3
#ENDIF
#ENDIF

//* Define device -- xdev mimcap_1p0_sin_3t
capm4_3t = capm4 AND MIM_3T 
capm4_1p0_3t = capm4_3t AND MIM_10F  //  3T M4*CTM5 capacitance is 1.0fF per unit area.

//***** Define connectivity/via layer -- mim_term ****
mim_term = SIZE capm4_3t BY 0.005 

//* Define device -- xdev mimcap_2p0_sin
capm4_2p0_2t = capm4_2t AND MIM_20F  //  2T M4*CTM5 capacitance is 2.0fF per unit area.

//* Define device -- xdev mimcap_2p0_sin_3t
capm4_2p0_3t = capm4_3t AND MIM_20F  //  3T M4*CTM5 capacitance is 2.0fF per unit area.

//* Define device -- r M1
M1X = M1 OR DUM1 
M1Y = M1X NOT M1SLOT 
RMDMY1 = RMDMY1i OR RMDMY 
M1Z = M1Y AND RMDMY1 
mt1res = M1Z INTERACT M1  //  metal1 resistor

//***** Define connectivity/via layer -- metal1 ****
metal1 = M1Y NOT mt1res  //  metal1 interconnect

//* Define device -- r M2
M2X = M2 OR DUM2 
M2Y = M2X NOT M2SLOT 
RMDMY2 = RMDMY2i OR RMDMY 
M2Z = M2Y AND RMDMY2 
mt2res = M2Z INTERACT M2  //  metal2 resistor

//***** Define connectivity/via layer -- metal2 ****
metal2 = M2Y NOT mt2res  //  metal2 interconnect

//* Define device -- nmos nch5_lvt_dd
bngate_dd1 = bngate5 AND NDD1 
bngate_dd = bngate_dd1 NOT MAC 

//* Define device -- nmos nch5_lvt_dd_mac
bngate_dd_mis = bngate_dd1 AND MAC  //  mismatch 5.0V I/O  normal nmos

//* Define device -- pmos pch5_lvt_dd
bpgate_dd1 = bpgate1_2 AND PDDi 
bpgate_dd = bpgate_dd1 NOT MAC  //  5.0V I/O  normal pmos

//* Define device -- pmos pch5_lvt_dd_mac
bpgate_dd_mis = bpgate_dd1 AND MAC  //  mismatch 5.0V I/O  normal pmos

//* Define device -- xdev pch5_as_switch_mac
gate_hv = gate_all AND HVDMY 
pgate_hvpmos = gate_hv INTERACT PIMP  // because pa6g5_de doesn't fully cover by pimp
pgate_hvpmos_ga2 = pgate_hvpmos AND HVGA 
pch5_as_sw_reg_1 = pgate_hvpmos_ga2 AND HV5DMY 
pch5_as_sw_reg_2 = pch5_as_sw_reg_1 AND MACRODMY 
pch5_as_sw_reg_3 = pch5_as_sw_reg_2 INTERACT NONLDDi 
pch5_as_sw_reg_4 = pch5_as_sw_reg_3 AND SH_N 
pch5_as_sw_reg = pch5_as_sw_reg_4 AND NBL 

//***** Define connectivity/via layer -- tpdiff_s ****
tpdiff_s = tpdiff_1 INTERACT NONLDDi 

//***** Define connectivity/via layer -- psub_term_ac ****
psub_term = psub NOT NBLi 
NBL_ac = NBL INTERACT HVDMY 
HVNW_ac = HVNWi INTERACT HVDMY 
ALL_FT_ac1 = NBL_ac OR HVNW_ac 
BJTDMY_ac = NBL INTERACT BJTDMY_4t 
ALL_FT_ac2 = ALL_FT_ac1 OR BJTDMY_ac 
NDD_ac = NDD1 INTERACT HVDMY 
ALL_FT_ac = ALL_FT_ac2 OR NDD_ac 
psub_term_ac = psub_term OR ALL_FT_ac 

//* Define device -- xdev nld6_g5a_sa_iso_v2_mac
ngate_hvnmos = gate_hv INTERACT NIMP  // Because nld6g5_de & ga doesn't fully cover nimp
ngate_hvnmos_ga2 = ngate_hvnmos AND HVGA 
ngate_hvnmos_ga3 = ngate_hvnmos_ga2 INTERACT NDD1 
ngate_hvnmos_ga = ngate_hvnmos_ga3 AND MACRODMY 
ngate_hvnmos_ga_iso_1 = ngate_hvnmos_ga AND NBL 
ngate_hvnmos_ga_iso_2 = COPY ngate_hvnmos_ga_iso_1 
ngate_hvnmos_ga_iso_3 = ngate_hvnmos_ga_iso_2 AND HVPBi 
ngate_hvnmos_ga_iso_4 = COPY ngate_hvnmos_ga_iso_3 
shn_hole = HOLES SH_N INNER
sh_n_hvnw = NDD1 INTERACT shn_hole 
ngate_hvnmos_ga_iso_41 = ngate_hvnmos_ga_iso_4 AND sh_n_hvnw 
nld6_g5_iso_mac = ngate_hvnmos_ga_iso_41 AND HV6DMY 
nld6_g5_sa_iso_mac_reg = nld6_g5_iso_mac NOT INTERACT RPO 
nld6_g5_sa_iso_v2_mac_rega = nld6_g5_sa_iso_mac_reg AND NOPW 
nld6_g5_sa_iso_v2_mac_reg = nld6_g5_sa_iso_v2_mac_rega AND SLITDMY 

//* Define device -- xdev nda45_g3b_nbl_cfp_mac
hvndf1 = tndiff_1 AND HVDMY 
hvndfs = hvndf1 INTERACT gate_hv 

//***** Define connectivity/via layer -- hvndfd_ndd ****
hvndfd_ndd1 = NDD1 INTERACT hvndf1 
hvndfd_ndd = hvndfd_ndd1 NOT HVPBi 

//* Define device -- xdev nld6_g5a_de_iso_v2_mac
nld6_g5_de_iso_mac_rega = nld6_g5_iso_mac INTERACT RPO 
SLITDMY_nopw = SLITDMY INTERACT NOPW 
nld6_g5_de_iso_mac_reg = nld6_g5_de_iso_mac_rega AND SLITDMY_nopw 

//* Define device -- xdev nld6_g5a_de_mac
nld_g5a_mac_reg1 = ngate_hvnmos_ga2 AND MACRODMY 
nld_g5a_mac_reg2 = nld_g5a_mac_reg1 INTERACT HVPBi 
nld_g5a_mac_reg3 = nld_g5a_mac_reg2 INTERACT RPO 
nld_g5a_mac_reg4 = nld_g5a_mac_reg3 AND NOPW 
nld_g5a_mac_reg5 = nld_g5a_mac_reg4 AND SLITDMY 
nld_g5a_mac_reg6 = nld_g5a_mac_reg5 NOT NBL 
nld_g5a_mac_reg7 = nld_g5a_mac_reg6 AND HVPBi 
nld6_g5a_de_mac_rega = nld_g5a_mac_reg7 AND HV6DMY 
NDD_sh_n = NDD1 INTERACT SH_N 
nld6_g5a_de_mac_reg = nld6_g5a_de_mac_rega AND NDD_sh_n 

//***** Define connectivity/via layer -- hvmos_poly_sti ****
hvmos_poly_sti1 = gate_tempa OR ldgate_extra 
hvmos_poly_sti2 = hvmos_poly_sti1 AND HVDMY 
hvmos_poly_sti3 = hvmos_poly_sti1 INTERACT ioldnmos_reg 
hvmos_poly_sti = hvmos_poly_sti2 OR hvmos_poly_sti3 

//* Define device -- xdev nld24_g5a_iso_switch_cfp_mac
HVPBa = HVPBi NOT POLY1i 
hvndfd_ndd_area = hvndfd_ndd1 NOT HVPBa 
tndiff_all = tndiff_1 NOT bjt_poly 
nmos_source_slit = tndiff_all INTERACT tpdiff_all 
tnpdiff = nmos_source_slit OR tpdiff_all  // for AS PS calculation

//* Define device -- xdev nld6_g5a_sa_mac
nld6_g5a_sa_mac_rega = nld_g5a_mac_reg2 NOT INTERACT RPO 
nld6_g5a_sa_mac_regb = nld6_g5a_sa_mac_rega AND SLITDMY 
nld6_g5a_sa_mac_regc = nld6_g5a_sa_mac_regb AND NOPW 
nld6_g5a_sa_mac_regd = nld6_g5a_sa_mac_regc NOT NBL 
nld6_g5a_sa_mac_rege = nld6_g5a_sa_mac_regd AND HVPBi 
nld6_g5a_sa_mac_reg = nld6_g5a_sa_mac_rege AND HV6DMY 

//* Define device -- xdev pa6_g5a_de_nbl_v2_mac
pgate_hvpmos_ga3 = pgate_hvpmos_ga2 AND NOPW 
pgate_hvpmos_ga = pgate_hvpmos_ga3 AND MACRODMY 
pgate_hv6vpmos_4 = pgate_hvpmos_ga AND HV6DMY 
RWDMYb = RWDMYa1 OR RWDMY2 
SH_P = SH_Pi NOT RWDMYb 
pgate_hv6vpmos_5 = pgate_hv6vpmos_4 INTERACT SH_P 
pgate_hv6vpmos_6 = pgate_hv6vpmos_5 INTERACT SH_N 
pgate_hv6vpmos_wi_nbl = pgate_hv6vpmos_6 AND NBL 
pa6_g5_de_nbl_mac_reg = pgate_hv6vpmos_wi_nbl INTERACT RPO 

//***** Define connectivity/via layer -- hvpdfs ****
hvpdf1 = tpdiff_1 AND HVDMY 
hvpdf3 = hvpdf1 AND SH_N 
hvpdfs4 = hvpdf3 AND NOPW 
hvnw_touch_shn = NBL INTERACT SH_N 
esd_ga_1 = hvnw_touch_shn AND DIO3TDMY 
esd_ga_2 = esd_ga_1 AND NOPW 
esd_ga_3 = esd_ga_2 AND HVDMY 
esd_ga_4 = esd_ga_3 AND HVGA 
esd_ga_5 = esd_ga_4 AND SDI 
esd_ga_6 = esd_ga_5 NOT EMRDMY 
esd_ga = esd_ga_6 AND tpdiff_1 
esd_ga_shn_1 = esd_ga NOT HVPBi 
esd_ga_shn = esd_ga_shn_1 AND SH_N 
esd_ga_12_v4_3t1 = esd_ga_shn AND HV12DMY 
esd_ga_12_v4_3t2 = esd_ga_12_v4_3t1 INTERACT HVESD1DMY 
esd_ga_shn_hole1 = esd_ga AND shn_hole 
esd_ga_shn_hole = esd_ga_shn_hole1 AND NBL 
esd_ga_20_v2_3t1 = esd_ga_shn_hole AND HV20DMY 
esd_ga_20_v2_3t2 = esd_ga_20_v2_3t1 INTERACT HVESD1DMY 
stack_esd_plus1 = esd_ga_12_v4_3t2 OR esd_ga_20_v2_3t2 
stack_esd_plus = stack_esd_plus1 NOT HVESD2DMY 
hvpdfs5 = hvpdfs4 NOT stack_esd_plus 
hvpdfs = hvpdfs5 INTERACT gate_hv 

//***** Define connectivity/via layer -- hvpdfd_shp ****
hvpdfd_shp1 = SH_P INTERACT hvpdf1 
hvpdfd_shp2 = hvpdfd_shp1 INTERACT gate_hv 
hvpdfd_shp = hvpdfd_shp2 AND NOPW 

//* Define device -- xdev pa6_g5a_sa_nbl_v2_mac
pa6_g5_sa_nbl_mac_reg = pgate_hv6vpmos_wi_nbl NOT pa6_g5_de_nbl_mac_reg 

//* Define device -- xdev nld9_g5a_mac
nld9_g5a_mac_reg = nld_g5a_mac_reg7 AND HV9DMY 

//* Define device -- xdev nld12_g5a_cfp_mac
nld_g5a_cfp_mac_reg1 = nld_g5a_mac_reg6 INTERACT CFP 
nld_g5a_cfp_mac_reg2 = nld_g5a_cfp_mac_reg1 AND HVPBi 
nld12_g5a_cfp_mac_reg = nld_g5a_cfp_mac_reg2 AND HV12DMY 

//* Define device -- xdev nld16_g5a_cfp_mac
nld16_g5a_cfp_mac_reg = nld_g5a_cfp_mac_reg2 AND HV16DMY 

//* Define device -- xdev nld20_g5a_cfp_mac
HV20DMY_EOD = HV20DMY INTERACT EOD 
nld20_g5a_cfp_mac_reg = nld_g5a_cfp_mac_reg2 AND HV20DMY_EOD 

//* Define device -- xdev nld9_g5a_iso_mac
nld_g5a_iso_mac_reg1 = nld_g5a_mac_reg5 AND NBL 
nld_g5a_iso_mac_reg2 = nld_g5a_iso_mac_reg1 AND NDD1 
nld9_g5a_iso_mac_reg1 = nld_g5a_iso_mac_reg2 AND HV9DMY 
nld9_g5a_iso_mac_reg2 = nld9_g5a_iso_mac_reg1 AND HVPBi 
NBL_SH_N = NBL INTERACT SH_N 
nld9_g5a_iso_mac_reg = nld9_g5a_iso_mac_reg2 AND NBL_SH_N 

//* Define device -- xdev nld5_g5a_iso_switch_mac
nld5_g5a_mac_reg2 = nld_g5a_mac_reg2 AND NOPW 
nld5_g5a_mac_reg3 = nld5_g5a_mac_reg2 AND SLITDMY 
nld5_g5a_mac_reg4 = nld5_g5a_mac_reg3 AND NBL 
nld5_g5a_mac_reg5 = nld5_g5a_mac_reg4 AND NDD1 
nld5_g5a_mac_reg6 = nld5_g5a_mac_reg5 AND HV5DMY 
nld5_g5a_mac_reg7 = nld5_g5a_mac_reg6 AND HVPBi 
nld5_g5a_iso_switch_mac_reg = nld5_g5a_mac_reg7 AND NBL_SH_N 

//* Define device -- xdev nld12_g5a_iso_cfp_mac
nld_g5a_iso_cfp_mac_reg1a = nld_g5a_iso_mac_reg2 INTERACT CFP 
nld_g5a_iso_cfp_mac_reg1b = nld_g5a_iso_cfp_mac_reg1a AND HVPBi 
nld_g5a_iso_cfp_mac_reg1 = nld_g5a_iso_cfp_mac_reg1b AND NBL_SH_N 
nld12_g5a_iso_cfp_mac_reg = nld_g5a_iso_cfp_mac_reg1 AND HV12DMY 

//* Define device -- xdev nld24_g5a_cfp_mac
HV24DMY_EOD = HV24DMY INTERACT EOD 
nld24_g5a_cfp_mac_rega = nld_g5a_cfp_mac_reg2 AND HV24DMY_EOD 
nld24_g5a_cfp_mac_reg = nld24_g5a_cfp_mac_rega NOT HVLOWR 

//* Define device -- xdev nld24_g5a_switch_cfp_mac
nld24_g5a_switch_cfp_mac_reg = nld24_g5a_cfp_mac_rega AND HVLOWR 

//* Define device -- xdev nld16_g5a_iso_cfp_mac
nld16_g5a_iso_cfp_mac_reg = nld_g5a_iso_cfp_mac_reg1 AND HV16DMY 

//* Define device -- xdev nld20_g5a_iso_cfp_mac
nld20_g5a_iso_cfp_mac_reg = nld_g5a_iso_cfp_mac_reg1 AND HV20DMY_EOD 

//* Define device -- xdev nld24_g5a_iso_cfp_mac
nld24_g5a_iso_cfp_mac_reg1 = nld_g5a_iso_cfp_mac_reg1 AND HV24DMY_EOD 
NBL_SLOT = NBL INTERACT NBLSLOTi 
nld24_g5a_iso_cfp_mac_reg2 = nld24_g5a_iso_cfp_mac_reg1 AND NBL_SLOT 
nld24_g5a_iso_cfp_mac_reg = nld24_g5a_iso_cfp_mac_reg2 NOT HVLOWR 
nld24_g5a_iso_switch_cfp_mac_reg = nld24_g5a_iso_cfp_mac_reg2 AND HVLOWR 

//* Define device -- xdev pa12_g5a_nbl_v2_mac
pgate_hvpmos_ga_1 = pgate_hvpmos_ga INTERACT RPO 
pgate_hvpmos_ga_2 = pgate_hvpmos_ga_1 INTERACT SH_N 
PDD_a = PDDi NOT RWDMYa 
nw_od2 = NWELL AND OD2 
PDD = PDD_a NOT nw_od2 
pgate_hvpmos_ga_3 = pgate_hvpmos_ga_2 INTERACT PDD 
pgate_hv_pa12_g5a = pgate_hvpmos_ga_3 AND HV12DMY 
pa12_g5a_nbl_mac_reg = pgate_hv_pa12_g5a AND NBL 
pa12_g5a_nbl_v2_mac_reg = pa12_g5a_nbl_mac_reg NOT SLITDMY 

//***** Define connectivity/via layer -- hvpdfd_pdd ****
hvpdfd_pdd1 = PDD INTERACT hvpdf1 
pgthv3 = gate_hv AND PIMP 
pgthv4 = pgthv3 AND HVGA 
hvpdfd_pdd2 = hvpdfd_pdd1 INTERACT pgthv4 
hvpdfd_pdda = hvpdfd_pdd2 AND NOPW 
hvpdfd_pdd = hvpdfd_pdda NOT SH_N 

//* Define device -- xdev pa29_g5a_nbl_cfp_mac
PDD_WOSHN = PDD NOT SH_N 

//* Define device -- xdev pa12_g5a_nbl_slit_v2_mac
pa12_g5a_nbl_slit_v2_mac_rega = pa12_g5a_nbl_mac_reg AND SLITDMY 
pa12_g5a_nbl_slit_v2_mac_reg = pa12_g5a_nbl_slit_v2_mac_rega NOT PDD_WOSHN 

//* Define device -- xdev pa20_g5a_nbl_slit_cfp_mac
pgate_hvpmos_ga_5_wiNOPW = COPY pgate_hvpmos_ga_3 
pgate_hv_pa20_g5a = pgate_hvpmos_ga_5_wiNOPW AND HV20DMY 
pa20_g5a_nbl_mac_reg = pgate_hv_pa20_g5a AND NBL 
pa20_g5a_nbl_cfp_mac_reg1 = pa20_g5a_nbl_mac_reg INTERACT CFP 
pa20_g5a_nbl_slit_cfp_mac_rega = pa20_g5a_nbl_cfp_mac_reg1 AND SLITDMY 
pa20_g5a_nbl_slit_cfp_mac_reg = pa20_g5a_nbl_slit_cfp_mac_rega NOT PDD_WOSHN 

//* Define device -- xdev pa16_g5a_nbl_slit_cfp_mac
pgate_hv_pa16_g5a = pgate_hvpmos_ga_5_wiNOPW AND HV16DMY 
pa16_g5a_nbl_mac_reg = pgate_hv_pa16_g5a AND NBL 
pa16_g5a_nbl_cfp_mac_reg1 = pa16_g5a_nbl_mac_reg INTERACT CFP 
pa16_g5a_nbl_slit_cfp_mac_rega = pa16_g5a_nbl_cfp_mac_reg1 AND SLITDMY 
pa16_g5a_nbl_slit_cfp_mac_reg = pa16_g5a_nbl_slit_cfp_mac_rega NOT PDD_WOSHN 

//* Define device -- xdev pa9_g5a_nbl_mac
pgate_hv_pa9_g5a = pgate_hvpmos_ga_3 AND HV9DMY 
pa9_g5a_nbl_mac_rega = pgate_hv_pa9_g5a AND NBL 
pa9_g5a_nbl_mac_reg = pa9_g5a_nbl_mac_rega NOT SLITDMY 

//* Define device -- xdev pa9_g5a_nbl_slit_mac
pa9_g5a_nbl_slit_mac_regb = pa9_g5a_nbl_mac_rega AND SLITDMY 
pa9_g5a_nbl_slit_mac_reg = pa9_g5a_nbl_slit_mac_regb NOT PDD_WOSHN 

//* Define device -- xdev pa20_g5a_nbl_cfp_mac
pa20_g5a_nbl_cfp_mac_reg = pa20_g5a_nbl_cfp_mac_reg1 NOT SLITDMY 

//* Define device -- xdev pa16_g5a_nbl_cfp_mac
pa16_g5a_nbl_cfp_mac_reg = pa16_g5a_nbl_cfp_mac_reg1 NOT SLITDMY 
pgate_hv_pa29_g5a = pgate_hvpmos_ga_5_wiNOPW AND HV29DMY 
pa29_g5a_nbl_mac_reg = pgate_hv_pa29_g5a AND NBL 
poly_cfp = poly INTERACT CFP 
pa29_g5a_nbl_cfp_mac_rega = pa29_g5a_nbl_mac_reg INTERACT poly_cfp 
pa29_g5a_nbl_cfp_mac_reg = pa29_g5a_nbl_cfp_mac_rega NOT PDD_WOSHN 

//* Define device -- xdev na29_g5a_cfp_mac
ngate_hvnmos_ga29_3 = ngate_hvnmos_ga2 INTERACT NDD1 
ngate_hvnmos_ga29 = ngate_hvnmos_ga29_3 AND MACRODMY 
ngate_hvnmos_na_ga29_1 = ngate_hvnmos_ga29 INTERACT SH_P 
ngate_hvnmos_na29_ga_4_wovtdn_wirpo = ngate_hvnmos_na_ga29_1 INTERACT RPO 
na_g5a_cfp_mac_reg1 = ngate_hvnmos_na29_ga_4_wovtdn_wirpo INTERACT NOPW 
na_g5a_cfp_mac_reg2 = na_g5a_cfp_mac_reg1 INTERACT CFP 
na_g5a_cfp_mac_reg3 = na_g5a_cfp_mac_reg2 NOT NBL  // INTERACT EOD
na_g5a_cfp_mac_reg = na_g5a_cfp_mac_reg3 NOT NDD1 
HV29DMY_EOD = HV29DMY INTERACT EOD 
na29_g5a_cfp_mac_reg = na_g5a_cfp_mac_reg AND HV29DMY_EOD 
ngate_hvnmos_na29_ga_2 = COPY ngate_hvnmos_na_ga29_1 
hvnmos_na29_ga_polya = ngate_hvnmos_na29_ga_2 NOT HVNW 
hvnmos_na29_ga_poly = hvnmos_na29_ga_polya AND SH_P 

//* Define device -- xdev na29_g5a_nbl_cfp_mac
na_g5a_nbl_cfp_mac_reg1 = na_g5a_cfp_mac_reg2 AND NBL_SLOT 
na_g5a_nbl_cfp_mac_reg2 = na_g5a_nbl_cfp_mac_reg1 INTERACT sh_n_hvnw 
na_g5a_nbl_cfp_mac_reg = na_g5a_nbl_cfp_mac_reg2 NOT INTERACT VTDN 
na29_g5a_nbl_cfp_mac_reg = na_g5a_nbl_cfp_mac_reg AND HV29DMY_EOD 

//***** Define connectivity/via layer -- hvpsf_shp ****
hvpsf_shp = COPY SH_P  // INTERACT na29_g5a_nbl_cfp_mac_reg

//* Define device -- xdev na20_g5a_nbl_cfp_mac
NDD_no_poly = NDD1 NOT POLY1i 
ngate_hvnmos_na_ga_1 = ngate_hvnmos_ga INTERACT SH_P 
ngate_hvnmos_na_ga_2 = ngate_hvnmos_na_ga_1 INTERACT sh_n_hvnw 
hvnmos_na_ga_poly = ngate_hvnmos_na_ga_2 AND SH_P 

//* Define device -- xdev nda29_g3a_nbl_cfp_mac
nda_g3a_nbl_cfp_mac_reg = na_g5a_nbl_cfp_mac_reg2 INTERACT VTDN 
nda29_g3a_nbl_cfp_mac_reg = nda_g3a_nbl_cfp_mac_reg AND HV29DMY_EOD 

//* Define device -- xdev na6_g5a_nbl_v2_mac
ngate_hvnmos_na_ga_3 = ngate_hvnmos_na_ga_2 NOT DPW 
ngate_hvnmos_na_ga_3_wivtdn = ngate_hvnmos_na_ga_3 INTERACT VTDN 
ngate_hvnmos_na_ga_3_wovtdn = ngate_hvnmos_na_ga_3 NOT ngate_hvnmos_na_ga_3_wivtdn 
ngate_hvnmos_na_ga_4_wovtdn_wirpo = ngate_hvnmos_na_ga_3_wovtdn INTERACT RPO 
na6_g5a_mac = ngate_hvnmos_na_ga_4_wovtdn_wirpo AND HV6DMY 
na6_g5a_nbl_mac_reg = na6_g5a_mac AND NBL 
na6_g5a_nbl_v2_mac_reg = na6_g5a_nbl_mac_reg INTERACT NOPW 

//* Define device -- xdev nld45_g5b_nbl_cfp_mac
ngate_hvnmos_gb2 = ngate_hvnmos AND HVGB 
hvnw_shn = HVNW INTERACT SH_N 
ngate_hvnmos_gb3 = ngate_hvnmos_gb2 INTERACT hvnw_shn 
ngate_hvnmos_gb4 = ngate_hvnmos_gb3 AND MACRODMY 
ngate_hvnmos_gb5 = COPY ngate_hvnmos_gb4 
ngate_hvnmos_gb_cfp1 = ngate_hvnmos_gb5 INTERACT RPO 
ngate_hvnmos_gb_cfp2 = ngate_hvnmos_gb_cfp1 AND HV40DMY 
ngate_hvnmos_gb_cfp3 = COPY ngate_hvnmos_gb_cfp2 
ngate_hvnmos_gb_cfp4 = ngate_hvnmos_gb_cfp3 INTERACT HVPBi 
ngate_hvnmos_gb_cfp5 = ngate_hvnmos_gb_cfp4 INTERACT NOPW 
ngate_hvnmos_gb_cfp6 = ngate_hvnmos_gb_cfp5 INTERACT SLITDMY 
nld_g5b_nbl_cfp_mac_reg1 = ngate_hvnmos_gb_cfp6 INTERACT CFP 
nld_g5b_nbl_cfp_mac_reg2 = nld_g5b_nbl_cfp_mac_reg1 AND HVPBi 
nld_g5b_nbl_cfp_mac_reg3 = nld_g5b_nbl_cfp_mac_reg2 AND NBL_SLOT 
nld45_g5b_nbl_cfp_mac_reg = nld_g5b_nbl_cfp_mac_reg3 AND HV45DMY 

//***** Define connectivity/via layer -- hvndfd_shn ****
hvndf4 = HVNWi INTERACT hvndf1 
ngthv3 = gate_hv AND NIMP 
ngthv5 = ngthv3 AND HVGB 
hvndfd = hvndf4 INTERACT ngthv5 
hvndfd_shn1 = hvndfd INTERACT SH_N 
hvndfd_shn = hvndfd_shn1 NOT HVPBi 

//***** Define connectivity/via layer -- HVPW ****
HVPW = HVPWa NOT RWDMYa 

//* Define device -- xdev nld36_g5b_nbl_cfp_mac
hvndfd_shn_area = hvndfd_shn1 NOT HVPBa 

//* Define device -- xdev pa45_g5b_nbl_cfp_mac
pgate_hvpmos_gb2 = pgate_hvpmos AND HVGB 
pa_g5b_nbl_cfp_mac_reg1 = pgate_hvpmos_gb2 INTERACT HVPWi 
pa_g5b_nbl_cfp_mac_reg2 = pa_g5b_nbl_cfp_mac_reg1 INTERACT SH_N 
pa_g5b_nbl_cfp_mac_reg3 = pa_g5b_nbl_cfp_mac_reg2 AND HV40DMY 
pa_g5b_nbl_cfp_mac_reg4 = pa_g5b_nbl_cfp_mac_reg3 AND NBL 
pa_g5b_nbl_cfp_mac_reg5 = pa_g5b_nbl_cfp_mac_reg4 AND MACRODMY 
pa_g5b_nbl_cfp_mac_reg6 = pa_g5b_nbl_cfp_mac_reg5 INTERACT NOPW 
pa_g5b_nbl_cfp_mac_reg7 = pa_g5b_nbl_cfp_mac_reg6 NOT INTERACT CFP 
pa45_g5b_nbl_cfp_mac_reg = pa_g5b_nbl_cfp_mac_reg7 AND HV45DMY 
na20_g5a_nbl_cfp_mac_reg1 = na_g5a_cfp_mac_reg2 AND NBL 
na20_g5a_nbl_cfp_mac_reg2 = na20_g5a_nbl_cfp_mac_reg1 INTERACT sh_n_hvnw 
na20_g5a_nbl_cfp_mac_reg3 = na20_g5a_nbl_cfp_mac_reg2 NOT INTERACT VTDN 
na20_g5a_nbl_cfp_mac_reg = na20_g5a_nbl_cfp_mac_reg3 AND HV20DMY_EOD 
na20_g5a_cfp_mac_reg = na_g5a_cfp_mac_reg AND HV20DMY_EOD 

//* Define device -- xdev pa36_g5b_nbl_cfp_mac
pa36_g5b_nbl_cfp_mac_reg = pa_g5b_nbl_cfp_mac_reg7 AND HV36DMY 
nld36_g5b_nbl_cfp_mac_reg = nld_g5b_nbl_cfp_mac_reg3 AND HV36DMY 
nda_g3b_nbl_cfp_mac_reg1 = ngate_hvnmos_gb_cfp3 INTERACT HVPWi 
nda_g3b_nbl_cfp_mac_reg2 = nda_g3b_nbl_cfp_mac_reg1 INTERACT NOPW 
nda_g3b_nbl_cfp_mac_reg3 = nda_g3b_nbl_cfp_mac_reg2 INTERACT SLITDMY 
nda_g3b_nbl_cfp_mac_reg4 = nda_g3b_nbl_cfp_mac_reg3 INTERACT CFP 
nda_g3b_nbl_cfp_mac_reg5 = nda_g3b_nbl_cfp_mac_reg4 AND NBL_SLOT 
nda_g3b_nbl_cfp_mac_reg6 = nda_g3b_nbl_cfp_mac_reg5 INTERACT VTDN 
nda_g3b_nbl_cfp_mac_reg7 = nda_g3b_nbl_cfp_mac_reg6 NOT HVNWi 
nda45_g3b_nbl_cfp_mac_reg = nda_g3b_nbl_cfp_mac_reg7 AND HV45DMY 
nda45_g3b_nbl_cfp_mac_aux = nda45_g3b_nbl_cfp_mac_reg AND HVPWi 

//* Define device -- xdev npddshnnbl10_ga_poly_4t
hnpnrg1 = HVDMY AND BJTDMY_all 
HVGAB = HVGA OR HVGB 
hnpnrg3 = hnpnrg1 AND HVGAB 
hnpnrg_4t_1 = hnpnrg3 AND BJTDMY_4t 
hnpnrg_4t = hnpnrg_4t_1 INTERACT NOPW 
hnndiff_4t = tndiff_all AND hnpnrg_4t 
shphvpw1 = SH_P OR PDD 
shp_hole = HOLES SH_P INNER
shphvpw2 = shp_hole OR PDD 
shphvpw = shphvpw1 OR shphvpw2 
hvpwbase = shphvpw AND hnpnrg_4t 
shpemit_1 = hnndiff_4t AND hvpwbase  //  define hv bjt npn(n+/sh_p/nbl) emiter
shpemit_3 = shpemit_1 NOT RPO 
shpemit_poly = shpemit_3 INTERACT POLY1i 
shpemit10_1_tmp1_poly = AREA shpemit_poly  > 99.999  < 100.001 
shpemit10_1_tmp2_poly = shpemit10_1_tmp1_poly AND HVGA 
pwemit10_ga_polya = shpemit10_1_tmp2_poly AND HVGA 
SHPW = SH_P OR shp_hole 
pwemit10_ga_polyb = pwemit10_ga_polya AND SHPW 
pwshnemit10_ga_poly = pwemit10_ga_polyb AND shn_hole 
pwshnnbl_emit10_ga_poly = pwshnemit10_ga_poly AND NBL 
npddshnnbl_emit10_ga_poly = pwshnnbl_emit10_ga_poly AND PDD 

//***** Define connectivity/via layer -- hncol_shp ****
shpemit_hvpw1 = NOPW INTERACT shpemit_1 
shpemit_hvpw2 = HVPW INTERACT shpemit_1 
shpemit_hvpw = shpemit_hvpw1 OR shpemit_hvpw2 
hvnw_shpemit_hvpw = COPY shpemit_hvpw 
hncolr_shp0 = hvnw_shpemit_hvpw AND hnpnrg_4t 
hncolr_shp1 = hncolr_shp0 INTERACT hvpwbase 
hncolr_shp2 = hncolr_shp1 OR SH_N 
hncols_shp3 = hncolr_shp2 INTERACT SH_P 
hncol_shp = hncols_shp3 NOT shpemit_1 

//***** Define connectivity/via layer -- hvpwbase_ga ****
hvpwbase_ga1 = hvpwbase INTERACT HVGA 
pnddshp5_nbl_ga_hnndiff_4t = mdiff AND hnpnrg_4t 
pnddshp5_nbl_ga_shpemit_1 = pnddshp5_nbl_ga_hnndiff_4t AND hvpwbase 
pnddshp5_nbl_ga_shpemit_2 = pnddshp5_nbl_ga_shpemit_1 NOT INTERACT RPO 
pnddshp5_nbl_ga_shpemit_poly = pnddshp5_nbl_ga_shpemit_2 INTERACT POLY1i 
pnddshp5_nbl_ga_4t_reg1 = AREA pnddshp5_nbl_ga_shpemit_poly  > 24.999  < 25.001 
pnddshp5_nbl_ga_4t_reg2 = pnddshp5_nbl_ga_4t_reg1 AND HVGA 
pnddshp5_nbl_ga_4t_reg3 = pnddshp5_nbl_ga_4t_reg2 AND NOPW 
pnddshp5_nbl_ga_4t_reg4 = pnddshp5_nbl_ga_4t_reg3 AND shn_hole 
pnddshp5_nbl_ga_4t_reg = pnddshp5_nbl_ga_4t_reg4 AND NBL 
hvpwbase_ga = hvpwbase_ga1 NOT INTERACT pnddshp5_nbl_ga_4t_reg 

//* Define device -- xdev npddshnnbl5_ga_poly_4t
shpemit5_1_tmp1_poly = AREA shpemit_poly  > 24.999  < 25.001 
shpemit5_1_tmp2_poly = shpemit5_1_tmp1_poly AND HVGA 
pwemit5_ga_polya = shpemit5_1_tmp2_poly AND HVGA 
pwemit5_ga_polyb = pwemit5_ga_polya AND SHPW 
pwshnemit5_ga_poly = pwemit5_ga_polyb AND shn_hole 
pwshnnbl_emit5_ga_poly = pwshnemit5_ga_poly AND NBL 
npddshnnbl_emit5_ga_poly = pwshnnbl_emit5_ga_poly AND PDD 

//* Define device -- xdev npddshnnbl2_ga_poly_4t
shpemit2_1_tmp1_poly = AREA shpemit_poly  > 3.999  < 4.001  // 40V N+/SH_P/NBL+HVNW/psub BJT_4t
shpemit2_1_tmp2_poly = shpemit2_1_tmp1_poly AND HVGA 
pwemit2_ga_polya = shpemit2_1_tmp2_poly AND HVGA 
pwemit2_ga_polyb = pwemit2_ga_polya AND SHPW 
pwshnemit2_ga_poly = pwemit2_ga_polyb AND shn_hole 
pwshnnbl_emit2_ga_poly = pwshnemit2_ga_poly AND NBL 
npddshnnbl_emit2_ga_poly = pwshnnbl_emit2_ga_poly AND PDD 

//* Define device -- xdev npwshnnbl10_ga_poly_4t
npwshnnbl_emit10_ga_polya = pwshnemit10_ga_poly NOT PDD 
npwshnnbl_emit10_ga_poly = npwshnnbl_emit10_ga_polya AND NBL 

//* Define device -- xdev npwshnnbl5_ga_poly_4t
npwshnnbl_emit5_ga_polya = pwshnemit5_ga_poly NOT PDD 
npwshnnbl_emit5_ga_poly = npwshnnbl_emit5_ga_polya AND NBL 

//* Define device -- xdev npwshnnbl2_ga_poly_4t
npwshnnbl_emit2_ga_polya = pwshnemit2_ga_poly NOT PDD 
npwshnnbl_emit2_ga_poly = npwshnnbl_emit2_ga_polya AND NBL 

//* Define device -- xdev phvnwpsub10_gb_poly
hpwemita = COPY tpdiff_1 
hpnprg_gen2 = HVDMY AND BJTDMY_all 
hnwbase = HVNW AND hpnprg_gen2 
hpwemit = hpwemita AND hnwbase 
pbhnpsub_emit10_tmp_1 = AREA hpwemit  > 99.999  < 100.001 
phnpsub_emit10_tmp = pbhnpsub_emit10_tmp_1 NOT INTERACT HVPBi 
phnpsub_emit10_tmp_gb = phnpsub_emit10_tmp AND HVGB 
phnpsub_emit10_gb_1 = phnpsub_emit10_tmp_gb NOT INTERACT shp_hole 
phnpsub_emit10_gb_2 = phnpsub_emit10_gb_1 NOT NBL 
phnpsub_emit10_gb_3 = phnpsub_emit10_gb_2 NOT BJTMEDMY 
phnpsub_emit10_gb_4 = phnpsub_emit10_gb_3 INTERACT POLY1i 
phnpsub_emit10_gb_poly = phnpsub_emit10_gb_4 NOT LVSDMY 

//***** Define connectivity/via layer -- phvnwcol ****
phvnwbase = HVNW AND hpnprg_gen2 
phvnwemita = tpdiff_1 AND phvnwbase 
phvnwemit = phvnwemita NOT INTERACT RPO 
phvnwcol1 = hnwbase INTERACT phvnwemit 
phvnwcol2 = HVPW INTERACT phvnwcol1 
phvnwcol3 = phvnwcol2 OR phvnwbase 
phvnwcol = phvnwcol3 NOT phvnwemit 

//* Define device -- xdev phvnwpsub5_gb_poly
pbhnpsub_emit5_tmp_1 = AREA hpwemit  > 24.999  < 25.001 
phnpsub_emit5_tmp = pbhnpsub_emit5_tmp_1 NOT INTERACT HVPBi 
phnpsub_emit5_tmp_gb = phnpsub_emit5_tmp AND HVGB 
phnpsub_emit5_gb_1 = phnpsub_emit5_tmp_gb NOT INTERACT shp_hole 
phnpsub_emit5_gb_2 = phnpsub_emit5_gb_1 NOT NBL 
phnpsub_emit5_gb_3 = phnpsub_emit5_gb_2 NOT BJTMEDMY 
phnpsub_emit5_gb_4 = phnpsub_emit5_gb_3 INTERACT POLY1i 
phnpsub_emit5_gb_poly = phnpsub_emit5_gb_4 NOT LVSDMY 

//* Define device -- xdev phvnwpsub2_gb_poly
pbhnpsub_emit2_tmp_1 = AREA hpwemit  > 3.999  < 4.001 
phnpsub_emit2_tmp = pbhnpsub_emit2_tmp_1 NOT INTERACT HVPBi 
phnpsub_emit2_tmp_gb = phnpsub_emit2_tmp AND HVGB 
phnpsub_emit2_gb_1 = phnpsub_emit2_tmp_gb NOT INTERACT shp_hole 
phnpsub_emit2_gb_2 = phnpsub_emit2_gb_1 NOT NBL 
phnpsub_emit2_gb_3 = phnpsub_emit2_gb_2 NOT BJTMEDMY 
phnpsub_emit2_gb_4 = phnpsub_emit2_gb_3 INTERACT POLY1i 
phnpsub_emit2_gb_poly = phnpsub_emit2_gb_4 NOT LVSDMY 

//* Define device -- xdev pnddpsub10_ga_poly
nddbase = NDD1 AND hpnprg_gen2 
nddemita = tpdiff_1 AND nddbase 
nddemit = nddemita NOT INTERACT RPO 
pnddpsub_emit10_tmp_1 = AREA nddemit  > 99.999  < 100.001 
pnddpsub_emit10_tmp_2 = pnddpsub_emit10_tmp_1 NOT INTERACT HVPBi 
pnddpsub_emit10_tmp_3 = pnddpsub_emit10_tmp_2 INTERACT POLY1i 
pnddpsub_emit10_tmp_4 = pnddpsub_emit10_tmp_3 AND HVGA 
pnddpsub_emit10_ga_poly = pnddpsub_emit10_tmp_4 NOT LVSDMY 

//***** Define connectivity/via layer -- nddcol ****
nddcol1 = nddbase INTERACT nddemit 
nddcol2 = HVPW INTERACT nddcol1 
nddcol3 = nddcol2 OR nddbase 
nddcol = nddcol3 NOT nddemit 

//* Define device -- xdev pnddpsub5_ga_poly
pnddpsub_emit5_tmp_1 = AREA nddemit  > 24.999  < 25.001 
pnddpsub_emit5_tmp_2 = pnddpsub_emit5_tmp_1 NOT INTERACT HVPBi 
pnddpsub_emit5_tmp_3 = pnddpsub_emit5_tmp_2 INTERACT POLY1i 
pnddpsub_emit5_tmp_4 = pnddpsub_emit5_tmp_3 AND HVGA 
pnddpsub_emit5_ga_poly = pnddpsub_emit5_tmp_4 NOT LVSDMY 

//* Define device -- xdev pnddpsub2_ga_poly
pnddpsub_emit2_tmp_1 = AREA nddemit  > 3.999  < 4.001 
pnddpsub_emit2_tmp_2 = pnddpsub_emit2_tmp_1 NOT INTERACT HVPBi 
pnddpsub_emit2_tmp_3 = pnddpsub_emit2_tmp_2 INTERACT POLY1i 
pnddpsub_emit2_tmp_4 = pnddpsub_emit2_tmp_3 AND HVGA 
pnddpsub_emit2_ga_poly = pnddpsub_emit2_tmp_4 NOT LVSDMY 

//* Define device -- xdev npwshnnbl10_ga_bgr8_7t
npwshnnbl10_ga_bgr8_7t_reg1 = BJTMDDMY AND BJTDMY_7t 
npwshnnbl10_ga_bgr8_7t_reg2 = npwshnnbl10_ga_bgr8_7t_reg1 NOT INTERACT PDD 
hnpnrg_7t = hnpnrg3 AND BJTDMY_7t 
hnndiff_7t = tndiff_1 AND hnpnrg_7t 
hvpwbase_7t = shphvpw AND hnpnrg_7t 
shpemit_7t_1 = hnndiff_7t AND hvpwbase_7t 
shpemit_7t_2 = shpemit_7t_1 NOT INTERACT RPO 
shpemit_7t_3 = shpemit_7t_2 AND BJTMDDMY 
shpemit_7t_4 = shpemit_7t_3 AND NOPW 
shpemit_7t_5 = shpemit_7t_4 AND NBL 
shpemit_7t_6 = shpemit_7t_5 NOT HVNW 
shpemit_7t_7 = shpemit_7t_6 AND shn_hole 
shpemit_7t = AREA shpemit_7t_7  > 99.999  < 100.001 
shpemit_7t_e8 = shpemit_7t NOT BJTSNDMY 
npwshnnbl10_ga_bgr8_7t_reg = npwshnnbl10_ga_bgr8_7t_reg2 INTERACT shpemit_7t_e8 

//***** Define connectivity/via layer -- hncol_shp_7t_c1 ****
shpemit_nopw_7t = NOPW INTERACT shpemit_7t 
shnw_shpemit_nopw_7t = SH_N OR shpemit_nopw_7t 
hncolr_shp0_7t = shnw_shpemit_nopw_7t AND hnpnrg_7t 
hncolr_shp1_7t = hncolr_shp0_7t INTERACT hvpwbase_7t 
hncols_shp2_7t = hncolr_shp1_7t INTERACT SH_P 
hncol_shp_7t = hncols_shp2_7t NOT shpemit_7t 
hncol_shp_7t_c1 = hncol_shp_7t AND BJTSNDMY 

//***** Define connectivity/via layer -- hncol_shp_7t_c8 ****
hncol_shp_7t_c8 = hncol_shp_7t NOT INTERACT BJTSNDMY 

//***** Define connectivity/via layer -- hvpwbase_7t_ga_b1 ****
hvpwbase_7t_ga_1 = hvpwbase_7t INTERACT HVGA 
hvpwbase_7t_ga = hvpwbase_7t_ga_1 INTERACT shpemit_7t 
hvpwbase_7t_ga_b1 = hvpwbase_7t_ga AND BJTSNDMY 

//***** Define connectivity/via layer -- hvpwbase_7t_ga_b8 ****
hvpwbase_7t_ga_b8 = hvpwbase_7t_ga NOT BJTSNDMY 

//* Define device -- xdev npddshnnbl10_ga_bgr8_7t
shpemit_7t_e1 = shpemit_7t AND BJTSNDMY 
npddshnnbl10_ga_bgr8_7t_reg3 = npwshnnbl10_ga_bgr8_7t_reg1 INTERACT PDD 
npddshnnbl10_ga_bgr8_7t_reg = npddshnnbl10_ga_bgr8_7t_reg3 INTERACT shpemit_7t_e8 

//* Define device -- xdev sbd_dio_ga_12_v2_3t
sbd_hole1 = HOLES PIMP INNER
sbd_hole2 = HOLES RPO 
sbd_hv_dio_gen2_1 = sbd_hole1 AND sbd_hole2 
sbd_hv_dio_gen2_3 = sbd_hv_dio_gen2_1 AND SBDDMY_3T 
sbd_hv_dio_gen2_4 = sbd_hv_dio_gen2_3 AND HVDMY 
sbd_hv_dio_gen2_5 = sbd_hv_dio_gen2_4 AND HVGA 
sbd_hv_dio_gen2_6 = COPY sbd_hv_dio_gen2_5 
sbd_hv_dio_gen2_8 = sbd_hv_dio_gen2_6 AND NOPW 
sbd_hv_dio_gen2_9 = sbd_hv_dio_gen2_8 AND OD 
sbd_hv_dio_gen2_dioa = sbd_hv_dio_gen2_9 AND shn_hole 
sbd_hole3 = HOLES SH_P INNER
sbd_hole3_pdd = sbd_hole3 INTERACT PDDi 
sbd_hv_dio_gen2_dio = sbd_hv_dio_gen2_dioa INTERACT sbd_hole3_pdd 
sbd_hv_dio_12_r_1 = COPY sbd_hv_dio_gen2_dio 
sbd_hv_dio_12_r_2 = sbd_hv_dio_12_r_1 NOT INTERACT SH_P 
dti_hole = HOLES DTI 
sbd_hv_dio_12_r_dti = sbd_hv_dio_12_r_2 INTERACT dti_hole 
sbd_hv_dio_12_ra = sbd_hv_dio_12_r_2 NOT sbd_hv_dio_12_r_dti 
HV12DMYa = HV12DMY INTERACT CFP 
HV12DMYe = HV12DMYa INTERACT NBL 
sbd_hv_dio_12_r = sbd_hv_dio_12_ra INTERACT HV12DMYe 

//* Define device -- xdev sbd_dio_ga_16_v2_3t
sbd_hv_dio_16_r_1 = sbd_hv_dio_gen2_dio NOT INTERACT SH_P 
sbd_hv_dio_16_r_2 = COPY sbd_hv_dio_16_r_1 
sbd_hv_dio_16_r_dti = sbd_hv_dio_16_r_2 INTERACT dti_hole 
sbd_hv_dio_16_ra = sbd_hv_dio_16_r_2 NOT sbd_hv_dio_16_r_dti 
HV16DMYa = HV16DMY INTERACT CFP 
HV16DMYb = HV16DMYa INTERACT NBL 
sbd_hv_dio_16_r = sbd_hv_dio_16_ra INTERACT HV16DMYb 

//* Define device -- xdev sbd_dio_ga_24_v2_3t
sbd_hv_dio_24_r_1_1 = COPY sbd_hv_dio_gen2_dio 
sbd_hv_dio_24_r_1 = sbd_hv_dio_24_r_1_1 AND NBL 
sbd_hv_dio_24_r_2 = sbd_hv_dio_24_r_1 NOT INTERACT SH_P 
sbd_hv_dio_24_r_dti = sbd_hv_dio_24_r_2 INTERACT dti_hole 
sbd_hv_dio_24_ra = sbd_hv_dio_24_r_2 NOT sbd_hv_dio_24_r_dti 
HV24DMYd = HV24DMY INTERACT CFP 
HV24DMYe = HV24DMYd INTERACT EOD 
sbd_hv_dio_24_r = sbd_hv_dio_24_ra INTERACT HV24DMYe 

//* Define device -- xdev zd_dio_ga_nbl_v2_4t
zd_hv_gagb_dio1 = POLY1 AND DIO4TDMY 
zd_hv_gagb_dio2 = zd_hv_gagb_dio1 AND HVDMY 
zd_hv_gagb_dio3 = zd_hv_gagb_dio2 AND SH_P 
zd_hv_gagb_dio4 = HOLES zd_hv_gagb_dio3 
zd_hv_gagb_dio5 = zd_hv_gagb_dio4 AND tndiff_1 
zd_hv_gagb_dio6 = zd_hv_gagb_dio5 AND HVPBi 
zd_hv_ga_dio8 = zd_hv_gagb_dio6 AND HVGA 
zd_hv_ga_dio9 = COPY zd_hv_ga_dio8 
zd_hv_ga_dio10 = zd_hv_ga_dio9 AND NOPW 
zd_dio_ga_nbl_4t_reg_1 = zd_hv_ga_dio10 AND NBL_SH_N 
zd_dio_ga_nbl_4t_reg_dti = zd_dio_ga_nbl_4t_reg_1 INTERACT dti_hole 
zd_dio_ga_nbl_4t_reg = zd_dio_ga_nbl_4t_reg_1 NOT zd_dio_ga_nbl_4t_reg_dti 

//* Define device -- diode npdd_dio_v2_ga
npdddio1 = tndiff_1 AND PDD 
npdddio2 = npdddio1 AND DIODMY 
npdddio3 = npdddio2 AND HVDMY 
npdddio4 = npdddio3 AND NOPW 
npdddio_ga = npdddio4 AND HVGA 

//* Define device -- diode nhvpw_dio_v2_gb
nhvpw_dio_gb1 = tndiff_1 AND HVPW 
nhvpw_dio_gb2 = nhvpw_dio_gb1 AND DIODMY 
nhvpw_dio_gb3 = nhvpw_dio_gb2 AND HVDMY 
nhvpw_dio_gb4 = nhvpw_dio_gb3 NOT NBL 
nhvpw_dio_gb5 = nhvpw_dio_gb4 AND HVPWi 
nhvpw_dio_gb6 = nhvpw_dio_gb5 AND NOPW 
nhvpw_dio_gb_reg = nhvpw_dio_gb6 AND HVGB 

//* Define device -- diode shnpsubshp_dio_ga
shnpsubshp_dio_ga_reg1 = SH_N AND DIODMY 
shnpsubshp_dio_ga_reg2 = shnpsubshp_dio_ga_reg1 AND HVDMY 
shnpsubshp_dio_ga_reg3 = shnpsubshp_dio_ga_reg2 AND HVGA 
shnpsubshp_dio_ga_reg4 = shnpsubshp_dio_ga_reg3 INTERACT NOPW 
shnpsubshp_dio_ga_reg = shnpsubshp_dio_ga_reg4 NOT NBL 

//* Define device -- diode shnnblpsubshp_dio_ga
shnnblpsubshp_dio_ga_reg1 = NBL AND DIODMY 
shnnblpsubshp_dio_ga_reg2 = shnnblpsubshp_dio_ga_reg1 AND HVDMY 
shnnblpsubshp_dio_ga_reg3 = shnnblpsubshp_dio_ga_reg2 AND HVGA 
shnnblpsubshp_dio_ga_reg4 = shnnblpsubshp_dio_ga_reg3 INTERACT NOPW 
shnnblpsubshp_dio_ga_reg = shnnblpsubshp_dio_ga_reg4 INTERACT SH_N 

//* Define device -- diode shnnblpsubshp_dio_gb
shnnblpsubshp_dio_gb_reg1 = shnnblpsubshp_dio_ga_reg2 AND HVGB 
shnnblpsubshp_dio_gb_reg2 = shnnblpsubshp_dio_gb_reg1 INTERACT NOPW 
shnnblpsubshp_dio_gb_reg = shnnblpsubshp_dio_gb_reg2 INTERACT SH_N 

//* Define device -- xdev pddshnnbl_dio_shp_ga_3t
pddshndio1 = PDD NOT INTERACT RPO 
pddshndio2 = pddshndio1 AND shn_hole 
pddshndio3 = pddshndio2 AND DIO3TDMY 
pddshndio4 = pddshndio3 AND HVGA 
pddshndio5 = pddshndio4 AND HVDMY 
pddshnnbl_dio_3t_reg1 = pddshndio5 AND NBL 
pddshnnbl_dio_3t_reg2 = pddshnnbl_dio_3t_reg1 NOT INTERACT SDI 
pddshnnbl_dio_3t_reg = pddshnnbl_dio_3t_reg2 AND NOPW 

//* Define device -- xdev shpnblshn_dio_shp_gb_3t
shpnbldio2 = SH_P AND shn_hole 
shpnbldio3 = shpnbldio2 AND DIO3TDMY 
shpnbldio4 = shpnbldio3 AND HVDMY 
shpnbldio5 = shpnbldio4 AND HVGB 
shpnbldio6 = shpnbldio5 AND NOPW 
shpnblshn_dio_3t_reg = shpnbldio6 AND NBL 

//* Define device -- xdev pbshnnbl_dio_shp_ga_3t
pbshnnbldio2 = HVPBi AND shn_hole 
pbshnnbldio3 = pbshnnbldio2 AND DIO3TDMY 
pbshnnbldio4 = pbshnnbldio3 AND HVDMY 
pbshnnbldio5 = pbshnnbldio4 NOT SDI 
pbshnnbldio6 = pbshnnbldio5 AND HVGA 
pbshnnbldio7 = pbshnnbldio6 AND NOPW 
pbshnnbl_dio_shp_ga_3t_reg = pbshnnbldio7 AND NBL 

//* Define device -- xdev pdio_esd_ga_6_v3_3t
HV6DMYa = HV6DMY INTERACT EMRDMY 
esd_ga_6_3t = esd_ga_shn AND HV6DMYa 

//* Define device -- xdev pdio_esd_ga_9_v3_3t
esd_ga_hvpb_1 = esd_ga AND HVPBi 
esd_ga_hvpb_shn = esd_ga_hvpb_1 AND SH_N 
esd_ga_hvpb_shn_nbl = esd_ga_hvpb_shn AND NBL 
esd_ga_9_3t = esd_ga_hvpb_shn_nbl AND HV9DMY 

//* Define device -- xdev pdio_esd_ga_12_v4_3t
esd_ga_12_v4_3t = esd_ga_12_v4_3t2 AND HVESD2DMY 
esd_ga_12_v4_3t_reg = SDI INTERACT esd_ga_12_v4_3t 

//***** Define connectivity/via layer -- stack_esd_minus ****
stack_esd_minus = NBL AND HVESD2DMY 

//* Define device -- xdev pdio_esd_ga_12_pdd_3t
esd_ga_12_pdd_3t1 = esd_ga_shn_hole NOT INTERACT HVESD1DMY 
HV12DMYb = HV12DMYa INTERACT PDDi 
HV12DMYc = HV12DMYb INTERACT SH_P 
HV12DMYd = HV12DMYc INTERACT RPO 
esd_ga_12_pdd_3t = esd_ga_12_pdd_3t1 AND HV12DMYd 

//* Define device -- xdev pdio_esd_ga_24_v3_3t
esd_3tdio_OD1 = OD AND DIO3TDMY 
esd_3tdio_OD = esd_3tdio_OD1 AND NBL 
esd_3tdio_OD_edge1 = esd_3tdio_OD NOT INSIDE EDGE PIMP
esd_3tdio_OD_edge2 = esd_3tdio_OD NOT TOUCH EDGE esd_3tdio_OD_edge1
esd_3tdio_OD_expand = EXPAND EDGE esd_3tdio_OD_edge2 OUTSIDE BY 0.18
esd_3tdio_rpo_auxi1 = esd_3tdio_OD_expand OR tpdiff_all 
esd_3tdio_rpo_auxi = esd_3tdio_rpo_auxi1 AND esd_ga_6 

//* Define device -- xdev pdio_esd_ga_16_v3_3t
HV16DMYb1 = HV16DMYa INTERACT PDDi 
HV16DMYc = HV16DMYb1 INTERACT SH_P 
HV16DMYd = HV16DMYc INTERACT RPO 
esd_ga_16_v3_3t = esd_ga_12_pdd_3t1 AND HV16DMYd 

//* Define device -- xdev pdio_esd_ga_20_pdd_3t
esd_ga_20_pdd_3t1 = esd_ga_20_v2_3t1 NOT INTERACT HVESD1DMY 
esd_ga_20_pdd_3t2 = esd_ga_20_pdd_3t1 INTERACT RPO 
HV20DMYa = HV20DMY INTERACT SH_P 
HV20DMYb = HV20DMYa INTERACT PDDi 
HV20DMYc = HV20DMYb INTERACT CFP 
esd_ga_20_pdd_3t = esd_ga_20_pdd_3t2 AND HV20DMYc 

//* Define device -- xdev pdio_esd_ga_20_v3_3t
esd_ga_20_v2_3t = esd_ga_20_v2_3t2 AND HVESD2DMY 
esd_ga_20_v2_3t_rega = SDI INTERACT esd_ga_20_v2_3t 
HV20DMYd = HV20DMYb INTERACT RPO 
esd_ga_20_v2_3t_reg = esd_ga_20_v2_3t_rega INTERACT HV20DMYd 
pdio_esd_ga_20_v3_3t_auxa = esd_3tdio_rpo_auxi AND HVESD2DMY 
pdio_esd_ga_20_v3_3t_aux = pdio_esd_ga_20_v3_3t_auxa NOT SH_N 
HV24DMYa = HV24DMY INTERACT SH_P 
HV24DMYb = HV24DMYa INTERACT PDDi 
HV24DMYc = HV24DMYb INTERACT CFP 
esd_ga_24_v2_3t1 = esd_ga_shn_hole AND HV24DMYc 
esd_ga_24_v2_3t = esd_ga_24_v2_3t1 INTERACT RPO 

//* Define device -- xdev pdio_esd_ga_29_v3_3t
HV29DMYa = HV29DMY INTERACT SH_P 
HV29DMYb = HV29DMYa INTERACT PDDi 
esd_ga_29_v2_3t = esd_ga_shn_hole AND HV29DMYb 

//* Define device -- xdev pdio_esd_gb_45_cit_v3_3t
esd_gb_8_1 = HVDMY AND HVGB 
esd_gb_8_2 = esd_gb_8_1 AND SDI 
esd_gb_8_3 = esd_gb_8_2 AND DIO3TDMY 
esd_gb_8 = esd_gb_8_3 AND HVPBi2 
esd_gb_9 = esd_gb_8 AND tpdiff_all 
NBL_HVNW_SHN = NBL INTERACT hvnw_shn 
esd_gb_10 = esd_gb_9 AND NBL_HVNW_SHN 
esd_gb_45_3ta = esd_gb_10 AND HV40DMY 
esd_gb_45_3tb = esd_gb_45_3ta AND HV45DMY 
esd_gb_45_3tc = esd_gb_45_3tb AND NBL_SLOT 
esd_gb_45_3t = esd_gb_45_3tc AND NOPW 
esd_gb_45_cit_3t = esd_gb_45_3t AND SDI_V2 

//* Define device -- xdev shpshnnbl_esd_dio_shp_ga_3t
esd_ga_7 = esd_ga_6 INTERACT PDD 
shpshnnbl_esd1 = esd_ga_7 AND tpdiff_1 
shpshnnbl_esd2 = shpshnnbl_esd1 AND SH_P 
shpshnnbl_esd2a = shpshnnbl_esd2 NOT INTERACT HV12DMY 
shpshnnbl_esd2b = shpshnnbl_esd2a NOT INTERACT HV16DMY 
shpshnnbl_esd3 = shpshnnbl_esd2b NOT INTERACT HV20DMY 
shpshnnbl_esd4 = shpshnnbl_esd3 NOT INTERACT HV24DMY 
shpshnnbl_esd5 = shpshnnbl_esd4 NOT INTERACT HV29DMY 
shpshnnbl_esd = shpshnnbl_esd5 NOT INTERACT HV45DMY 

//* Define device -- xdev pbhvnwshnnbl_esd_dio_shp_gb_3t
esd_gb_1 = esd_ga_1 AND HVDMY 
esd_gb_2 = esd_gb_1 AND HVGB 
esd_gb_3 = esd_gb_2 AND SDI 
esd_gb_4 = esd_gb_3 NOT EMRDMY 
esd_gb_5 = esd_gb_4 AND tpdiff_1 
esd_gb_6 = esd_gb_5 AND NOPW 
esd_gb_7 = esd_gb_6 AND HVPBi 
pbhvnwshnnbl_esd1 = esd_gb_7 INTERACT NBLSLOTi 
pbhvnwshnnbl_esd2 = pbhvnwshnnbl_esd1 INTERACT HVNWi 
pbhvnwshnnbl_esd = pbhvnwshnnbl_esd2 NOT INTERACT HV45DMY 

//* Define device -- xdev pdio_esd_gb_36_3t
esd_gb_3t_1 = esd_gb_10 AND NBL_SLOT 
esd_gb_3t_2 = esd_gb_3t_1 AND NOPW 
esd_gb_36_3t = esd_gb_3t_2 AND HV36DMY 

//* Define device -- xdev rppolyhri3d3k
hrpop2 = rpop NOT NIMP 
hrpop3 = hrpop2 NOT PIMP  //  HRI high resistance poly resistor
hrpop4 = hrpop3 AND RLPPDMY 
hrpo_3d3ka = hrpop4 INTERACT HRI3D3KDMY 
poly_pimp = poly INTERACT PIMP 
hrpo_3d3k = hrpo_3d3ka INTERACT poly_pimp 
hrpo3d3k_2t_1 = hrpo_3d3k AND RPDMY 
hrpo3d3k_2t = hrpo3d3k_2t_1 NOT INTERACT SERPDMY 

//* Define device -- xdev rppolyhri3d3k_dis
hrpo3d3k_3t_1 = hrpo_3d3k AND RPDMY1 
hrpo3d3k_3t = hrpo3d3k_3t_1 NOT INTERACT SERPDMY 

//* Define device -- xdev rppolyhri1k
hrpo_1ka = hrpop4 AND HRI 
hrpo_1k = hrpo_1ka INTERACT poly_pimp 
hrpo1k_2t = hrpo_1k AND RPDMY 

//* Define device -- xdev rppolyhri1k_dis
hrpo1k_3t = hrpo_1k AND RPDMY1 

//* Define device -- xdev rppo1rpo_serp_dis
SERPDMY_rsep = SERPDMY INTERACT RSEPDUMMY 
rpporpo_3t_serp = rpporpo_3t4 INTERACT SERPDMY_rsep 
RSEPDUMMMY_poly = RSEPDUMMY AND POLY1i 
rpporpo_3t_serp_aux = rpporpo_3t_serp NOT RSEPDUMMMY_poly 

//* Define device -- xdev rppolyhri3d3k_serp_dis
hrpo3d3k_3t_serp = hrpo3d3k_3t_1 INTERACT SERPDMY_rsep 
hrpo3d3k_3t_serp_aux = hrpo3d3k_3t_serp NOT RSEPDUMMMY_poly 

//* Define device -- xdev rppo1rpo_serp
rpporpo_2t_serp = rpporpoa INTERACT SERPDMY_rsep 
rpporpo_2t_serp_aux = rpporpo_2t_serp NOT RSEPDUMMMY_poly 

//* Define device -- xdev rppolyhri3d3k_serp
hrpo3d3k_2t_serp = hrpo3d3k_2t_1 INTERACT SERPDMY_rsep 
hrpo3d3k_2t_serp_aux = hrpo3d3k_2t_serp NOT RSEPDUMMMY_poly 

//* Define device -- xdev nwdio_5_iso
nwdio_iso_1 = nxwell NOT DIONW 
nwdio_iso_2 = nwdio_iso_1 NOT BJTDMY_all 
nwdio_iso_3 = nwdio_iso_2 NOT RWDMY1 
nwdio_iso_4 = nwdio_iso_3 OUTSIDE nwdio 
nwdio_iso_5 = nwdio_iso_4 OUTSIDE nwdio_od2 
nwdio_iso_6 = nwdio_iso_5 TOUCH psub 
nwdio_iso_7 = nwdio_iso_6 NOT DPW 
nwdio_5_iso_reg = nwdio_iso_7 AND OD2  //  5V NW/PW diode
hv_iso_region_1 = HVDMY OR LVPWRDMY 
p_hvdmy_1 = SH_Pi OR HVPW 
hvdmy_hole = HOLES HVDMY 
p_hvdmy_2 = p_hvdmy_1 AND hvdmy_hole 
hvnw_nohvdmy = SH_N NOT HVDMY 
hvnw_hole = HOLES hvnw_nohvdmy 
p_hvdmy = p_hvdmy_2 AND hvnw_hole 
hv_iso_region_2 = hv_iso_region_1 NOT p_hvdmy 
hvnw_ring = hvnw_nohvdmy INTERACT hvnw_hole 
hvnw_hole_s1 = SIZE hvnw_ring BY 0.01 
hv_iso_region = hv_iso_region_2 NOT hvnw_hole_s1 
nwdio_5_iso_reg12_1 = nwdio_5_iso_reg NOT INTERACT hv_iso_region 
NBL_hvnwi = NBL AND SH_N 
NBL_hvnwi_hole1 = HOLES NBL_hvnwi 
NBL_hvnwi_hole2 = NBL_hvnwi_hole1 NOT SH_N 
NBL_hvnwi_hole = NBL_hvnwi_hole2 INSIDE NBL 
lv_iso_region1 = NBL_hvnwi_hole NOT HVDMY 
lv_iso_region2 = lv_iso_region1 NOT p_hvdmy 
lv_iso_region = lv_iso_region2 NOT LVPWRDMY 
nwdio_5_iso_reg12_2 = nwdio_5_iso_reg12_1 INTERACT lv_iso_region 
nwdio_5_iso_reg12 = nwdio_5_iso_reg12_2 NOT PDDi 

//***** Define connectivity/via layer -- psub_under_ANWEL ****
psub_under_nxwell = psub OR nxwell 
hvnwdio_iso_1 = HVNWi NOT DIONW 
hvnwdio_iso_2 = hvnwdio_iso_1 AND DPW 
psub_under_ANWEL = psub_under_nxwell OR hvnwdio_iso_2 
nwdio_5_iso_reg3_1 = nwdio_5_iso_reg NOT INTERACT hv_iso_region 
nwdio_5_iso_reg3_2 = nwdio_5_iso_reg3_1 NOT INTERACT lv_iso_region 
nwdio_5_iso_reg3 = nwdio_5_iso_reg3_2 NOT PDDi 

//* Define device -- xdev nwpddshp_dio_5_iso
nwdio_5_iso_area = nwdio_iso_7 AND OD2  //  5V NW/PW diode
nwpddshp_dio_5_iso_reg = nwdio_5_iso_reg12_2 AND PDDi 
nwpddshp_dio_5_iso_reg3 = nwdio_5_iso_reg3_2 AND PDDi 

//* Define device -- xdev nwdpwshp_dio_iso
nwdio_iso_8 = nwdio_iso_6 AND DPW 
nwdpwdio_iso_reg = nwdio_iso_8 NOT OD2  //  1.8V NW/PW diode
nwdpwshpdio_iso_reg12_1 = nwdpwdio_iso_reg NOT INTERACT hv_iso_region 
nwdpwshpdio_iso_reg12 = nwdpwshpdio_iso_reg12_1 INTERACT lv_iso_region 

//* Define device -- xdev nwdpwshp_dio_5_iso
nwdpwdio_5_iso_reg = nwdio_iso_8 AND OD2  //  5V NW/PW diode
nwdpwshpdio_5_iso_reg12_1 = nwdpwdio_5_iso_reg NOT INTERACT hv_iso_region 
nwdpwshpdio_5_iso_reg12_2 = nwdpwshpdio_5_iso_reg12_1 INTERACT lv_iso_region 
nwdpwshpdio_5_iso_reg12 = nwdpwshpdio_5_iso_reg12_2 NOT PDDi 

//* Define device -- xdev nwdio_iso
nwdio_iso_reg = nwdio_iso_7 NOT OD2  //  1.8V NW/PW diode
nwdio_iso_reg12_1 = nwdio_iso_reg NOT INTERACT hv_iso_region 
nwdio_iso_reg12 = nwdio_iso_reg12_1 INTERACT lv_iso_region 
nwdio_iso_reg3_1 = nwdio_iso_reg NOT INTERACT hv_iso_region 
nwdio_iso_reg3 = nwdio_iso_reg3_1 NOT INTERACT lv_iso_region 

//* Define device -- xdev pwnblshn_dio_iso
pwnblhvnw_iso_reg = psub_in_nbl NOT OD2  //  1.8V NW/PW diode
pwnblhvnw_iso_reg12_1 = pwnblhvnw_iso_reg NOT INTERACT hv_iso_region 
pwnblhvnw_iso_reg12 = pwnblhvnw_iso_reg12_1 INTERACT lv_iso_region 

//* Define device -- xdev pwnddnblshn_dio_5_iso
pwnblhvnw_5_iso_reg12_1 = pwnblhvnw_5_iso_reg NOT INTERACT hv_iso_region 
pwnblhvnw_5_iso_reg12_2 = pwnblhvnw_5_iso_reg12_1 INTERACT lv_iso_region 
dpw_in_nbl = psub_in_nbl_1 AND SH_P 
hvpw_region_1 = HVDMY INTERACT shp_hole 
hvpw_region_2 = HOLES hvpw_region_1 
hvpw_region = hvpw_region_1 OR hvpw_region_2 
hvpwdpwnblhvnw_reg = dpw_in_nbl INTERACT hvpw_region 
hvpwdpwnblhvnw_iso_reg12_1 = hvpwdpwnblhvnw_reg NOT INTERACT hv_iso_region 
hvpwdpwnblhvnw_iso_reg12 = hvpwdpwnblhvnw_iso_reg12_1 INTERACT lv_iso_region 
pwnblhvnw_5_iso_reg12_3 = pwnblhvnw_5_iso_reg12_2 NOT INTERACT hvpwdpwnblhvnw_iso_reg12 
shpdpwnblhvnw_reg1 = COPY dpw_in_nbl 
shpdpwnblhvnw_reg = shpdpwnblhvnw_reg1 OR psub_in_nbl 
shpdpwnblhvnw_iso_reg12_1 = shpdpwnblhvnw_reg NOT INTERACT hv_iso_region 
shpdpwnblhvnw_iso_reg12 = shpdpwnblhvnw_iso_reg12_1 INTERACT lv_iso_region 
pwnblhvnw_5_iso_reg12_4 = pwnblhvnw_5_iso_reg12_3 INTERACT shpdpwnblhvnw_iso_reg12 
pwnddnblhvnw_5_iso_reg12 = pwnblhvnw_5_iso_reg12_4 AND NDD1 

//* Define device -- xdev pwndddpwnblshn_dio_5_iso
pwndddpwnblshn_5_iso_reg12a = OD2 AND NDD1 
pwndddpwnblshn_5_iso_reg12_1 = psub_in_nbl_3 INTERACT pwndddpwnblshn_5_iso_reg12a 
pwndddpwnblshn_5_iso_reg12_2 = pwndddpwnblshn_5_iso_reg12_1 INTERACT lv_iso_region 
pwndddpwnblshn_5_iso_reg12_3 = pwndddpwnblshn_5_iso_reg12_2 NOT INTERACT hv_iso_region 
pwndddpwnblshn_5_iso_reg12 = pwndddpwnblshn_5_iso_reg12_3 AND DPW 

//* Define device -- xdev nwpdddpwshp_dio_5_iso
nwpdddpwshp_dio_5_iso_reg = nwdpwshpdio_5_iso_reg12_2 AND PDDi 

//* Define device -- xdev pwnblshn_dio_5_iso
pwnblhvnw_5_iso_reg12 = pwnblhvnw_5_iso_reg12_4 NOT pwnddnblhvnw_5_iso_reg12 

//* Define device -- xdev shpdpwnblshn_dio_iso
shpdpwnblshn_dio_iso_reg_1 = NBL AND DPW 
shpdpwnblshn_dio_iso_reg_2 = shpdpwnblshn_dio_iso_reg_1 INTERACT lv_iso_region 
shpdpwnblshn_dio_iso_reg_3 = shpdpwnblshn_dio_iso_reg_2 NOT INTERACT hv_iso_region 
shpdpwnblshn_dio_iso_reg12 = shpdpwnblshn_dio_iso_reg_3 NOT pwndddpwnblshn_5_iso_reg12 

//* Define device -- xdev shnnblpsubshp_dio_9_iso
HVNWNBLPSUBSHP_9_ISO_1 = HVNWNBLPSUBSHP_ISO INTERACT HV9ISO 
HVNWNBLPSUBSHP_9_ISO_2 = HVNWNBLPSUBSHP_9_ISO_1 NOT INTERACT HV29ISO 
HVNWNBLPSUBSHP_9_ISO_3 = HVNWNBLPSUBSHP_9_ISO_2 NOT INTERACT HV45ISO 
HVNWNBLPSUBSHP_9_ISO = HVNWNBLPSUBSHP_9_ISO_3 NOT INTERACT HV70ISO 
HVNWNBLPSUBSHP_9_ISO_reg12_1 = HVNWNBLPSUBSHP_9_ISO NOT INTERACT hv_iso_region 
HVNWNBLPSUBSHP_9_ISO_reg12_2 = HVNWNBLPSUBSHP_9_ISO_reg12_1 INTERACT lv_iso_region 
HVNWNBLPSUBSHP_9_ISO_reg12 = HVNWNBLPSUBSHP_9_ISO_reg12_2 NOT INTERACT dti_hole 
HVNWNBLPSUBSHP_69_ISO = HVNWNBLPSUBSHP_ISO INTERACT DIO3TDMY 
HVNWNBLPSUBSHP_9_ISO_reg4_1 = HVNWNBLPSUBSHP_69_ISO INTERACT hv_iso_region 
HVNWNBLPSUBSHP_9_ISO_reg4_2 = HVNWNBLPSUBSHP_9_ISO_reg4_1 NOT INTERACT lv_iso_region 
HVNWNBLPSUBSHP_9_ISO_reg4_3 = HVNWNBLPSUBSHP_9_ISO_reg4_2 NOT INTERACT dti_hole 
HVNWNBLPSUBSHP_9_ISO_reg4_4 = HVNWNBLPSUBSHP_9_ISO_reg4_3 INTERACT HV6DMY 
HVNWNBLPSUBSHP_9_ISO_reg4_5 = HVNWNBLPSUBSHP_9_ISO_reg4_3 INTERACT HV9DMY 
HVNWNBLPSUBSHP_9_ISO_reg4 = HVNWNBLPSUBSHP_9_ISO_reg4_4 OR HVNWNBLPSUBSHP_9_ISO_reg4_5 

//* Define device -- xdev shnnblpsubshp_dio_29_iso
HVNWNBLPSUBSHP_29_ISO_1 = HVNWNBLPSUBSHP_ISO NOT INTERACT HV8ISO 
HVNWNBLPSUBSHP_29_ISO_2 = HVNWNBLPSUBSHP_29_ISO_1 INTERACT HV29ISO 
HVNWNBLPSUBSHP_29_ISO_3 = HVNWNBLPSUBSHP_29_ISO_2 NOT INTERACT HV45ISO 
HVNWNBLPSUBSHP_29_ISO = HVNWNBLPSUBSHP_29_ISO_3 NOT INTERACT HV70ISO 
HVNWNBLPSUBSHP_29_ISO_reg12_1 = HVNWNBLPSUBSHP_29_ISO NOT INTERACT hv_iso_region 
HVNWNBLPSUBSHP_29_ISO_reg12_2 = HVNWNBLPSUBSHP_29_ISO_reg12_1 INTERACT lv_iso_region 
HVNWNBLPSUBSHP_29_ISO_reg12 = HVNWNBLPSUBSHP_29_ISO_reg12_2 NOT INTERACT dti_hole 
SHNWNBLPSUBSHP_29_ISO_reg4_4 = HVNWNBLPSUBSHP_9_ISO_reg4_3 INTERACT PDD 
SHNWNBLPSUBSHP_29_ISO_reg4_3 = HVNWNBLPSUBSHP_9_ISO_reg4_3 INTERACT HV29DMY 
SHNWNBLPSUBSHP_29_ISO_reg4_1 = HVNWNBLPSUBSHP_9_ISO_reg4_3 INTERACT HV12DMY 
SHNWNBLPSUBSHP_29_ISO_reg4_2 = HVNWNBLPSUBSHP_9_ISO_reg4_3 INTERACT HV20DMY 
SHNWNBLPSUBSHP_29_ISO_reg4_5 = SHNWNBLPSUBSHP_29_ISO_reg4_1 OR SHNWNBLPSUBSHP_29_ISO_reg4_2 
SHNWNBLPSUBSHP_29_ISO_reg4_6 = SHNWNBLPSUBSHP_29_ISO_reg4_3 OR SHNWNBLPSUBSHP_29_ISO_reg4_5 
SHNWNBLPSUBSHP_29_ISO_reg4a = SHNWNBLPSUBSHP_29_ISO_reg4_4 OR SHNWNBLPSUBSHP_29_ISO_reg4_6 
SHNWNBLPSUBSHP_29_ISO_reg4b = SHNWNBLPSUBSHP_29_ISO_reg4a INTERACT SDI 
SHNWNBLPSUBSHP_29_ISO_reg4 = SHNWNBLPSUBSHP_29_ISO_reg4b NOT INTERACT HVESD1DMY  //  stack ESD device don't extract this diode

//* Define device -- xdev shnnblpsubshp_dio_45_iso
HVNWNBLPSUBSHP_ISO_45 = NBL INTERACT HVDMY 
HVNWNBLPSUBSHP_45_ISO_1 = HVNWNBLPSUBSHP_ISO_45 NOT INTERACT HV8ISO 
HVNWNBLPSUBSHP_45_ISO_2 = HVNWNBLPSUBSHP_45_ISO_1 NOT INTERACT HV29ISO 
HVNWNBLPSUBSHP_45_ISO_3 = HVNWNBLPSUBSHP_45_ISO_2 INTERACT HV45ISO 
HVNWNBLPSUBSHP_45_ISO = HVNWNBLPSUBSHP_45_ISO_3 NOT INTERACT HV70ISO 
HVNWNBLPSUBSHP_45_ISO_reg12_1 = HVNWNBLPSUBSHP_45_ISO NOT INTERACT hv_iso_region 
HVNWNBLPSUBSHP_45_ISO_reg12_2 = HVNWNBLPSUBSHP_45_ISO_reg12_1 INTERACT lv_iso_region 
HVNWNBLPSUBSHP_45_ISO_reg12 = HVNWNBLPSUBSHP_45_ISO_reg12_2 NOT INTERACT dti_hole 
SHNNBLPSUBSHP_gb_ISO_reg4_1 = NBL AND HVGB 
SHNNBLPSUBSHP_gb_ISO_reg4_2 = SHNNBLPSUBSHP_gb_ISO_reg4_1 INTERACT hv_iso_region 
DIO3TDMY_ESD = DIO3TDMY INTERACT SDI 
SHNWNBLPSUBSHP_45_ISO_reg1a = SHNNBLPSUBSHP_gb_ISO_reg4_2 INTERACT DIO3TDMY_ESD 
SHNWNBLPSUBSHP_45_ISO_reg1 = SHNWNBLPSUBSHP_45_ISO_reg1a NOT INTERACT HV36DMY 
NBLHVNW = NBL INTERACT HVNW 
SHNWNBLPSUBSHP_45_ISO_reg2 = HVNWNBLPSUBSHP_9_ISO_reg4_3 INTERACT NBLHVNW 
SHNWNBLPSUBSHP_45_ISO_reg4 = SHNWNBLPSUBSHP_45_ISO_reg1 OR SHNWNBLPSUBSHP_45_ISO_reg2 

//* Define device -- xdev ppnddshp_dio_iso_ac
ndd_not_in_hvnw = NDD1 NOT HVNWi 
nddpsubshp_dio_iso_reg_1 = ndd_not_in_hvnw AND HVDMY 
rndd1 = rwdmy_hv AND NDDi 
rndd_r1 = rndd1 AND RWDMY 
rndd_r2 = rndd_r1 AND NOPW 
rndd_r3 = rndd_r2 AND HVDMY 
rndd_r4 = rndd_r3 AND HVGA 
rndd_r = rndd_r4 NOT CK3DMY 
nddpsubshp_dio_iso_reg_2 = nddpsubshp_dio_iso_reg_1 NOT INTERACT rndd_r 
nddpsubshp_dio_iso_reg = nddpsubshp_dio_iso_reg_2 INTERACT SBDDMY_3T 

//* Define device -- xdev ppshnnblpsubshp_dio_iso
HVNWNBLPSUBSHP_ISO_reg4_1a = NBL AND HVGA 
HVNWNBLPSUBSHP_ISO_reg4_1 = HVNWNBLPSUBSHP_ISO_reg4_1a INTERACT hv_iso_region 
SHNNBLPSUBSHP_ISO_reg4_1 = HVNWNBLPSUBSHP_ISO_reg4_1 NOT INTERACT lv_iso_region 
SHNNBLPSUBSHP_ISO_reg4_2 = SHNNBLPSUBSHP_ISO_reg4_1 NOT INTERACT SLITDMY 
SHNNBLPSUBSHP_ISO_reg4_3_1 = SHNNBLPSUBSHP_ISO_reg4_2 INTERACT HV6DMY 
SHNNBLPSUBSHP_ISO_reg4_3_2 = SHNNBLPSUBSHP_ISO_reg4_2 INTERACT HV5DMY 
SHNNBLPSUBSHP_ISO_reg4_3 = SHNNBLPSUBSHP_ISO_reg4_3_1 OR SHNNBLPSUBSHP_ISO_reg4_3_2 
SHNNBLPSUBSHP_ISO_reg4 = SHNNBLPSUBSHP_ISO_reg4_3 NOT INTERACT DIO3TDMY 

//* Define device -- xdev ppshnnblpsubshp_dio_iso_ac
SHNNBLPSUBSHP_ISO_ac_reg4_1 = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT SLITDMY 
SHNNBLPSUBSHP_ISO_ac_reg4a = SHNNBLPSUBSHP_ISO_ac_reg4_1 INTERACT HV6DMY 
HV9DMY_NOPDD = HV9DMY NOT INTERACT PDD 
SHNNBLPSUBSHP_ISO_ac_reg4b = SHNNBLPSUBSHP_ISO_ac_reg4_1 INTERACT HV9DMY_NOPDD 
SHNNBLPSUBSHP_ISO_ac_reg4_a = SHNNBLPSUBSHP_ISO_ac_reg4a OR SHNNBLPSUBSHP_ISO_ac_reg4b 
SHNNBLPSUBSHP_ISO_ac_reg4g = SHNNBLPSUBSHP_ISO_ac_reg4_1 INTERACT HV5DMY 
SHNNBLPSUBSHP_ISO_ac_reg4 = SHNNBLPSUBSHP_ISO_ac_reg4_a OR SHNNBLPSUBSHP_ISO_ac_reg4g 

//* Define device -- xdev ppshnnblpsubshp_dio_mv_iso
SHNNBLPSUBSHP_mv_ISO_reg4_1 = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT HV12DMY 
SHNNBLPSUBSHP_mv_ISO_reg4_2 = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT HV20DMY 
SHNNBLPSUBSHP_mv_ISO_reg4_3a = SHNNBLPSUBSHP_mv_ISO_reg4_1 OR SHNNBLPSUBSHP_mv_ISO_reg4_2 
SHNNBLPSUBSHP_mv_ISO_reg4_2a = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT HV16DMY 
SHNNBLPSUBSHP_mv_ISO_reg4_3b = SHNNBLPSUBSHP_mv_ISO_reg4_3a OR SHNNBLPSUBSHP_mv_ISO_reg4_2a 
SHNNBLPSUBSHP_mv_ISO_reg4_3 = SHNNBLPSUBSHP_mv_ISO_reg4_3b NOT INTERACT SBDDMY_3T 
SHNNBLPSUBSHP_mv_ISO_reg4_2b = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT HV9DMY 
SHNNBLPSUBSHP_mv_ISO_reg4_3c = SHNNBLPSUBSHP_mv_ISO_reg4_3 OR SHNNBLPSUBSHP_mv_ISO_reg4_2b 
SHNNBLPSUBSHP_mv_ISO_reg4_4 = SHNNBLPSUBSHP_mv_ISO_reg4_3c NOT INTERACT HVPBi2 
SHNNBLPSUBSHP_mv_ISO_reg4 = SHNNBLPSUBSHP_mv_ISO_reg4_4 NOT INTERACT DIO3TDMY 

//* Define device -- xdev ppshnnblpsubshp_dio_mv_iso_ac
SHNNBLPSUBSHP_mv_ISO_ac_reg4 = SHNNBLPSUBSHP_mv_ISO_reg4_3 INTERACT HVPBi2 

//* Define device -- xdev ppshnnblpsubshp_dio_hv_iso
SHNNBLPSUBSHP_hv_ISO_reg4_1 = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT HV29DMY 
SHNNBLPSUBSHP_hv_ISO_reg4 = SHNNBLPSUBSHP_hv_ISO_reg4_1 NOT INTERACT DIO3TDMY_ESD 

//* Define device -- xdev ppshnnblpsubshp_dio_hv_iso_ac
SHNNBLPSUBSHP_hv_ISO_ac_reg4_1 = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT HV24DMY 
DIO3TDMY_NO_ESD = DIO3TDMY NOT INTERACT SDI 
SHNNBLPSUBSHP_hv_ISO_ac_reg4_2 = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT DIO3TDMY_NO_ESD 
SHNNBLPSUBSHP_hv_ISO_ac_reg4_3 = SHNNBLPSUBSHP_hv_ISO_ac_reg4_1 OR SHNNBLPSUBSHP_hv_ISO_ac_reg4_2 
SHNNBLPSUBSHP_hv_ISO_ac_reg4_2a = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT SBDDMY_3T 
SHNNBLPSUBSHP_hv_ISO_ac_reg4_4a = SHNNBLPSUBSHP_hv_ISO_ac_reg4_3 OR SHNNBLPSUBSHP_hv_ISO_ac_reg4_2a 
SHNNBLPSUBSHP_hv_ISO_ac_reg4_2b = SHNNBLPSUBSHP_ISO_reg4_1 INTERACT DIO4TDMY 
SHNNBLPSUBSHP_hv_ISO_ac_reg4_4 = SHNNBLPSUBSHP_hv_ISO_ac_reg4_4a OR SHNNBLPSUBSHP_hv_ISO_ac_reg4_2b 
SHNNBLPSUBSHP_hv_ISO_ac_reg4 = SHNNBLPSUBSHP_hv_ISO_ac_reg4_4 NOT INTERACT DIO3TDMY_ESD 

//* Define device -- xdev ppshnnblpsubshp_dio_gb_iso
SHNNBLPSUBSHP_gb_ISO_reg4_3 = SHNNBLPSUBSHP_gb_ISO_reg4_2 INTERACT HV45DMY 
SHNNBLPSUBSHP_gb_ISO_reg4_4 = SHNNBLPSUBSHP_gb_ISO_reg4_3 NOT INTERACT DIO3TDMY_ESD 
SHNNBLPSUBSHP_gb_ISO_reg4 = SHNNBLPSUBSHP_gb_ISO_reg4_4 NOT INTERACT SLITDMY 

//* Define device -- xdev ppshnnblpsubshp_dio_gb_iso_ac
SHNNBLPSUBSHP_gb_ISO_ac_reg4_1 = SHNNBLPSUBSHP_gb_ISO_reg4_3 INTERACT SLITDMY 
SHNNBLPSUBSHP_gb_ISO_ac_reg4_2 = SHNNBLPSUBSHP_gb_ISO_reg4_2 INTERACT DIO3TDMY_NO_ESD 
SHNNBLPSUBSHP_gb_ISO_ac_reg4 = SHNNBLPSUBSHP_gb_ISO_ac_reg4_1 OR SHNNBLPSUBSHP_gb_ISO_ac_reg4_2 

//* Define device -- xdev ppshpnblshn_dio_iso
shpdpwnblhvnw_iso_reg4_1 = shpdpwnblhvnw_reg INTERACT hv_iso_region 
shpdpwnblhvnw_iso_reg4_2 = shpdpwnblhvnw_iso_reg4_1 NOT INTERACT lv_iso_region 
shpdpwnblshn_iso_reg4_1 = shpdpwnblhvnw_iso_reg4_2 INTERACT HV6DMY 
shpdpwnblshn_iso_reg4_2 = shpdpwnblshn_iso_reg4_1 NOT INTERACT SLITDMY 
shpdpwnblshn_iso_reg4 = shpdpwnblshn_iso_reg4_2 INTERACT NDD1 

//* Define device -- xdev ppshpnblshn_dio_iso_ac
shpdpwnblshn_iso_ac_reg4_1 = shpdpwnblhvnw_iso_reg4_2 INTERACT HV9DMY 
shpdpwnblshn_iso_ac_reg4_2a = shpdpwnblshn_iso_reg4_1 OR shpdpwnblshn_iso_ac_reg4_1 
shpdpwnblshn_iso_ac_reg4_2b = shpdpwnblhvnw_iso_reg4_2 INTERACT HV5DMY 
shpdpwnblshn_iso_ac_reg4_2 = shpdpwnblshn_iso_ac_reg4_2a OR shpdpwnblshn_iso_ac_reg4_2b 
shpdpwnblshn_iso_ac_reg4_3 = shpdpwnblshn_iso_ac_reg4_2 INTERACT SLITDMY 
shpdpwnblshn_iso_ac_reg4 = shpdpwnblshn_iso_ac_reg4_3 INTERACT NDD1 

//* Define device -- xdev ppshpnblshn_dio_mv_iso_ac
shpdpwnblshn_iso_mv_ac_reg4_1 = shpdpwnblhvnw_iso_reg4_2 INTERACT HV12DMY 
shpdpwnblshn_iso_mv_ac_reg4_2 = shpdpwnblhvnw_iso_reg4_2 INTERACT HV20DMY 
shpdpwnblshn_iso_mv_ac_reg4_3a = shpdpwnblshn_iso_mv_ac_reg4_1 OR shpdpwnblshn_iso_mv_ac_reg4_2 
shpdpwnblshn_iso_mv_ac_reg4_2a = shpdpwnblhvnw_iso_reg4_2 INTERACT HV16DMY 
shpdpwnblshn_iso_mv_ac_reg4_3 = shpdpwnblshn_iso_mv_ac_reg4_3a OR shpdpwnblshn_iso_mv_ac_reg4_2a 
shpdpwnblshn_iso_mv_ac_reg4_4a = shpdpwnblshn_iso_mv_ac_reg4_3 INTERACT NDD1 
shpdpwnblshn_iso_mv_ac_reg4_4 = shpdpwnblshn_iso_mv_ac_reg4_4a INTERACT SLITDMY 
shpdpwnblshn_iso_mv_ac_reg4 = shpdpwnblshn_iso_mv_ac_reg4_4 NOT INTERACT SBDDMY_3T 

//* Define device -- xdev ppshpnblshn_dio_hv_iso
shpdpwnblshn_iso_hv_reg4_1 = shpdpwnblhvnw_iso_reg4_2 INTERACT HV29DMY 
shpdpwnblshn_iso_hv_reg4 = shpdpwnblshn_iso_hv_reg4_1 INTERACT NDD1 

//* Define device -- xdev ppshpnblshn_dio_hv_iso_ac
shpdpwnblshn_iso_hv_ac_reg4_1 = shpdpwnblhvnw_iso_reg4_2 INTERACT HV24DMY 
shpdpwnblshn_iso_hv_ac_reg4_2 = shpdpwnblshn_iso_hv_ac_reg4_1 NOT INTERACT SBDDMY_3T 
shpdpwnblshn_iso_hv_ac_reg4a = shpdpwnblshn_iso_hv_ac_reg4_2 NOT INTERACT DIO3TDMY_ESD 
shpdpwnblshn_iso_hv_ac_reg4_3 = shpdpwnblhvnw_iso_reg4_2 INTERACT DIO4TDMY 
shpdpwnblshn_iso_hv_ac_reg4 = shpdpwnblshn_iso_hv_ac_reg4a OR shpdpwnblshn_iso_hv_ac_reg4_3 

//* Define device -- xdev ppshpnblshn_dio_mv_iso
shpdpwnblshn_iso_mv_reg4_1 = shpdpwnblhvnw_iso_reg4_2 NOT INTERACT SLITDMY 
shpdpwnblshn_iso_mv_reg4_2 = shpdpwnblshn_iso_mv_reg4_1 INTERACT NDD1 
shpdpwnblshn_iso_mv_reg4 = shpdpwnblshn_iso_mv_reg4_2 INTERACT HV20DMY 

//* Define device -- xdev ppshnnblpsubshp_dio_gb_mv_iso
SHNNBLPSUBSHP_gb_mv_ISO_reg4_1 = SHNNBLPSUBSHP_gb_ISO_reg4_2 INTERACT HV36DMY 
SHNNBLPSUBSHP_gb_mv_ISO_reg4 = SHNNBLPSUBSHP_gb_mv_ISO_reg4_1 NOT INTERACT SDI 

//* Define device -- xdev ppshnnblpsubshp_dio_36_iso
SHNWNBLPSUBSHP_36_ISO_reg4 = SHNNBLPSUBSHP_gb_mv_ISO_reg4_1 INTERACT SDI 

//* Define ERC or other layers
rhvpw2 = rhvpw1 AND NBL 
psub_float1 = psub NOT INTERACT rhvpw2  //  exclude HVPW resistor for floating psub check
psub_float2 = psub_float1 NOT INTERACT BJTDMY  //  exclude psub BJT for floating psub check
psub_in1 = psub AND HVNWa 
nbl_hv = NBLi AND HVDMY 
psub_in2 = psub AND nbl_hv 
psub_ina = psub_in1 OR psub_in2 
dpw_hv = DPW AND HVDMY 
psub_in3 = psub AND dpw_hv 
psub_in = psub_ina OR psub_in3 
psub_float = psub_float2 NOT psub_in 

//***** Define connectivity/via layer -- polyCont ****
pl2co = POLY2 AND CONT  //  define POLY2 contact
pl1co = CONT NOT pl2co  //  define OD/POLY1 contact
polyCont = pl1co AND POLY1 

//***** Define connectivity/via layer -- mim_hvpw_via ****
mim_hvpw_via = mim_term AND HVPW 

//***** Define connectivity/via layer -- tfr ****
tfr = M0 NOT MSi 

//***** Define connectivity/via layer -- psub_under_DPW_co_imp ****
DPW_co_imp = NDDi OR HVNWi 
psub_under_DPW_co_imp = psub OR DPW_co_imp 

//***** Define connectivity/via layer -- mom3p1 ****
mom3p11 = metal3 AND MOMDMY23 
mom3p1 = mom3p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- pw_iso ****
pw_iso1_1 = NBL AND HVNWi 
pw_iso1_2 = pw_iso1_1 NOT INTERACT BJTDMY_all 
pw_iso1 = pw_iso1_2 NOT INTERACT RWDMYa 
pw_iso2 = HOLES pw_iso1 
hvnw_pw_iso = HVNWi INSIDE pw_iso2 
pw_iso = pw_iso2 NOT INTERACT hvnw_pw_iso 

//***** Define connectivity/via layer -- VIA1 ****
cv1 = VIA1i AND CTM1  //  via for CTM1/M2
VIA1 = VIA1i NOT cv1  //  via for M2/M2

//***** Define connectivity/via layer -- psub_term_nw ****
psub_term_nw = psub_term OR nxwell 
rhvnw1 = HVNWa AND RWDMYX 
HVNW_float1 = HVNWi NOT INTERACT rhvnw1  //  exclude HVNW resistor for floating HVNW check
HVNW_float2 = HVNW_float1 NOT INTERACT BJTDMY  //  exclude HVNW BJT for floating HVNW check
pbhnpsub_emit2_tmp = pbhnpsub_emit2_tmp_1 INTERACT HVPBi 
pbhnpsub_emit2_tmp_gb = pbhnpsub_emit2_tmp AND HVGB 
pbhnpsub_emit2_gb_1 = pbhnpsub_emit2_tmp_gb AND shp_hole 
pbhnhvpw_emit2_gb_1 = pbhnpsub_emit2_gb_1 AND NBL 
dpw_hole = HOLES DPW INNER
pbhnhvpw_emit2_gb = pbhnhvpw_emit2_gb_1 AND dpw_hole 
HVNW_float3 = HVNW_float2 NOT INTERACT pbhnhvpw_emit2_gb  //  exclude lat bjt emit
pbhnpsub_emit5_tmp = pbhnpsub_emit5_tmp_1 INTERACT HVPBi 
pbhnpsub_emit5_tmp_gb = pbhnpsub_emit5_tmp AND HVGB 
pbhnpsub_emit5_gb_1 = pbhnpsub_emit5_tmp_gb AND shp_hole 
pbhnhvpw_emit5_gb_1 = pbhnpsub_emit5_gb_1 AND NBL 
pbhnhvpw_emit5_gb = pbhnhvpw_emit5_gb_1 AND dpw_hole 
HVNW_float4 = HVNW_float3 NOT INTERACT pbhnhvpw_emit5_gb  //  exclude lat bjt emit
HVNW_float = HVNW_float4 NOT HVNWa 

//***** Define connectivity/via layer -- nwemit ****
nwemita = tndiff_1 AND SH_N 
hnpnrg = hnpnrg3 AND BJTDMY_all 
hpbase1 = HVPW AND hnpnrg 
hppbase1 = hpbase1 INTERACT SH_P 
hppbase = hppbase1 NOT NOPW 
nwemitb = nwemita AND hppbase  //  define HV BJT NPN(NW/HVPW/NBL) emiter
nwemit = nwemitb AND HV40DMY  //  define HV 40V  BJT NPN(NW/HVPW/NBL) emiter

//***** Define connectivity/via layer -- hvpdfd ****
hvpdf6 = HVPW INTERACT hvpdf1 
hvpdfd = hvpdf6 INTERACT pgthv4 

//***** Define connectivity/via layer -- hnemit ****
hnndiff = tndiff_all AND hnpnrg 
hpbase = hpbase1 NOT INTERACT SH_P 
hnemita = hnndiff AND hpbase  //  define HV BJT NPN(N+/HVPW/NBL) emitter
hnemitb = hnemita NOT SH_N 
hnemit = hnemitb AND HV40DMY  //  40V N+/HVPW/NBL+HVNW BJY emitter

//***** Define connectivity/via layer -- hnwbase_lat ****
hpnprg1_gen2_4t = HVGA AND BJTDMY_4t 
hpnprg_gen2_4t = hpnprg1_gen2_4t AND HVDMY 
hnwbase_lat = HVNWi AND hpnprg_gen2_4t 
poly_nohvfpoa = poly NOT HVFPO 
poly_nohvfpo = poly_nohvfpoa NOT DIODMYa 

//***** Define connectivity/via layer -- hvpwbase_gb ****
hvpwbase_gb = hvpwbase INTERACT HVGB 

//***** Define connectivity/via layer -- odCont ****
odCont = pl1co NOT POLY1 

//***** Define connectivity/via layer -- hpwemit_lat ****
hpwemita_lat = tpdiff_1 AND HVNWi 
hpwemitb_lat = hpwemita_lat AND hnwbase_lat 
poly_in_bjtdmy = poly AND BJTDMY_4t 
poly_in_bjtdmy_hole = HOLES poly_in_bjtdmy 
hpwemit_lat = hpwemitb_lat AND poly_in_bjtdmy_hole 

//***** Define connectivity/via layer -- poly_hvnw ****
poly_hvnw = poly_term AND HVNW 

//***** Define connectivity/via layer -- nplug ****
nplug1a = tndiff_1 AND ANWEL  //   define N_well contact
nplug1b = tndiff_1 AND HVNW 
nplug1_1 = nplug1a OR nplug1b 
nplug1c = tndiff_1 AND SH_N 
nplug1_2 = nplug1_1 OR nplug1c 
nplug1d = tndiff_1 AND NDDa 
nplug1 = nplug1_2 OR nplug1d 
nplug3 = nplug1 INTERACT CONT 
tpdiffco = tpdiff_1 INTERACT CONT 
nplug2 = nplug1 INTERACT tpdiffco 
nplug4 = nplug3 OR nplug2 
pw_in_hvnw2 = HVPBi OR SH_P 
pw_in_hvnw = pw_in_hvnw2 OR PDD 
nplug = nplug4 NOT pw_in_hvnw 
erc_mos_gates = gate_all NOT VARDMY 
erc_pmos_gates1 = erc_mos_gates AND NWELL 
erc_pmos_gates2 = erc_mos_gates AND HVNWi 
erc_pmos_gates3 = erc_pmos_gates1 OR erc_pmos_gates2 
erc_pmos_gates4 = erc_pmos_gates3 AND PIMP 
tpgate_fgd1 = gate_lv_fgd AND nxwell 
tpgate_fgd = tpgate_fgd1 INTERACT PIMP 
bpgate_ngd1 = tpgate_fgd AND OD2 
bpgate_fgd = bpgate_ngd1 INTERACT NIMP 
erc_pmos_gates = erc_pmos_gates4 OR bpgate_fgd 

//***** Define connectivity/via layer -- pplug_ac ****
pplug1_1 = tpdiff_1 AND psub  //   define p_sub contact
pplug1_2 = pplug1_1 NOT SH_N 
pplug1 = pplug1_2 NOT NDDa 
pplug3 = pplug1 INTERACT CONT 
tndiffco = tndiff_1 INTERACT CONT 
pplug2 = pplug1 INTERACT tndiffco 
pplug = pplug3 OR pplug2  //   define p_sub contact
pplug_ac = pplug NOT ALL_FT_ac 

//***** Define connectivity/via layer -- mim_hvnw_via ****
mim_hvnw_via = mim_term AND HVNW 

//***** Define connectivity/via layer -- poly_hvpw ****
poly_hvpw = poly_term AND HVPW 

//***** Define connectivity/via layer -- ntap ****
xwell = NWELL OUTSIDE RWDMYa 
ntapx = tndiff_1 AND xwell 
ntap = ntapx NOT BJTDMY 

//***** Define connectivity/via layer -- tpdiff_woR ****
tpdiff_woRa = tpdiff_1 AND SBDDMY_3T 
tpdiff_woR = tpdiff_woRa NOT sbd_hv_dio_gen2_dio  //  avoid overlap
nw_hvnw = NWELL OR HVNWi 
c_pmall = nw_hvnw NOT NTN  //  pmos all for WPE (clear tone)
c_pmcore = c_pmall NOT OD2  //  pmos all for WPE (clear tone)	mask 192
nw_ntn = NWELL OR NTN 
#IFNDEF WPE_PURE5V
c_nmIO = OD2 NOT nw_ntn
#ELSE
c_nmIO = BULK NOT nw_ntn
#ENDIF

//***** Define connectivity/via layer -- hvpdfd_hvpb ****
hvpdfd_hvpb1 = HVPBi INTERACT hvpdf1 
hvpdfd_hvpb2 = hvpdfd_hvpb1 INTERACT pgthv4 
hvpdfd_hvpb = hvpdfd_hvpb2 AND HVNWa 
nxwell_float1 = nxwell NOT INTERACT VARDMY  //  exclude nwell under VAR for floating nwell check
nxwell_float2 = nxwell_float1 NOT INTERACT trwell  //  exclude nwell resistor for floating nwell check
nxwell_float3 = nxwell_float2 NOT INTERACT BJTDMY  //  exclude nwell under BJTDMY for floating nwell check
nxwell_float = nxwell_float3 NOT INTERACT HOTWL  //  exclude hot-NWEL 

//***** Define connectivity/via layer -- VIA2 ****
cv2 = VIA2i AND CTM2  //  via for CTM2/M3
VIA2 = VIA2i NOT cv2  //  via for M3/M3

//***** Define connectivity/via layer -- dpwc ****
dpwc = DPW AND HVPW 

//***** Define connectivity/via layer -- poly_psub ****
poly_psub = poly_term AND psub 

//***** Define connectivity/via layer -- hncol ****
hncolr1 = HVNW AND hnpnrg 
hncolr = hncolr1 NOT INTERACT SH_N 
hncols = hncolr TOUCH hpbase 
hncol1 = hncols OR hpbase 
hncol = hncol1 NOT hnemit 

//***** Define connectivity/via layer -- emit_poly ****
emit_poly = emit1_1 INTERACT POLY1i 

//***** Define connectivity/via layer -- shpcol_hvnw ****
shpcol_hvnw_1 = shp_hole OR SH_P 
shpcol_hvnw_2 = shpcol_hvnw_1 AND hnpnrg 
shpcol_hvnw_3 = shpcol_hvnw_2 AND HVNW 
shpcol_hvnw = shpcol_hvnw_3 NOT hpwemit 

//***** Define connectivity/via layer -- tiod ****
tiod1 = diff NOT POLY1 
tiod2 = tiod1 NOT RPO 
tiod3 = tiod2 NOT RPDMYa 
tiod4 = tiod3 NOT RWDMYa  //  RPO, RPDMY, RWDMY cut ti-od
tiod5 = tiod4 NOT tpdiff_1 
tiod6 = tiod5 NOT tndiff_1 
tiod7 = tiod6 NOT sbd_hv_dio_gen2_dio 
tiod = tiod7 NOT schottky_p 

//***** Define connectivity/via layer -- mom4p2 ****
mom4p21 = metal4 AND MOMDMY24 
mom4p2 = mom4p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- gate1_not_IO1 ****
gate1_not_IO1 = gate_lv NOT OD2 

//***** Define connectivity/via layer -- iso_hvnw ****
iso_hvnw = iso_hvnwa NOT RWDMY 
#IFNDEF WPE_PURE5V
c_pmIO = c_pmall AND OD2
#ELSE
c_pmIO = COPY c_pmall
#ENDIF

//***** Define connectivity/via layer -- mom4m2 ****
mom4m2 = mom4p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA3 ****
VIA3 = VIA3i NOT cv3  //  via for M4/M4

//***** Define connectivity/via layer -- shpemit ****
shpemit_2 = shpemit_1 INTERACT RPO 
shpemit = shpemit_2 NOT INTERACT POLY1i 

//***** Define connectivity/via layer -- mom3m2 ****
mom3p21 = metal3 AND MOMDMY24 
mom3m2 = mom3p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- pplug_inhvnw ****
pw_in_NOPW = pw_in_hvnw AND NOPW 
pw_in_hvnw4 = pw_in_NOPW OR NDD1 
pw_in_hvnw5 = pw_in_hvnw4 NOT SH_N 
pplug1_inhvnw = tpdiff_1 AND pw_in_hvnw5  //   define p_sub contact
pplug3_inhvnw = pplug1_inhvnw INTERACT CONT 
pplug2_inhvnw = pplug1_inhvnw INTERACT tndiffco 
pplug_inhvnw1 = pplug3_inhvnw OR pplug2_inhvnw  //   define p_sub contact
pplug_inhvnw = pplug_inhvnw1 NOT hpwemit  //  for hercules purpose

//***** Define connectivity/via layer -- mom4m1 ****
mom4p11 = metal4 AND MOMDMY23 
mom4m1 = mom4p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA4 ****
VIA4 = VIA4i NOT cv4  //  

//***** Define connectivity/via layer -- s_hvnw ****
s_hvnw = HVNWi NOT RWDMYa 

//***** Define connectivity/via layer -- poly_nw ****
poly_nw = poly_term AND nxwell 

//***** Define connectivity/via layer -- mom4p1 ****
mom4p1 = mom4p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- hvndfd_shn_ndd ****
hvndfd_shn_ndd = hvndfd_shn INTERACT NDD1 

//***** Define connectivity/via layer -- hpwcol_lat ****
hpwcol_lat = hpwemitb_lat NOT hpwemit_lat 

//***** Define connectivity/via layer -- mom3p2 ****
mom3p2 = mom3p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- c2poly ****
rp2 = rp1 NOT INTERACT POLY1 
p2rdum = rp2 INTERACT POLY2  //  poly2 resistor dummy
resp2 = POLY2 AND p2rdum  //  poly2 resistor layer
c2poly = POLY2 NOT resp2  //  poly2 interconnect

//***** Define connectivity/via layer -- n_pplug ****
n_pplug1 = mdiff INTERACT CONT 
n_pplug2 = n_pplug1 AND PIMP 
n_pplug3 = n_pplug2 NOT nxwell 
n_pplug4_1 = n_pplug3 NOT HVNW 
n_pplug4 = n_pplug4_1 NOT iso_hvnw 
n_pplug5 = n_pplug4 AND n_psub 
rwel = psub INSIDE NBL 
n_pplug6 = n_pplug5 NOT rwel 
n_pplug7 = n_pplug6 NOT NDD1 
n_pplug = n_pplug7 NOT SH_N 

//***** Define connectivity/via layer -- nplug_nbl ****
nplug_nbla = tndiff_1 AND NBL 
nplug_nblb = nplug_nbla AND iso_hvnw 
nplug_nblc = nplug_nbla AND HVNW 
nplug_nbl2 = nplug_nblb OR nplug_nblc 
c_nw_nbl = nplug_nbla AND nxwell 
nplug_nbl3 = nplug_nbl2 OR c_nw_nbl 
nplug_nbl4 = nplug_nbl3 NOT pw_in_hvnw 
DPW_wo_HVGB = DPW NOT HVGB 
nplug_nbl5 = nplug_nbl4 NOT DPW_wo_HVGB 
nplug_nbld = nplug_nbla AND SH_N 
DPW_wi_NDD = NDD1 AND hv_iso_region 
nplug_nble = nplug_nbld NOT DPW_wi_NDD 
nplug_nbl6 = nplug_nbl5 OR nplug_nble 
nplug_nbl7 = nplug_nbl6 INTERACT CONT 
nplug_nbl8 = nplug_nbl6 INTERACT tpdiffco 
nplug_nbl = nplug_nbl7 OR nplug_nbl8 

//***** Define connectivity/via layer -- tndiff_woR ****
tndiff_woR = tndiff_1 AND SBDDMY_3T 

//***** Define connectivity/via layer -- mom3m1 ****
mom3m1 = mom3p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- hpwcol ****
hnwbase_col = hnwbase INTERACT hpwemit 
hpwcols = HVPW TOUCH hnwbase_col 
hpwcol1 = hpwcols OR hnwbase 
hpwcol = hpwcol1 NOT hpwemit 

//***** Define connectivity/via layer -- ptap ****
ptap = tpdiff_1 AND psub 

//***** Define connectivity/via layer -- mim_psub_via ****
mim_psub_via = mim_term AND psub 
erc_nmos_gates1 = erc_mos_gates NOT NWELL 
erc_nmos_gates2 = erc_nmos_gates1 NOT HVNW 
erc_nmos_gates3 = erc_nmos_gates2 AND NIMP 
erc_nmos_gates = erc_nmos_gates3 OR bngate_fgd 
d_nmcore = OD2 OR nw_ntn  //  nmos core for WPE (Dark tone)
c_nmcore = BULK NOT d_nmcore  //  nmos core for WPE (clear tone)	mask 191

//***** Define connectivity/via layer -- mim_nw_via ****
mim_nw_via = mim_term AND nxwell 
//#############################################
//# CONNECTION                                #
//#############################################
#IFDEF top2_thick
CONNECT metal4 ctm BY ctm_via
#ELSE
#IFDEF top_metal_mim
CONNECT metal5 ctm BY ctm_via
#ELSE
CONNECT metal4 ctm BY ctm_via
#ENDIF
#ENDIF
CONNECT ctm mim_block
CONNECT emit emit_poly
CONNECT emit hpwcol_lat
CONNECT emit hpwemit_lat
CONNECT emit ntap
CONNECT emit nwemit
CONNECT emit pplug_inhvnw
CONNECT emit ptap
CONNECT emit shpemit
CONNECT emit tiod
CONNECT emit_poly hpwcol_lat
CONNECT emit_poly ntap
CONNECT emit_poly pplug_inhvnw
CONNECT emit_poly ptap
CONNECT emit_poly tiod
CONNECT hpwcol_lat ntap
CONNECT hpwcol_lat pplug_inhvnw
CONNECT hpwcol_lat ptap
CONNECT hpwcol_lat tiod
CONNECT hpwemit_lat emit_poly
CONNECT hpwemit_lat hpwcol_lat
CONNECT hpwemit_lat ntap
CONNECT hpwemit_lat pplug_inhvnw
CONNECT hpwemit_lat ptap
CONNECT hpwemit_lat shpemit
CONNECT hpwemit_lat tiod
CONNECT metal1 c2poly BY pl2co
CONNECT metal1 poly BY polyCont
CONNECT metal1 tndiff BY odCont
CONNECT metal1 tpdiff BY odCont
CONNECT metal2 metal1 BY VIA1
CONNECT metal2 tfr BY SICR_V1
CONNECT metal3 metal2 BY VIA2
CONNECT metal3 mom3m1
CONNECT metal3 mom3m2
CONNECT metal3 mom3p1
CONNECT metal3 mom3p2
CONNECT metal4 metal3 BY VIA3
CONNECT metal4 mom4m1
CONNECT metal4 mom4m2
CONNECT metal4 mom4p1
CONNECT metal4 mom4p2
CONNECT metal5 metal4 BY VIA4
CONNECT ntap pplug_inhvnw
CONNECT ntap ptap
CONNECT nwemit emit_poly
CONNECT nwemit hpwcol_lat
CONNECT nwemit hpwemit_lat
CONNECT nwemit ntap
CONNECT nwemit pplug_inhvnw
CONNECT nwemit ptap
CONNECT nwemit shpemit
CONNECT nwemit tiod
CONNECT poly gate1_not_IO1
CONNECT poly hvmos_poly_sti
CONNECT ptap pplug_inhvnw
CONNECT shpemit emit_poly
CONNECT shpemit hpwcol_lat
CONNECT shpemit ntap
CONNECT shpemit pplug_inhvnw
CONNECT shpemit ptap
CONNECT shpemit tiod
CONNECT tiod ntap
CONNECT tiod pplug_inhvnw
CONNECT tiod ptap
CONNECT tndiff emit
CONNECT tndiff emit_poly
CONNECT tndiff emit_rpo
CONNECT tndiff hpwcol_lat
CONNECT tndiff hpwemit_lat
CONNECT tndiff hvpdfs
CONNECT tndiff ioemit
CONNECT tndiff ioemit_poly
CONNECT tndiff nddemit
CONNECT tndiff ntap
CONNECT tndiff nwemit
CONNECT tndiff phvnwemit
CONNECT tndiff pplug_inhvnw
CONNECT tndiff ptap
CONNECT tndiff sbd_hv_dio_gen2_dio
CONNECT tndiff schottky_p
CONNECT tndiff shpemit
CONNECT tndiff stack_esd_plus
CONNECT tndiff tiod
CONNECT tndiff tpdiff
CONNECT tndiff tpdiff_s
CONNECT tndiff tpdiff_woR
CONNECT tndiff_woR hnemit
CONNECT tpdiff emit
CONNECT tpdiff emit_poly
CONNECT tpdiff hpwcol_lat
CONNECT tpdiff hpwemit_lat
CONNECT tpdiff ntap
CONNECT tpdiff nwemit
CONNECT tpdiff pplug_inhvnw
CONNECT tpdiff ptap
CONNECT tpdiff shpemit
CONNECT tpdiff tiod

#IFDEF RC_DECK
CONNECT  poly gate
CONNECT  nxwell mim_term BY mim_nw_via
CONNECT  nxwell poly_term BY poly_nw
CONNECT  psub mim_term BY mim_psub_via
CONNECT  psub poly_term BY poly_psub
CONNECT  HVPW mim_term BY mim_hvpw_via
CONNECT  HVPW poly_term BY poly_hvpw
CONNECT  HVPW DPW BY dpwc
CONNECT  tpdiff SH_P BY pplug_inhvnw
CONNECT  tpdiff hpwcol BY pplug
CONNECT  tpdiff psub_term BY pplug
CONNECT  tpdiff PDD BY pplug_inhvnw
CONNECT  tpdiff hvpdfd_pdd BY pplug_inhvnw
CONNECT  tpdiff hvpwbase_7t_ga_b8 BY pplug_inhvnw
CONNECT  tpdiff psub_term_nw BY pplug
CONNECT  tpdiff psub_under_ANWEL BY pplug
CONNECT  tpdiff hpbase BY pplug
CONNECT  tpdiff psub_term_ac BY pplug_ac
CONNECT  tpdiff hvpdfd_shp BY pplug_inhvnw
CONNECT  tpdiff iocoll BY pplug
CONNECT  tpdiff nddcol BY pplug
CONNECT  tpdiff hvpwbase_gb BY pplug
CONNECT  tpdiff psub_under_DPW_co_imp BY pplug
CONNECT  tpdiff HVPW BY pplug
CONNECT  tpdiff hvpdfd BY pplug
CONNECT  tpdiff hvpdfd_hvpb BY pplug_inhvnw
CONNECT  tpdiff hvpwbase_7t_ga_b1 BY pplug_inhvnw
CONNECT  tpdiff HVPBi BY pplug_inhvnw
CONNECT  tpdiff psub BY pplug
CONNECT  tpdiff shpcol_hvnw BY pplug_inhvnw
CONNECT  tpdiff pw_iso BY pplug
CONNECT  tpdiff phvnwcol BY pplug
CONNECT  tpdiff hvpwbase_ga BY pplug_inhvnw
CONNECT  tpdiff coll BY pplug
CONNECT  tpdiff hvpsf_shp BY pplug
CONNECT  tndiff stack_esd_minus BY nplug_nbl
CONNECT  tndiff hncol_shp BY nplug
CONNECT  tndiff hvndfd BY nplug
CONNECT  tndiff hnwbase BY nplug
CONNECT  tndiff s_hvnw BY nplug
CONNECT  tndiff ionbase BY nplug
CONNECT  tndiff hnwbase_lat BY nplug
CONNECT  tndiff NDD BY nplug
CONNECT  tndiff hvndfd_shn BY nplug
CONNECT  tndiff iso_hvnw BY nplug
CONNECT  tndiff nxwell BY nplug
CONNECT  tndiff hvndfd_shn_ndd BY nplug
CONNECT  tndiff hncol_shp_7t_c1 BY nplug
CONNECT  tndiff hvndfd_ndd BY nplug
CONNECT  tndiff nbase BY nplug
CONNECT  tndiff hncol BY nplug
CONNECT  tndiff nddbase BY nplug
CONNECT  tndiff NBL BY nplug_nbl
CONNECT  tndiff phvnwbase BY nplug
CONNECT  tndiff hncol_shp_7t_c8 BY nplug
CONNECT  tndiff SH_N BY nplug
CONNECT  tndiff HVNW BY nplug
CONNECT  HVNW mim_term BY mim_hvnw_via
CONNECT  HVNW poly_term BY poly_hvnw
#ELSE
SCONNECT nxwell mim_term BY mim_nw_via
SCONNECT nxwell poly_term BY poly_nw
SCONNECT psub mim_term BY mim_psub_via
SCONNECT psub poly_term BY poly_psub
SCONNECT HVPW mim_term BY mim_hvpw_via
SCONNECT HVPW poly_term BY poly_hvpw
SCONNECT HVPW DPW BY dpwc
SCONNECT tpdiff SH_P BY pplug_inhvnw
#IFNDEF NW_RING
  SCONNECT tpdiff n_psub BY n_pplug
#ENDIF
SCONNECT tpdiff hpwcol BY pplug
SCONNECT tpdiff psub_term BY pplug
SCONNECT tpdiff PDD BY pplug_inhvnw
SCONNECT tpdiff hvpdfd_pdd BY pplug_inhvnw
SCONNECT tpdiff hvpwbase_7t_ga_b8 BY pplug_inhvnw
SCONNECT tpdiff psub_term_nw BY pplug
SCONNECT tpdiff psub_under_ANWEL BY pplug
SCONNECT tpdiff hpbase BY pplug
SCONNECT tpdiff psub_term_ac BY pplug_ac
SCONNECT tpdiff hvpdfd_shp BY pplug_inhvnw
SCONNECT tpdiff iocoll BY pplug
SCONNECT tpdiff nddcol BY pplug
SCONNECT tpdiff hvpwbase_gb BY pplug
SCONNECT tpdiff psub_under_DPW_co_imp BY pplug
SCONNECT tpdiff HVPW BY pplug
SCONNECT tpdiff hvpdfd BY pplug
SCONNECT tpdiff hvpdfd_hvpb BY pplug_inhvnw
SCONNECT tpdiff hvpwbase_7t_ga_b1 BY pplug_inhvnw
SCONNECT tpdiff HVPBi BY pplug_inhvnw
SCONNECT tpdiff psub BY pplug
SCONNECT tpdiff shpcol_hvnw BY pplug_inhvnw
SCONNECT tpdiff pw_iso BY pplug
SCONNECT tpdiff phvnwcol BY pplug
SCONNECT tpdiff hvpwbase_ga BY pplug_inhvnw
SCONNECT tpdiff coll BY pplug
SCONNECT tpdiff hvpsf_shp BY pplug
SCONNECT tndiff stack_esd_minus BY nplug_nbl
SCONNECT tndiff hncol_shp BY nplug
SCONNECT tndiff hvndfd BY nplug
SCONNECT tndiff hnwbase BY nplug
SCONNECT tndiff s_hvnw BY nplug
SCONNECT tndiff ionbase BY nplug
SCONNECT tndiff hnwbase_lat BY nplug
SCONNECT tndiff NDD BY nplug
SCONNECT tndiff hvndfd_shn BY nplug
SCONNECT tndiff iso_hvnw BY nplug
SCONNECT tndiff nxwell BY nplug
SCONNECT tndiff hvndfd_shn_ndd BY nplug
SCONNECT tndiff hncol_shp_7t_c1 BY nplug
SCONNECT tndiff hvndfd_ndd BY nplug
SCONNECT tndiff nbase BY nplug
SCONNECT tndiff hncol BY nplug
SCONNECT tndiff nddbase BY nplug
SCONNECT tndiff NBL BY nplug_nbl
SCONNECT tndiff phvnwbase BY nplug
SCONNECT tndiff hncol_shp_7t_c8 BY nplug
SCONNECT tndiff SH_N BY nplug
SCONNECT tndiff HVNW BY nplug
SCONNECT HVNW mim_term BY mim_hvnw_via
SCONNECT HVNW poly_term BY poly_hvnw
#ENDIF
tndiff_cut = schottky_n OR (tndiff_woR OR (shpemit_7t_e8 OR (shpemit_7t_e1 OR (hvndfs OR (hnemit OR shpemit_poly)))))
tpdiff_cut = tpdiff_s OR (sbd_hv_dio_gen2_dio OR (schottky_p OR (tpdiff_woR OR (stack_esd_plus OR (phvnwemit OR (nddemit OR (ioemit_poly OR (ioemit OR (emit_rpo OR hvpdfs)))))))))
tndiff = tndiff_all NOT tndiff_cut 
tpdiff = tpdiff_all NOT tpdiff_cut


 /* SPECIAL CONNECTIONS FOR without R diffusion */ 
CONNECT tndiff hnemit
CONNECT metal1 hnemit BY odCont 
CONNECT hnemit emit 
CONNECT hnemit emit_poly 
CONNECT hnemit emit_rpo 
CONNECT hnemit hpwcol_lat 
CONNECT hnemit hpwemit_lat 
CONNECT hnemit hvpdfs 
CONNECT hnemit ioemit 
CONNECT hnemit ioemit_poly 
CONNECT hnemit nddemit 
CONNECT hnemit ntap 
CONNECT hnemit nwemit 
CONNECT hnemit phvnwemit 
CONNECT hnemit pplug_inhvnw 
CONNECT hnemit ptap 
CONNECT hnemit sbd_hv_dio_gen2_dio 
CONNECT hnemit schottky_p 
CONNECT hnemit shpemit 
CONNECT hnemit stack_esd_plus 
CONNECT hnemit tiod 
CONNECT hnemit tpdiff 
CONNECT hnemit tpdiff_s 
CONNECT hnemit tpdiff_woR 

CONNECT hnemit shpemit_poly
CONNECT hnemit hvndfs
CONNECT hnemit shpemit_7t_e1
CONNECT hnemit shpemit_7t_e8
CONNECT hnemit tndiff_woR
CONNECT hnemit schottky_n
CONNECT tndiff shpemit_poly
CONNECT metal1 shpemit_poly BY odCont 
CONNECT shpemit_poly emit 
CONNECT shpemit_poly emit_poly 
CONNECT shpemit_poly emit_rpo 
CONNECT shpemit_poly hpwcol_lat 
CONNECT shpemit_poly hpwemit_lat 
CONNECT shpemit_poly hvpdfs 
CONNECT shpemit_poly ioemit 
CONNECT shpemit_poly ioemit_poly 
CONNECT shpemit_poly nddemit 
CONNECT shpemit_poly ntap 
CONNECT shpemit_poly nwemit 
CONNECT shpemit_poly phvnwemit 
CONNECT shpemit_poly pplug_inhvnw 
CONNECT shpemit_poly ptap 
CONNECT shpemit_poly sbd_hv_dio_gen2_dio 
CONNECT shpemit_poly schottky_p 
CONNECT shpemit_poly shpemit 
CONNECT shpemit_poly stack_esd_plus 
CONNECT shpemit_poly tiod 
CONNECT shpemit_poly tpdiff 
CONNECT shpemit_poly tpdiff_s 
CONNECT shpemit_poly tpdiff_woR 

CONNECT shpemit_poly hvndfs
CONNECT shpemit_poly shpemit_7t_e1
CONNECT shpemit_poly shpemit_7t_e8
CONNECT shpemit_poly tndiff_woR
CONNECT shpemit_poly schottky_n
CONNECT tndiff hvndfs
CONNECT metal1 hvndfs BY odCont 
CONNECT hvndfs emit 
CONNECT hvndfs emit_poly 
CONNECT hvndfs emit_rpo 
CONNECT hvndfs hpwcol_lat 
CONNECT hvndfs hpwemit_lat 
CONNECT hvndfs hvpdfs 
CONNECT hvndfs ioemit 
CONNECT hvndfs ioemit_poly 
CONNECT hvndfs nddemit 
CONNECT hvndfs ntap 
CONNECT hvndfs nwemit 
CONNECT hvndfs phvnwemit 
CONNECT hvndfs pplug_inhvnw 
CONNECT hvndfs ptap 
CONNECT hvndfs sbd_hv_dio_gen2_dio 
CONNECT hvndfs schottky_p 
CONNECT hvndfs shpemit 
CONNECT hvndfs stack_esd_plus 
CONNECT hvndfs tiod 
CONNECT hvndfs tpdiff 
CONNECT hvndfs tpdiff_s 
CONNECT hvndfs tpdiff_woR 

CONNECT hvndfs shpemit_7t_e1
CONNECT hvndfs shpemit_7t_e8
CONNECT hvndfs tndiff_woR
CONNECT hvndfs schottky_n
CONNECT tndiff shpemit_7t_e1
CONNECT metal1 shpemit_7t_e1 BY odCont 
CONNECT shpemit_7t_e1 emit 
CONNECT shpemit_7t_e1 emit_poly 
CONNECT shpemit_7t_e1 emit_rpo 
CONNECT shpemit_7t_e1 hpwcol_lat 
CONNECT shpemit_7t_e1 hpwemit_lat 
CONNECT shpemit_7t_e1 hvpdfs 
CONNECT shpemit_7t_e1 ioemit 
CONNECT shpemit_7t_e1 ioemit_poly 
CONNECT shpemit_7t_e1 nddemit 
CONNECT shpemit_7t_e1 ntap 
CONNECT shpemit_7t_e1 nwemit 
CONNECT shpemit_7t_e1 phvnwemit 
CONNECT shpemit_7t_e1 pplug_inhvnw 
CONNECT shpemit_7t_e1 ptap 
CONNECT shpemit_7t_e1 sbd_hv_dio_gen2_dio 
CONNECT shpemit_7t_e1 schottky_p 
CONNECT shpemit_7t_e1 shpemit 
CONNECT shpemit_7t_e1 stack_esd_plus 
CONNECT shpemit_7t_e1 tiod 
CONNECT shpemit_7t_e1 tpdiff 
CONNECT shpemit_7t_e1 tpdiff_s 
CONNECT shpemit_7t_e1 tpdiff_woR 

CONNECT shpemit_7t_e1 shpemit_7t_e8
CONNECT shpemit_7t_e1 tndiff_woR
CONNECT shpemit_7t_e1 schottky_n
CONNECT tndiff shpemit_7t_e8
CONNECT metal1 shpemit_7t_e8 BY odCont 
CONNECT shpemit_7t_e8 emit 
CONNECT shpemit_7t_e8 emit_poly 
CONNECT shpemit_7t_e8 emit_rpo 
CONNECT shpemit_7t_e8 hpwcol_lat 
CONNECT shpemit_7t_e8 hpwemit_lat 
CONNECT shpemit_7t_e8 hvpdfs 
CONNECT shpemit_7t_e8 ioemit 
CONNECT shpemit_7t_e8 ioemit_poly 
CONNECT shpemit_7t_e8 nddemit 
CONNECT shpemit_7t_e8 ntap 
CONNECT shpemit_7t_e8 nwemit 
CONNECT shpemit_7t_e8 phvnwemit 
CONNECT shpemit_7t_e8 pplug_inhvnw 
CONNECT shpemit_7t_e8 ptap 
CONNECT shpemit_7t_e8 sbd_hv_dio_gen2_dio 
CONNECT shpemit_7t_e8 schottky_p 
CONNECT shpemit_7t_e8 shpemit 
CONNECT shpemit_7t_e8 stack_esd_plus 
CONNECT shpemit_7t_e8 tiod 
CONNECT shpemit_7t_e8 tpdiff 
CONNECT shpemit_7t_e8 tpdiff_s 
CONNECT shpemit_7t_e8 tpdiff_woR 

CONNECT shpemit_7t_e8 tndiff_woR
CONNECT shpemit_7t_e8 schottky_n
CONNECT tndiff tndiff_woR
CONNECT metal1 tndiff_woR BY odCont 
CONNECT tndiff_woR emit 
CONNECT tndiff_woR emit_poly 
CONNECT tndiff_woR emit_rpo 
CONNECT tndiff_woR hpwcol_lat 
CONNECT tndiff_woR hpwemit_lat 
CONNECT tndiff_woR hvpdfs 
CONNECT tndiff_woR ioemit 
CONNECT tndiff_woR ioemit_poly 
CONNECT tndiff_woR nddemit 
CONNECT tndiff_woR ntap 
CONNECT tndiff_woR nwemit 
CONNECT tndiff_woR phvnwemit 
CONNECT tndiff_woR pplug_inhvnw 
CONNECT tndiff_woR ptap 
CONNECT tndiff_woR sbd_hv_dio_gen2_dio 
CONNECT tndiff_woR schottky_p 
CONNECT tndiff_woR shpemit 
CONNECT tndiff_woR stack_esd_plus 
CONNECT tndiff_woR tiod 
CONNECT tndiff_woR tpdiff 
CONNECT tndiff_woR tpdiff_s 
CONNECT tndiff_woR tpdiff_woR 

CONNECT tndiff_woR schottky_n
CONNECT tndiff schottky_n
CONNECT metal1 schottky_n BY odCont 
CONNECT schottky_n emit 
CONNECT schottky_n emit_poly 
CONNECT schottky_n emit_rpo 
CONNECT schottky_n hpwcol_lat 
CONNECT schottky_n hpwemit_lat 
CONNECT schottky_n hvpdfs 
CONNECT schottky_n ioemit 
CONNECT schottky_n ioemit_poly 
CONNECT schottky_n nddemit 
CONNECT schottky_n ntap 
CONNECT schottky_n nwemit 
CONNECT schottky_n phvnwemit 
CONNECT schottky_n pplug_inhvnw 
CONNECT schottky_n ptap 
CONNECT schottky_n sbd_hv_dio_gen2_dio 
CONNECT schottky_n schottky_p 
CONNECT schottky_n shpemit 
CONNECT schottky_n stack_esd_plus 
CONNECT schottky_n tiod 
CONNECT schottky_n tpdiff 
CONNECT schottky_n tpdiff_s 
CONNECT schottky_n tpdiff_woR 

CONNECT tpdiff emit_rpo
CONNECT metal1 emit_rpo BY odCont 
CONNECT tndiff emit_rpo 
CONNECT emit_rpo emit 
CONNECT emit_rpo emit_poly 
CONNECT emit_rpo hpwcol_lat 
CONNECT emit_rpo hpwemit_lat 
CONNECT emit_rpo ntap 
CONNECT emit_rpo nwemit 
CONNECT emit_rpo pplug_inhvnw 
CONNECT emit_rpo ptap 
CONNECT emit_rpo shpemit 
CONNECT emit_rpo tiod 

CONNECT emit_rpo hvpdfs
CONNECT emit_rpo ioemit
CONNECT emit_rpo ioemit_poly
CONNECT emit_rpo nddemit
CONNECT emit_rpo phvnwemit
CONNECT emit_rpo stack_esd_plus
CONNECT emit_rpo tpdiff_woR
CONNECT emit_rpo schottky_p
CONNECT emit_rpo sbd_hv_dio_gen2_dio
CONNECT emit_rpo tpdiff_s
CONNECT tpdiff hvpdfs
CONNECT metal1 hvpdfs BY odCont 
CONNECT tndiff hvpdfs 
CONNECT hvpdfs emit 
CONNECT hvpdfs emit_poly 
CONNECT hvpdfs hpwcol_lat 
CONNECT hvpdfs hpwemit_lat 
CONNECT hvpdfs ntap 
CONNECT hvpdfs nwemit 
CONNECT hvpdfs pplug_inhvnw 
CONNECT hvpdfs ptap 
CONNECT hvpdfs shpemit 
CONNECT hvpdfs tiod 

CONNECT hvpdfs ioemit
CONNECT hvpdfs ioemit_poly
CONNECT hvpdfs nddemit
CONNECT hvpdfs phvnwemit
CONNECT hvpdfs stack_esd_plus
CONNECT hvpdfs tpdiff_woR
CONNECT hvpdfs schottky_p
CONNECT hvpdfs sbd_hv_dio_gen2_dio
CONNECT hvpdfs tpdiff_s
CONNECT tpdiff ioemit
CONNECT metal1 ioemit BY odCont 
CONNECT tndiff ioemit 
CONNECT ioemit emit 
CONNECT ioemit emit_poly 
CONNECT ioemit hpwcol_lat 
CONNECT ioemit hpwemit_lat 
CONNECT ioemit ntap 
CONNECT ioemit nwemit 
CONNECT ioemit pplug_inhvnw 
CONNECT ioemit ptap 
CONNECT ioemit shpemit 
CONNECT ioemit tiod 

CONNECT ioemit ioemit_poly
CONNECT ioemit nddemit
CONNECT ioemit phvnwemit
CONNECT ioemit stack_esd_plus
CONNECT ioemit tpdiff_woR
CONNECT ioemit schottky_p
CONNECT ioemit sbd_hv_dio_gen2_dio
CONNECT ioemit tpdiff_s
CONNECT tpdiff ioemit_poly
CONNECT metal1 ioemit_poly BY odCont 
CONNECT tndiff ioemit_poly 
CONNECT ioemit_poly emit 
CONNECT ioemit_poly emit_poly 
CONNECT ioemit_poly hpwcol_lat 
CONNECT ioemit_poly hpwemit_lat 
CONNECT ioemit_poly ntap 
CONNECT ioemit_poly nwemit 
CONNECT ioemit_poly pplug_inhvnw 
CONNECT ioemit_poly ptap 
CONNECT ioemit_poly shpemit 
CONNECT ioemit_poly tiod 

CONNECT ioemit_poly nddemit
CONNECT ioemit_poly phvnwemit
CONNECT ioemit_poly stack_esd_plus
CONNECT ioemit_poly tpdiff_woR
CONNECT ioemit_poly schottky_p
CONNECT ioemit_poly sbd_hv_dio_gen2_dio
CONNECT ioemit_poly tpdiff_s
CONNECT tpdiff nddemit
CONNECT metal1 nddemit BY odCont 
CONNECT tndiff nddemit 
CONNECT nddemit emit 
CONNECT nddemit emit_poly 
CONNECT nddemit hpwcol_lat 
CONNECT nddemit hpwemit_lat 
CONNECT nddemit ntap 
CONNECT nddemit nwemit 
CONNECT nddemit pplug_inhvnw 
CONNECT nddemit ptap 
CONNECT nddemit shpemit 
CONNECT nddemit tiod 

CONNECT nddemit phvnwemit
CONNECT nddemit stack_esd_plus
CONNECT nddemit tpdiff_woR
CONNECT nddemit schottky_p
CONNECT nddemit sbd_hv_dio_gen2_dio
CONNECT nddemit tpdiff_s
CONNECT tpdiff phvnwemit
CONNECT metal1 phvnwemit BY odCont 
CONNECT tndiff phvnwemit 
CONNECT phvnwemit emit 
CONNECT phvnwemit emit_poly 
CONNECT phvnwemit hpwcol_lat 
CONNECT phvnwemit hpwemit_lat 
CONNECT phvnwemit ntap 
CONNECT phvnwemit nwemit 
CONNECT phvnwemit pplug_inhvnw 
CONNECT phvnwemit ptap 
CONNECT phvnwemit shpemit 
CONNECT phvnwemit tiod 

CONNECT phvnwemit stack_esd_plus
CONNECT phvnwemit tpdiff_woR
CONNECT phvnwemit schottky_p
CONNECT phvnwemit sbd_hv_dio_gen2_dio
CONNECT phvnwemit tpdiff_s
CONNECT tpdiff stack_esd_plus
CONNECT metal1 stack_esd_plus BY odCont 
CONNECT tndiff stack_esd_plus 
CONNECT stack_esd_plus emit 
CONNECT stack_esd_plus emit_poly 
CONNECT stack_esd_plus hpwcol_lat 
CONNECT stack_esd_plus hpwemit_lat 
CONNECT stack_esd_plus ntap 
CONNECT stack_esd_plus nwemit 
CONNECT stack_esd_plus pplug_inhvnw 
CONNECT stack_esd_plus ptap 
CONNECT stack_esd_plus shpemit 
CONNECT stack_esd_plus tiod 

CONNECT stack_esd_plus tpdiff_woR
CONNECT stack_esd_plus schottky_p
CONNECT stack_esd_plus sbd_hv_dio_gen2_dio
CONNECT stack_esd_plus tpdiff_s
CONNECT tpdiff tpdiff_woR
CONNECT metal1 tpdiff_woR BY odCont 
CONNECT tndiff tpdiff_woR 
CONNECT tpdiff_woR emit 
CONNECT tpdiff_woR emit_poly 
CONNECT tpdiff_woR hpwcol_lat 
CONNECT tpdiff_woR hpwemit_lat 
CONNECT tpdiff_woR ntap 
CONNECT tpdiff_woR nwemit 
CONNECT tpdiff_woR pplug_inhvnw 
CONNECT tpdiff_woR ptap 
CONNECT tpdiff_woR shpemit 
CONNECT tpdiff_woR tiod 

CONNECT tpdiff_woR schottky_p
CONNECT tpdiff_woR sbd_hv_dio_gen2_dio
CONNECT tpdiff_woR tpdiff_s
CONNECT tpdiff schottky_p
CONNECT metal1 schottky_p BY odCont 
CONNECT tndiff schottky_p 
CONNECT schottky_p emit 
CONNECT schottky_p emit_poly 
CONNECT schottky_p hpwcol_lat 
CONNECT schottky_p hpwemit_lat 
CONNECT schottky_p ntap 
CONNECT schottky_p nwemit 
CONNECT schottky_p pplug_inhvnw 
CONNECT schottky_p ptap 
CONNECT schottky_p shpemit 
CONNECT schottky_p tiod 

CONNECT schottky_p sbd_hv_dio_gen2_dio
CONNECT schottky_p tpdiff_s
CONNECT tpdiff sbd_hv_dio_gen2_dio
CONNECT metal1 sbd_hv_dio_gen2_dio BY odCont 
CONNECT tndiff sbd_hv_dio_gen2_dio 
CONNECT sbd_hv_dio_gen2_dio emit 
CONNECT sbd_hv_dio_gen2_dio emit_poly 
CONNECT sbd_hv_dio_gen2_dio hpwcol_lat 
CONNECT sbd_hv_dio_gen2_dio hpwemit_lat 
CONNECT sbd_hv_dio_gen2_dio ntap 
CONNECT sbd_hv_dio_gen2_dio nwemit 
CONNECT sbd_hv_dio_gen2_dio pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio ptap 
CONNECT sbd_hv_dio_gen2_dio shpemit 
CONNECT sbd_hv_dio_gen2_dio tiod 

CONNECT sbd_hv_dio_gen2_dio tpdiff_s
CONNECT tpdiff tpdiff_s
CONNECT metal1 tpdiff_s BY odCont 
CONNECT tndiff tpdiff_s 
CONNECT tpdiff_s emit 
CONNECT tpdiff_s emit_poly 
CONNECT tpdiff_s hpwcol_lat 
CONNECT tpdiff_s hpwemit_lat 
CONNECT tpdiff_s ntap 
CONNECT tpdiff_s nwemit 
CONNECT tpdiff_s pplug_inhvnw 
CONNECT tpdiff_s ptap 
CONNECT tpdiff_s shpemit 
CONNECT tpdiff_s tiod 


#IFDEF RC_DECK
CONNECT hnemit HVNW BY nplug 
CONNECT hnemit NBL BY nplug_nbl 
CONNECT hnemit NDD BY nplug 
CONNECT hnemit SH_N BY nplug 
CONNECT hnemit hncol BY nplug 
CONNECT hnemit hncol_shp BY nplug 
CONNECT hnemit hncol_shp_7t_c1 BY nplug 
CONNECT hnemit hncol_shp_7t_c8 BY nplug 
CONNECT hnemit hnwbase BY nplug 
CONNECT hnemit hnwbase_lat BY nplug 
CONNECT hnemit hvndfd BY nplug 
CONNECT hnemit hvndfd_ndd BY nplug 
CONNECT hnemit hvndfd_shn BY nplug 
CONNECT hnemit hvndfd_shn_ndd BY nplug 
CONNECT hnemit ionbase BY nplug 
CONNECT hnemit iso_hvnw BY nplug 
CONNECT hnemit nbase BY nplug 
CONNECT hnemit nddbase BY nplug 
CONNECT hnemit nxwell BY nplug 
CONNECT hnemit phvnwbase BY nplug 
CONNECT hnemit s_hvnw BY nplug 
CONNECT hnemit stack_esd_minus BY nplug_nbl 

CONNECT shpemit_poly HVNW BY nplug 
CONNECT shpemit_poly NBL BY nplug_nbl 
CONNECT shpemit_poly NDD BY nplug 
CONNECT shpemit_poly SH_N BY nplug 
CONNECT shpemit_poly hncol BY nplug 
CONNECT shpemit_poly hncol_shp BY nplug 
CONNECT shpemit_poly hncol_shp_7t_c1 BY nplug 
CONNECT shpemit_poly hncol_shp_7t_c8 BY nplug 
CONNECT shpemit_poly hnwbase BY nplug 
CONNECT shpemit_poly hnwbase_lat BY nplug 
CONNECT shpemit_poly hvndfd BY nplug 
CONNECT shpemit_poly hvndfd_ndd BY nplug 
CONNECT shpemit_poly hvndfd_shn BY nplug 
CONNECT shpemit_poly hvndfd_shn_ndd BY nplug 
CONNECT shpemit_poly ionbase BY nplug 
CONNECT shpemit_poly iso_hvnw BY nplug 
CONNECT shpemit_poly nbase BY nplug 
CONNECT shpemit_poly nddbase BY nplug 
CONNECT shpemit_poly nxwell BY nplug 
CONNECT shpemit_poly phvnwbase BY nplug 
CONNECT shpemit_poly s_hvnw BY nplug 
CONNECT shpemit_poly stack_esd_minus BY nplug_nbl 

CONNECT hvndfs HVNW BY nplug 
CONNECT hvndfs NBL BY nplug_nbl 
CONNECT hvndfs NDD BY nplug 
CONNECT hvndfs SH_N BY nplug 
CONNECT hvndfs hncol BY nplug 
CONNECT hvndfs hncol_shp BY nplug 
CONNECT hvndfs hncol_shp_7t_c1 BY nplug 
CONNECT hvndfs hncol_shp_7t_c8 BY nplug 
CONNECT hvndfs hnwbase BY nplug 
CONNECT hvndfs hnwbase_lat BY nplug 
CONNECT hvndfs hvndfd BY nplug 
CONNECT hvndfs hvndfd_ndd BY nplug 
CONNECT hvndfs hvndfd_shn BY nplug 
CONNECT hvndfs hvndfd_shn_ndd BY nplug 
CONNECT hvndfs ionbase BY nplug 
CONNECT hvndfs iso_hvnw BY nplug 
CONNECT hvndfs nbase BY nplug 
CONNECT hvndfs nddbase BY nplug 
CONNECT hvndfs nxwell BY nplug 
CONNECT hvndfs phvnwbase BY nplug 
CONNECT hvndfs s_hvnw BY nplug 
CONNECT hvndfs stack_esd_minus BY nplug_nbl 

CONNECT shpemit_7t_e1 HVNW BY nplug 
CONNECT shpemit_7t_e1 NBL BY nplug_nbl 
CONNECT shpemit_7t_e1 NDD BY nplug 
CONNECT shpemit_7t_e1 SH_N BY nplug 
CONNECT shpemit_7t_e1 hncol BY nplug 
CONNECT shpemit_7t_e1 hncol_shp BY nplug 
CONNECT shpemit_7t_e1 hncol_shp_7t_c1 BY nplug 
CONNECT shpemit_7t_e1 hncol_shp_7t_c8 BY nplug 
CONNECT shpemit_7t_e1 hnwbase BY nplug 
CONNECT shpemit_7t_e1 hnwbase_lat BY nplug 
CONNECT shpemit_7t_e1 hvndfd BY nplug 
CONNECT shpemit_7t_e1 hvndfd_ndd BY nplug 
CONNECT shpemit_7t_e1 hvndfd_shn BY nplug 
CONNECT shpemit_7t_e1 hvndfd_shn_ndd BY nplug 
CONNECT shpemit_7t_e1 ionbase BY nplug 
CONNECT shpemit_7t_e1 iso_hvnw BY nplug 
CONNECT shpemit_7t_e1 nbase BY nplug 
CONNECT shpemit_7t_e1 nddbase BY nplug 
CONNECT shpemit_7t_e1 nxwell BY nplug 
CONNECT shpemit_7t_e1 phvnwbase BY nplug 
CONNECT shpemit_7t_e1 s_hvnw BY nplug 
CONNECT shpemit_7t_e1 stack_esd_minus BY nplug_nbl 

CONNECT shpemit_7t_e8 HVNW BY nplug 
CONNECT shpemit_7t_e8 NBL BY nplug_nbl 
CONNECT shpemit_7t_e8 NDD BY nplug 
CONNECT shpemit_7t_e8 SH_N BY nplug 
CONNECT shpemit_7t_e8 hncol BY nplug 
CONNECT shpemit_7t_e8 hncol_shp BY nplug 
CONNECT shpemit_7t_e8 hncol_shp_7t_c1 BY nplug 
CONNECT shpemit_7t_e8 hncol_shp_7t_c8 BY nplug 
CONNECT shpemit_7t_e8 hnwbase BY nplug 
CONNECT shpemit_7t_e8 hnwbase_lat BY nplug 
CONNECT shpemit_7t_e8 hvndfd BY nplug 
CONNECT shpemit_7t_e8 hvndfd_ndd BY nplug 
CONNECT shpemit_7t_e8 hvndfd_shn BY nplug 
CONNECT shpemit_7t_e8 hvndfd_shn_ndd BY nplug 
CONNECT shpemit_7t_e8 ionbase BY nplug 
CONNECT shpemit_7t_e8 iso_hvnw BY nplug 
CONNECT shpemit_7t_e8 nbase BY nplug 
CONNECT shpemit_7t_e8 nddbase BY nplug 
CONNECT shpemit_7t_e8 nxwell BY nplug 
CONNECT shpemit_7t_e8 phvnwbase BY nplug 
CONNECT shpemit_7t_e8 s_hvnw BY nplug 
CONNECT shpemit_7t_e8 stack_esd_minus BY nplug_nbl 

CONNECT tndiff_woR HVNW BY nplug 
CONNECT tndiff_woR NBL BY nplug_nbl 
CONNECT tndiff_woR NDD BY nplug 
CONNECT tndiff_woR SH_N BY nplug 
CONNECT tndiff_woR hncol BY nplug 
CONNECT tndiff_woR hncol_shp BY nplug 
CONNECT tndiff_woR hncol_shp_7t_c1 BY nplug 
CONNECT tndiff_woR hncol_shp_7t_c8 BY nplug 
CONNECT tndiff_woR hnwbase BY nplug 
CONNECT tndiff_woR hnwbase_lat BY nplug 
CONNECT tndiff_woR hvndfd BY nplug 
CONNECT tndiff_woR hvndfd_ndd BY nplug 
CONNECT tndiff_woR hvndfd_shn BY nplug 
CONNECT tndiff_woR hvndfd_shn_ndd BY nplug 
CONNECT tndiff_woR ionbase BY nplug 
CONNECT tndiff_woR iso_hvnw BY nplug 
CONNECT tndiff_woR nbase BY nplug 
CONNECT tndiff_woR nddbase BY nplug 
CONNECT tndiff_woR nxwell BY nplug 
CONNECT tndiff_woR phvnwbase BY nplug 
CONNECT tndiff_woR s_hvnw BY nplug 
CONNECT tndiff_woR stack_esd_minus BY nplug_nbl 

CONNECT schottky_n HVNW BY nplug 
CONNECT schottky_n NBL BY nplug_nbl 
CONNECT schottky_n NDD BY nplug 
CONNECT schottky_n SH_N BY nplug 
CONNECT schottky_n hncol BY nplug 
CONNECT schottky_n hncol_shp BY nplug 
CONNECT schottky_n hncol_shp_7t_c1 BY nplug 
CONNECT schottky_n hncol_shp_7t_c8 BY nplug 
CONNECT schottky_n hnwbase BY nplug 
CONNECT schottky_n hnwbase_lat BY nplug 
CONNECT schottky_n hvndfd BY nplug 
CONNECT schottky_n hvndfd_ndd BY nplug 
CONNECT schottky_n hvndfd_shn BY nplug 
CONNECT schottky_n hvndfd_shn_ndd BY nplug 
CONNECT schottky_n ionbase BY nplug 
CONNECT schottky_n iso_hvnw BY nplug 
CONNECT schottky_n nbase BY nplug 
CONNECT schottky_n nddbase BY nplug 
CONNECT schottky_n nxwell BY nplug 
CONNECT schottky_n phvnwbase BY nplug 
CONNECT schottky_n s_hvnw BY nplug 
CONNECT schottky_n stack_esd_minus BY nplug_nbl 

CONNECT emit_rpo HVPBi BY pplug_inhvnw 
CONNECT emit_rpo HVPW BY pplug 
CONNECT emit_rpo PDD BY pplug_inhvnw 
CONNECT emit_rpo SH_P BY pplug_inhvnw 
CONNECT emit_rpo coll BY pplug 
CONNECT emit_rpo hpbase BY pplug 
CONNECT emit_rpo hpwcol BY pplug 
CONNECT emit_rpo hvpdfd BY pplug 
CONNECT emit_rpo hvpdfd_hvpb BY pplug_inhvnw 
CONNECT emit_rpo hvpdfd_pdd BY pplug_inhvnw 
CONNECT emit_rpo hvpdfd_shp BY pplug_inhvnw 
CONNECT emit_rpo hvpsf_shp BY pplug 
CONNECT emit_rpo hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT emit_rpo hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT emit_rpo hvpwbase_ga BY pplug_inhvnw 
CONNECT emit_rpo hvpwbase_gb BY pplug 
CONNECT emit_rpo iocoll BY pplug 
CONNECT emit_rpo nddcol BY pplug 
CONNECT emit_rpo phvnwcol BY pplug 
CONNECT emit_rpo psub BY pplug 
CONNECT emit_rpo psub_term BY pplug 
CONNECT emit_rpo psub_term_ac BY pplug_ac 
CONNECT emit_rpo psub_term_nw BY pplug 
CONNECT emit_rpo psub_under_ANWEL BY pplug 
CONNECT emit_rpo psub_under_DPW_co_imp BY pplug 
CONNECT emit_rpo pw_iso BY pplug 
CONNECT emit_rpo shpcol_hvnw BY pplug_inhvnw 

CONNECT hvpdfs HVPBi BY pplug_inhvnw 
CONNECT hvpdfs HVPW BY pplug 
CONNECT hvpdfs PDD BY pplug_inhvnw 
CONNECT hvpdfs SH_P BY pplug_inhvnw 
CONNECT hvpdfs coll BY pplug 
CONNECT hvpdfs hpbase BY pplug 
CONNECT hvpdfs hpwcol BY pplug 
CONNECT hvpdfs hvpdfd BY pplug 
CONNECT hvpdfs hvpdfd_hvpb BY pplug_inhvnw 
CONNECT hvpdfs hvpdfd_pdd BY pplug_inhvnw 
CONNECT hvpdfs hvpdfd_shp BY pplug_inhvnw 
CONNECT hvpdfs hvpsf_shp BY pplug 
CONNECT hvpdfs hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT hvpdfs hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT hvpdfs hvpwbase_ga BY pplug_inhvnw 
CONNECT hvpdfs hvpwbase_gb BY pplug 
CONNECT hvpdfs iocoll BY pplug 
CONNECT hvpdfs nddcol BY pplug 
CONNECT hvpdfs phvnwcol BY pplug 
CONNECT hvpdfs psub BY pplug 
CONNECT hvpdfs psub_term BY pplug 
CONNECT hvpdfs psub_term_ac BY pplug_ac 
CONNECT hvpdfs psub_term_nw BY pplug 
CONNECT hvpdfs psub_under_ANWEL BY pplug 
CONNECT hvpdfs psub_under_DPW_co_imp BY pplug 
CONNECT hvpdfs pw_iso BY pplug 
CONNECT hvpdfs shpcol_hvnw BY pplug_inhvnw 

CONNECT ioemit HVPBi BY pplug_inhvnw 
CONNECT ioemit HVPW BY pplug 
CONNECT ioemit PDD BY pplug_inhvnw 
CONNECT ioemit SH_P BY pplug_inhvnw 
CONNECT ioemit coll BY pplug 
CONNECT ioemit hpbase BY pplug 
CONNECT ioemit hpwcol BY pplug 
CONNECT ioemit hvpdfd BY pplug 
CONNECT ioemit hvpdfd_hvpb BY pplug_inhvnw 
CONNECT ioemit hvpdfd_pdd BY pplug_inhvnw 
CONNECT ioemit hvpdfd_shp BY pplug_inhvnw 
CONNECT ioemit hvpsf_shp BY pplug 
CONNECT ioemit hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT ioemit hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT ioemit hvpwbase_ga BY pplug_inhvnw 
CONNECT ioemit hvpwbase_gb BY pplug 
CONNECT ioemit iocoll BY pplug 
CONNECT ioemit nddcol BY pplug 
CONNECT ioemit phvnwcol BY pplug 
CONNECT ioemit psub BY pplug 
CONNECT ioemit psub_term BY pplug 
CONNECT ioemit psub_term_ac BY pplug_ac 
CONNECT ioemit psub_term_nw BY pplug 
CONNECT ioemit psub_under_ANWEL BY pplug 
CONNECT ioemit psub_under_DPW_co_imp BY pplug 
CONNECT ioemit pw_iso BY pplug 
CONNECT ioemit shpcol_hvnw BY pplug_inhvnw 

CONNECT ioemit_poly HVPBi BY pplug_inhvnw 
CONNECT ioemit_poly HVPW BY pplug 
CONNECT ioemit_poly PDD BY pplug_inhvnw 
CONNECT ioemit_poly SH_P BY pplug_inhvnw 
CONNECT ioemit_poly coll BY pplug 
CONNECT ioemit_poly hpbase BY pplug 
CONNECT ioemit_poly hpwcol BY pplug 
CONNECT ioemit_poly hvpdfd BY pplug 
CONNECT ioemit_poly hvpdfd_hvpb BY pplug_inhvnw 
CONNECT ioemit_poly hvpdfd_pdd BY pplug_inhvnw 
CONNECT ioemit_poly hvpdfd_shp BY pplug_inhvnw 
CONNECT ioemit_poly hvpsf_shp BY pplug 
CONNECT ioemit_poly hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT ioemit_poly hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT ioemit_poly hvpwbase_ga BY pplug_inhvnw 
CONNECT ioemit_poly hvpwbase_gb BY pplug 
CONNECT ioemit_poly iocoll BY pplug 
CONNECT ioemit_poly nddcol BY pplug 
CONNECT ioemit_poly phvnwcol BY pplug 
CONNECT ioemit_poly psub BY pplug 
CONNECT ioemit_poly psub_term BY pplug 
CONNECT ioemit_poly psub_term_ac BY pplug_ac 
CONNECT ioemit_poly psub_term_nw BY pplug 
CONNECT ioemit_poly psub_under_ANWEL BY pplug 
CONNECT ioemit_poly psub_under_DPW_co_imp BY pplug 
CONNECT ioemit_poly pw_iso BY pplug 
CONNECT ioemit_poly shpcol_hvnw BY pplug_inhvnw 

CONNECT nddemit HVPBi BY pplug_inhvnw 
CONNECT nddemit HVPW BY pplug 
CONNECT nddemit PDD BY pplug_inhvnw 
CONNECT nddemit SH_P BY pplug_inhvnw 
CONNECT nddemit coll BY pplug 
CONNECT nddemit hpbase BY pplug 
CONNECT nddemit hpwcol BY pplug 
CONNECT nddemit hvpdfd BY pplug 
CONNECT nddemit hvpdfd_hvpb BY pplug_inhvnw 
CONNECT nddemit hvpdfd_pdd BY pplug_inhvnw 
CONNECT nddemit hvpdfd_shp BY pplug_inhvnw 
CONNECT nddemit hvpsf_shp BY pplug 
CONNECT nddemit hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT nddemit hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT nddemit hvpwbase_ga BY pplug_inhvnw 
CONNECT nddemit hvpwbase_gb BY pplug 
CONNECT nddemit iocoll BY pplug 
CONNECT nddemit nddcol BY pplug 
CONNECT nddemit phvnwcol BY pplug 
CONNECT nddemit psub BY pplug 
CONNECT nddemit psub_term BY pplug 
CONNECT nddemit psub_term_ac BY pplug_ac 
CONNECT nddemit psub_term_nw BY pplug 
CONNECT nddemit psub_under_ANWEL BY pplug 
CONNECT nddemit psub_under_DPW_co_imp BY pplug 
CONNECT nddemit pw_iso BY pplug 
CONNECT nddemit shpcol_hvnw BY pplug_inhvnw 

CONNECT phvnwemit HVPBi BY pplug_inhvnw 
CONNECT phvnwemit HVPW BY pplug 
CONNECT phvnwemit PDD BY pplug_inhvnw 
CONNECT phvnwemit SH_P BY pplug_inhvnw 
CONNECT phvnwemit coll BY pplug 
CONNECT phvnwemit hpbase BY pplug 
CONNECT phvnwemit hpwcol BY pplug 
CONNECT phvnwemit hvpdfd BY pplug 
CONNECT phvnwemit hvpdfd_hvpb BY pplug_inhvnw 
CONNECT phvnwemit hvpdfd_pdd BY pplug_inhvnw 
CONNECT phvnwemit hvpdfd_shp BY pplug_inhvnw 
CONNECT phvnwemit hvpsf_shp BY pplug 
CONNECT phvnwemit hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT phvnwemit hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT phvnwemit hvpwbase_ga BY pplug_inhvnw 
CONNECT phvnwemit hvpwbase_gb BY pplug 
CONNECT phvnwemit iocoll BY pplug 
CONNECT phvnwemit nddcol BY pplug 
CONNECT phvnwemit phvnwcol BY pplug 
CONNECT phvnwemit psub BY pplug 
CONNECT phvnwemit psub_term BY pplug 
CONNECT phvnwemit psub_term_ac BY pplug_ac 
CONNECT phvnwemit psub_term_nw BY pplug 
CONNECT phvnwemit psub_under_ANWEL BY pplug 
CONNECT phvnwemit psub_under_DPW_co_imp BY pplug 
CONNECT phvnwemit pw_iso BY pplug 
CONNECT phvnwemit shpcol_hvnw BY pplug_inhvnw 

CONNECT stack_esd_plus HVPBi BY pplug_inhvnw 
CONNECT stack_esd_plus HVPW BY pplug 
CONNECT stack_esd_plus PDD BY pplug_inhvnw 
CONNECT stack_esd_plus SH_P BY pplug_inhvnw 
CONNECT stack_esd_plus coll BY pplug 
CONNECT stack_esd_plus hpbase BY pplug 
CONNECT stack_esd_plus hpwcol BY pplug 
CONNECT stack_esd_plus hvpdfd BY pplug 
CONNECT stack_esd_plus hvpdfd_hvpb BY pplug_inhvnw 
CONNECT stack_esd_plus hvpdfd_pdd BY pplug_inhvnw 
CONNECT stack_esd_plus hvpdfd_shp BY pplug_inhvnw 
CONNECT stack_esd_plus hvpsf_shp BY pplug 
CONNECT stack_esd_plus hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT stack_esd_plus hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT stack_esd_plus hvpwbase_ga BY pplug_inhvnw 
CONNECT stack_esd_plus hvpwbase_gb BY pplug 
CONNECT stack_esd_plus iocoll BY pplug 
CONNECT stack_esd_plus nddcol BY pplug 
CONNECT stack_esd_plus phvnwcol BY pplug 
CONNECT stack_esd_plus psub BY pplug 
CONNECT stack_esd_plus psub_term BY pplug 
CONNECT stack_esd_plus psub_term_ac BY pplug_ac 
CONNECT stack_esd_plus psub_term_nw BY pplug 
CONNECT stack_esd_plus psub_under_ANWEL BY pplug 
CONNECT stack_esd_plus psub_under_DPW_co_imp BY pplug 
CONNECT stack_esd_plus pw_iso BY pplug 
CONNECT stack_esd_plus shpcol_hvnw BY pplug_inhvnw 

CONNECT tpdiff_woR HVPBi BY pplug_inhvnw 
CONNECT tpdiff_woR HVPW BY pplug 
CONNECT tpdiff_woR PDD BY pplug_inhvnw 
CONNECT tpdiff_woR SH_P BY pplug_inhvnw 
CONNECT tpdiff_woR coll BY pplug 
CONNECT tpdiff_woR hpbase BY pplug 
CONNECT tpdiff_woR hpwcol BY pplug 
CONNECT tpdiff_woR hvpdfd BY pplug 
CONNECT tpdiff_woR hvpdfd_hvpb BY pplug_inhvnw 
CONNECT tpdiff_woR hvpdfd_pdd BY pplug_inhvnw 
CONNECT tpdiff_woR hvpdfd_shp BY pplug_inhvnw 
CONNECT tpdiff_woR hvpsf_shp BY pplug 
CONNECT tpdiff_woR hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT tpdiff_woR hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT tpdiff_woR hvpwbase_ga BY pplug_inhvnw 
CONNECT tpdiff_woR hvpwbase_gb BY pplug 
CONNECT tpdiff_woR iocoll BY pplug 
CONNECT tpdiff_woR nddcol BY pplug 
CONNECT tpdiff_woR phvnwcol BY pplug 
CONNECT tpdiff_woR psub BY pplug 
CONNECT tpdiff_woR psub_term BY pplug 
CONNECT tpdiff_woR psub_term_ac BY pplug_ac 
CONNECT tpdiff_woR psub_term_nw BY pplug 
CONNECT tpdiff_woR psub_under_ANWEL BY pplug 
CONNECT tpdiff_woR psub_under_DPW_co_imp BY pplug 
CONNECT tpdiff_woR pw_iso BY pplug 
CONNECT tpdiff_woR shpcol_hvnw BY pplug_inhvnw 

CONNECT schottky_p HVPBi BY pplug_inhvnw 
CONNECT schottky_p HVPW BY pplug 
CONNECT schottky_p PDD BY pplug_inhvnw 
CONNECT schottky_p SH_P BY pplug_inhvnw 
CONNECT schottky_p coll BY pplug 
CONNECT schottky_p hpbase BY pplug 
CONNECT schottky_p hpwcol BY pplug 
CONNECT schottky_p hvpdfd BY pplug 
CONNECT schottky_p hvpdfd_hvpb BY pplug_inhvnw 
CONNECT schottky_p hvpdfd_pdd BY pplug_inhvnw 
CONNECT schottky_p hvpdfd_shp BY pplug_inhvnw 
CONNECT schottky_p hvpsf_shp BY pplug 
CONNECT schottky_p hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT schottky_p hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT schottky_p hvpwbase_ga BY pplug_inhvnw 
CONNECT schottky_p hvpwbase_gb BY pplug 
CONNECT schottky_p iocoll BY pplug 
CONNECT schottky_p nddcol BY pplug 
CONNECT schottky_p phvnwcol BY pplug 
CONNECT schottky_p psub BY pplug 
CONNECT schottky_p psub_term BY pplug 
CONNECT schottky_p psub_term_ac BY pplug_ac 
CONNECT schottky_p psub_term_nw BY pplug 
CONNECT schottky_p psub_under_ANWEL BY pplug 
CONNECT schottky_p psub_under_DPW_co_imp BY pplug 
CONNECT schottky_p pw_iso BY pplug 
CONNECT schottky_p shpcol_hvnw BY pplug_inhvnw 

CONNECT sbd_hv_dio_gen2_dio HVPBi BY pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio HVPW BY pplug 
CONNECT sbd_hv_dio_gen2_dio PDD BY pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio SH_P BY pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio coll BY pplug 
CONNECT sbd_hv_dio_gen2_dio hpbase BY pplug 
CONNECT sbd_hv_dio_gen2_dio hpwcol BY pplug 
CONNECT sbd_hv_dio_gen2_dio hvpdfd BY pplug 
CONNECT sbd_hv_dio_gen2_dio hvpdfd_hvpb BY pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio hvpdfd_pdd BY pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio hvpdfd_shp BY pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio hvpsf_shp BY pplug 
CONNECT sbd_hv_dio_gen2_dio hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio hvpwbase_ga BY pplug_inhvnw 
CONNECT sbd_hv_dio_gen2_dio hvpwbase_gb BY pplug 
CONNECT sbd_hv_dio_gen2_dio iocoll BY pplug 
CONNECT sbd_hv_dio_gen2_dio nddcol BY pplug 
CONNECT sbd_hv_dio_gen2_dio phvnwcol BY pplug 
CONNECT sbd_hv_dio_gen2_dio psub BY pplug 
CONNECT sbd_hv_dio_gen2_dio psub_term BY pplug 
CONNECT sbd_hv_dio_gen2_dio psub_term_ac BY pplug_ac 
CONNECT sbd_hv_dio_gen2_dio psub_term_nw BY pplug 
CONNECT sbd_hv_dio_gen2_dio psub_under_ANWEL BY pplug 
CONNECT sbd_hv_dio_gen2_dio psub_under_DPW_co_imp BY pplug 
CONNECT sbd_hv_dio_gen2_dio pw_iso BY pplug 
CONNECT sbd_hv_dio_gen2_dio shpcol_hvnw BY pplug_inhvnw 

CONNECT tpdiff_s HVPBi BY pplug_inhvnw 
CONNECT tpdiff_s HVPW BY pplug 
CONNECT tpdiff_s PDD BY pplug_inhvnw 
CONNECT tpdiff_s SH_P BY pplug_inhvnw 
CONNECT tpdiff_s coll BY pplug 
CONNECT tpdiff_s hpbase BY pplug 
CONNECT tpdiff_s hpwcol BY pplug 
CONNECT tpdiff_s hvpdfd BY pplug 
CONNECT tpdiff_s hvpdfd_hvpb BY pplug_inhvnw 
CONNECT tpdiff_s hvpdfd_pdd BY pplug_inhvnw 
CONNECT tpdiff_s hvpdfd_shp BY pplug_inhvnw 
CONNECT tpdiff_s hvpsf_shp BY pplug 
CONNECT tpdiff_s hvpwbase_7t_ga_b1 BY pplug_inhvnw 
CONNECT tpdiff_s hvpwbase_7t_ga_b8 BY pplug_inhvnw 
CONNECT tpdiff_s hvpwbase_ga BY pplug_inhvnw 
CONNECT tpdiff_s hvpwbase_gb BY pplug 
CONNECT tpdiff_s iocoll BY pplug 
CONNECT tpdiff_s nddcol BY pplug 
CONNECT tpdiff_s phvnwcol BY pplug 
CONNECT tpdiff_s psub BY pplug 
CONNECT tpdiff_s psub_term BY pplug 
CONNECT tpdiff_s psub_term_ac BY pplug_ac 
CONNECT tpdiff_s psub_term_nw BY pplug 
CONNECT tpdiff_s psub_under_ANWEL BY pplug 
CONNECT tpdiff_s psub_under_DPW_co_imp BY pplug 
CONNECT tpdiff_s pw_iso BY pplug 
CONNECT tpdiff_s shpcol_hvnw BY pplug_inhvnw 

#ELSE
SCONNECT hnemit HVNW BY nplug 
SCONNECT hnemit NBL BY nplug_nbl 
SCONNECT hnemit NDD BY nplug 
SCONNECT hnemit SH_N BY nplug 
SCONNECT hnemit hncol BY nplug 
SCONNECT hnemit hncol_shp BY nplug 
SCONNECT hnemit hncol_shp_7t_c1 BY nplug 
SCONNECT hnemit hncol_shp_7t_c8 BY nplug 
SCONNECT hnemit hnwbase BY nplug 
SCONNECT hnemit hnwbase_lat BY nplug 
SCONNECT hnemit hvndfd BY nplug 
SCONNECT hnemit hvndfd_ndd BY nplug 
SCONNECT hnemit hvndfd_shn BY nplug 
SCONNECT hnemit hvndfd_shn_ndd BY nplug 
SCONNECT hnemit ionbase BY nplug 
SCONNECT hnemit iso_hvnw BY nplug 
SCONNECT hnemit nbase BY nplug 
SCONNECT hnemit nddbase BY nplug 
SCONNECT hnemit nxwell BY nplug 
SCONNECT hnemit phvnwbase BY nplug 
SCONNECT hnemit s_hvnw BY nplug 
SCONNECT hnemit stack_esd_minus BY nplug_nbl 

SCONNECT shpemit_poly HVNW BY nplug 
SCONNECT shpemit_poly NBL BY nplug_nbl 
SCONNECT shpemit_poly NDD BY nplug 
SCONNECT shpemit_poly SH_N BY nplug 
SCONNECT shpemit_poly hncol BY nplug 
SCONNECT shpemit_poly hncol_shp BY nplug 
SCONNECT shpemit_poly hncol_shp_7t_c1 BY nplug 
SCONNECT shpemit_poly hncol_shp_7t_c8 BY nplug 
SCONNECT shpemit_poly hnwbase BY nplug 
SCONNECT shpemit_poly hnwbase_lat BY nplug 
SCONNECT shpemit_poly hvndfd BY nplug 
SCONNECT shpemit_poly hvndfd_ndd BY nplug 
SCONNECT shpemit_poly hvndfd_shn BY nplug 
SCONNECT shpemit_poly hvndfd_shn_ndd BY nplug 
SCONNECT shpemit_poly ionbase BY nplug 
SCONNECT shpemit_poly iso_hvnw BY nplug 
SCONNECT shpemit_poly nbase BY nplug 
SCONNECT shpemit_poly nddbase BY nplug 
SCONNECT shpemit_poly nxwell BY nplug 
SCONNECT shpemit_poly phvnwbase BY nplug 
SCONNECT shpemit_poly s_hvnw BY nplug 
SCONNECT shpemit_poly stack_esd_minus BY nplug_nbl 

SCONNECT hvndfs HVNW BY nplug 
SCONNECT hvndfs NBL BY nplug_nbl 
SCONNECT hvndfs NDD BY nplug 
SCONNECT hvndfs SH_N BY nplug 
SCONNECT hvndfs hncol BY nplug 
SCONNECT hvndfs hncol_shp BY nplug 
SCONNECT hvndfs hncol_shp_7t_c1 BY nplug 
SCONNECT hvndfs hncol_shp_7t_c8 BY nplug 
SCONNECT hvndfs hnwbase BY nplug 
SCONNECT hvndfs hnwbase_lat BY nplug 
SCONNECT hvndfs hvndfd BY nplug 
SCONNECT hvndfs hvndfd_ndd BY nplug 
SCONNECT hvndfs hvndfd_shn BY nplug 
SCONNECT hvndfs hvndfd_shn_ndd BY nplug 
SCONNECT hvndfs ionbase BY nplug 
SCONNECT hvndfs iso_hvnw BY nplug 
SCONNECT hvndfs nbase BY nplug 
SCONNECT hvndfs nddbase BY nplug 
SCONNECT hvndfs nxwell BY nplug 
SCONNECT hvndfs phvnwbase BY nplug 
SCONNECT hvndfs s_hvnw BY nplug 
SCONNECT hvndfs stack_esd_minus BY nplug_nbl 

SCONNECT shpemit_7t_e1 HVNW BY nplug 
SCONNECT shpemit_7t_e1 NBL BY nplug_nbl 
SCONNECT shpemit_7t_e1 NDD BY nplug 
SCONNECT shpemit_7t_e1 SH_N BY nplug 
SCONNECT shpemit_7t_e1 hncol BY nplug 
SCONNECT shpemit_7t_e1 hncol_shp BY nplug 
SCONNECT shpemit_7t_e1 hncol_shp_7t_c1 BY nplug 
SCONNECT shpemit_7t_e1 hncol_shp_7t_c8 BY nplug 
SCONNECT shpemit_7t_e1 hnwbase BY nplug 
SCONNECT shpemit_7t_e1 hnwbase_lat BY nplug 
SCONNECT shpemit_7t_e1 hvndfd BY nplug 
SCONNECT shpemit_7t_e1 hvndfd_ndd BY nplug 
SCONNECT shpemit_7t_e1 hvndfd_shn BY nplug 
SCONNECT shpemit_7t_e1 hvndfd_shn_ndd BY nplug 
SCONNECT shpemit_7t_e1 ionbase BY nplug 
SCONNECT shpemit_7t_e1 iso_hvnw BY nplug 
SCONNECT shpemit_7t_e1 nbase BY nplug 
SCONNECT shpemit_7t_e1 nddbase BY nplug 
SCONNECT shpemit_7t_e1 nxwell BY nplug 
SCONNECT shpemit_7t_e1 phvnwbase BY nplug 
SCONNECT shpemit_7t_e1 s_hvnw BY nplug 
SCONNECT shpemit_7t_e1 stack_esd_minus BY nplug_nbl 

SCONNECT shpemit_7t_e8 HVNW BY nplug 
SCONNECT shpemit_7t_e8 NBL BY nplug_nbl 
SCONNECT shpemit_7t_e8 NDD BY nplug 
SCONNECT shpemit_7t_e8 SH_N BY nplug 
SCONNECT shpemit_7t_e8 hncol BY nplug 
SCONNECT shpemit_7t_e8 hncol_shp BY nplug 
SCONNECT shpemit_7t_e8 hncol_shp_7t_c1 BY nplug 
SCONNECT shpemit_7t_e8 hncol_shp_7t_c8 BY nplug 
SCONNECT shpemit_7t_e8 hnwbase BY nplug 
SCONNECT shpemit_7t_e8 hnwbase_lat BY nplug 
SCONNECT shpemit_7t_e8 hvndfd BY nplug 
SCONNECT shpemit_7t_e8 hvndfd_ndd BY nplug 
SCONNECT shpemit_7t_e8 hvndfd_shn BY nplug 
SCONNECT shpemit_7t_e8 hvndfd_shn_ndd BY nplug 
SCONNECT shpemit_7t_e8 ionbase BY nplug 
SCONNECT shpemit_7t_e8 iso_hvnw BY nplug 
SCONNECT shpemit_7t_e8 nbase BY nplug 
SCONNECT shpemit_7t_e8 nddbase BY nplug 
SCONNECT shpemit_7t_e8 nxwell BY nplug 
SCONNECT shpemit_7t_e8 phvnwbase BY nplug 
SCONNECT shpemit_7t_e8 s_hvnw BY nplug 
SCONNECT shpemit_7t_e8 stack_esd_minus BY nplug_nbl 

SCONNECT tndiff_woR HVNW BY nplug 
SCONNECT tndiff_woR NBL BY nplug_nbl 
SCONNECT tndiff_woR NDD BY nplug 
SCONNECT tndiff_woR SH_N BY nplug 
SCONNECT tndiff_woR hncol BY nplug 
SCONNECT tndiff_woR hncol_shp BY nplug 
SCONNECT tndiff_woR hncol_shp_7t_c1 BY nplug 
SCONNECT tndiff_woR hncol_shp_7t_c8 BY nplug 
SCONNECT tndiff_woR hnwbase BY nplug 
SCONNECT tndiff_woR hnwbase_lat BY nplug 
SCONNECT tndiff_woR hvndfd BY nplug 
SCONNECT tndiff_woR hvndfd_ndd BY nplug 
SCONNECT tndiff_woR hvndfd_shn BY nplug 
SCONNECT tndiff_woR hvndfd_shn_ndd BY nplug 
SCONNECT tndiff_woR ionbase BY nplug 
SCONNECT tndiff_woR iso_hvnw BY nplug 
SCONNECT tndiff_woR nbase BY nplug 
SCONNECT tndiff_woR nddbase BY nplug 
SCONNECT tndiff_woR nxwell BY nplug 
SCONNECT tndiff_woR phvnwbase BY nplug 
SCONNECT tndiff_woR s_hvnw BY nplug 
SCONNECT tndiff_woR stack_esd_minus BY nplug_nbl 

SCONNECT schottky_n HVNW BY nplug 
SCONNECT schottky_n NBL BY nplug_nbl 
SCONNECT schottky_n NDD BY nplug 
SCONNECT schottky_n SH_N BY nplug 
SCONNECT schottky_n hncol BY nplug 
SCONNECT schottky_n hncol_shp BY nplug 
SCONNECT schottky_n hncol_shp_7t_c1 BY nplug 
SCONNECT schottky_n hncol_shp_7t_c8 BY nplug 
SCONNECT schottky_n hnwbase BY nplug 
SCONNECT schottky_n hnwbase_lat BY nplug 
SCONNECT schottky_n hvndfd BY nplug 
SCONNECT schottky_n hvndfd_ndd BY nplug 
SCONNECT schottky_n hvndfd_shn BY nplug 
SCONNECT schottky_n hvndfd_shn_ndd BY nplug 
SCONNECT schottky_n ionbase BY nplug 
SCONNECT schottky_n iso_hvnw BY nplug 
SCONNECT schottky_n nbase BY nplug 
SCONNECT schottky_n nddbase BY nplug 
SCONNECT schottky_n nxwell BY nplug 
SCONNECT schottky_n phvnwbase BY nplug 
SCONNECT schottky_n s_hvnw BY nplug 
SCONNECT schottky_n stack_esd_minus BY nplug_nbl 

SCONNECT emit_rpo HVPBi BY pplug_inhvnw 
SCONNECT emit_rpo HVPW BY pplug 
SCONNECT emit_rpo PDD BY pplug_inhvnw 
SCONNECT emit_rpo SH_P BY pplug_inhvnw 
SCONNECT emit_rpo coll BY pplug 
SCONNECT emit_rpo hpbase BY pplug 
SCONNECT emit_rpo hpwcol BY pplug 
SCONNECT emit_rpo hvpdfd BY pplug 
SCONNECT emit_rpo hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT emit_rpo hvpdfd_pdd BY pplug_inhvnw 
SCONNECT emit_rpo hvpdfd_shp BY pplug_inhvnw 
SCONNECT emit_rpo hvpsf_shp BY pplug 
SCONNECT emit_rpo hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT emit_rpo hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT emit_rpo hvpwbase_ga BY pplug_inhvnw 
SCONNECT emit_rpo hvpwbase_gb BY pplug 
SCONNECT emit_rpo iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT emit_rpo n_psub BY n_pplug 
#ENDIF
SCONNECT emit_rpo nddcol BY pplug 
SCONNECT emit_rpo phvnwcol BY pplug 
SCONNECT emit_rpo psub BY pplug 
SCONNECT emit_rpo psub_term BY pplug 
SCONNECT emit_rpo psub_term_ac BY pplug_ac 
SCONNECT emit_rpo psub_term_nw BY pplug 
SCONNECT emit_rpo psub_under_ANWEL BY pplug 
SCONNECT emit_rpo psub_under_DPW_co_imp BY pplug 
SCONNECT emit_rpo pw_iso BY pplug 
SCONNECT emit_rpo shpcol_hvnw BY pplug_inhvnw 

SCONNECT hvpdfs HVPBi BY pplug_inhvnw 
SCONNECT hvpdfs HVPW BY pplug 
SCONNECT hvpdfs PDD BY pplug_inhvnw 
SCONNECT hvpdfs SH_P BY pplug_inhvnw 
SCONNECT hvpdfs coll BY pplug 
SCONNECT hvpdfs hpbase BY pplug 
SCONNECT hvpdfs hpwcol BY pplug 
SCONNECT hvpdfs hvpdfd BY pplug 
SCONNECT hvpdfs hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT hvpdfs hvpdfd_pdd BY pplug_inhvnw 
SCONNECT hvpdfs hvpdfd_shp BY pplug_inhvnw 
SCONNECT hvpdfs hvpsf_shp BY pplug 
SCONNECT hvpdfs hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT hvpdfs hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT hvpdfs hvpwbase_ga BY pplug_inhvnw 
SCONNECT hvpdfs hvpwbase_gb BY pplug 
SCONNECT hvpdfs iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT hvpdfs n_psub BY n_pplug 
#ENDIF
SCONNECT hvpdfs nddcol BY pplug 
SCONNECT hvpdfs phvnwcol BY pplug 
SCONNECT hvpdfs psub BY pplug 
SCONNECT hvpdfs psub_term BY pplug 
SCONNECT hvpdfs psub_term_ac BY pplug_ac 
SCONNECT hvpdfs psub_term_nw BY pplug 
SCONNECT hvpdfs psub_under_ANWEL BY pplug 
SCONNECT hvpdfs psub_under_DPW_co_imp BY pplug 
SCONNECT hvpdfs pw_iso BY pplug 
SCONNECT hvpdfs shpcol_hvnw BY pplug_inhvnw 

SCONNECT ioemit HVPBi BY pplug_inhvnw 
SCONNECT ioemit HVPW BY pplug 
SCONNECT ioemit PDD BY pplug_inhvnw 
SCONNECT ioemit SH_P BY pplug_inhvnw 
SCONNECT ioemit coll BY pplug 
SCONNECT ioemit hpbase BY pplug 
SCONNECT ioemit hpwcol BY pplug 
SCONNECT ioemit hvpdfd BY pplug 
SCONNECT ioemit hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT ioemit hvpdfd_pdd BY pplug_inhvnw 
SCONNECT ioemit hvpdfd_shp BY pplug_inhvnw 
SCONNECT ioemit hvpsf_shp BY pplug 
SCONNECT ioemit hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT ioemit hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT ioemit hvpwbase_ga BY pplug_inhvnw 
SCONNECT ioemit hvpwbase_gb BY pplug 
SCONNECT ioemit iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT ioemit n_psub BY n_pplug 
#ENDIF
SCONNECT ioemit nddcol BY pplug 
SCONNECT ioemit phvnwcol BY pplug 
SCONNECT ioemit psub BY pplug 
SCONNECT ioemit psub_term BY pplug 
SCONNECT ioemit psub_term_ac BY pplug_ac 
SCONNECT ioemit psub_term_nw BY pplug 
SCONNECT ioemit psub_under_ANWEL BY pplug 
SCONNECT ioemit psub_under_DPW_co_imp BY pplug 
SCONNECT ioemit pw_iso BY pplug 
SCONNECT ioemit shpcol_hvnw BY pplug_inhvnw 

SCONNECT ioemit_poly HVPBi BY pplug_inhvnw 
SCONNECT ioemit_poly HVPW BY pplug 
SCONNECT ioemit_poly PDD BY pplug_inhvnw 
SCONNECT ioemit_poly SH_P BY pplug_inhvnw 
SCONNECT ioemit_poly coll BY pplug 
SCONNECT ioemit_poly hpbase BY pplug 
SCONNECT ioemit_poly hpwcol BY pplug 
SCONNECT ioemit_poly hvpdfd BY pplug 
SCONNECT ioemit_poly hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT ioemit_poly hvpdfd_pdd BY pplug_inhvnw 
SCONNECT ioemit_poly hvpdfd_shp BY pplug_inhvnw 
SCONNECT ioemit_poly hvpsf_shp BY pplug 
SCONNECT ioemit_poly hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT ioemit_poly hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT ioemit_poly hvpwbase_ga BY pplug_inhvnw 
SCONNECT ioemit_poly hvpwbase_gb BY pplug 
SCONNECT ioemit_poly iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT ioemit_poly n_psub BY n_pplug 
#ENDIF
SCONNECT ioemit_poly nddcol BY pplug 
SCONNECT ioemit_poly phvnwcol BY pplug 
SCONNECT ioemit_poly psub BY pplug 
SCONNECT ioemit_poly psub_term BY pplug 
SCONNECT ioemit_poly psub_term_ac BY pplug_ac 
SCONNECT ioemit_poly psub_term_nw BY pplug 
SCONNECT ioemit_poly psub_under_ANWEL BY pplug 
SCONNECT ioemit_poly psub_under_DPW_co_imp BY pplug 
SCONNECT ioemit_poly pw_iso BY pplug 
SCONNECT ioemit_poly shpcol_hvnw BY pplug_inhvnw 

SCONNECT nddemit HVPBi BY pplug_inhvnw 
SCONNECT nddemit HVPW BY pplug 
SCONNECT nddemit PDD BY pplug_inhvnw 
SCONNECT nddemit SH_P BY pplug_inhvnw 
SCONNECT nddemit coll BY pplug 
SCONNECT nddemit hpbase BY pplug 
SCONNECT nddemit hpwcol BY pplug 
SCONNECT nddemit hvpdfd BY pplug 
SCONNECT nddemit hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT nddemit hvpdfd_pdd BY pplug_inhvnw 
SCONNECT nddemit hvpdfd_shp BY pplug_inhvnw 
SCONNECT nddemit hvpsf_shp BY pplug 
SCONNECT nddemit hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT nddemit hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT nddemit hvpwbase_ga BY pplug_inhvnw 
SCONNECT nddemit hvpwbase_gb BY pplug 
SCONNECT nddemit iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT nddemit n_psub BY n_pplug 
#ENDIF
SCONNECT nddemit nddcol BY pplug 
SCONNECT nddemit phvnwcol BY pplug 
SCONNECT nddemit psub BY pplug 
SCONNECT nddemit psub_term BY pplug 
SCONNECT nddemit psub_term_ac BY pplug_ac 
SCONNECT nddemit psub_term_nw BY pplug 
SCONNECT nddemit psub_under_ANWEL BY pplug 
SCONNECT nddemit psub_under_DPW_co_imp BY pplug 
SCONNECT nddemit pw_iso BY pplug 
SCONNECT nddemit shpcol_hvnw BY pplug_inhvnw 

SCONNECT phvnwemit HVPBi BY pplug_inhvnw 
SCONNECT phvnwemit HVPW BY pplug 
SCONNECT phvnwemit PDD BY pplug_inhvnw 
SCONNECT phvnwemit SH_P BY pplug_inhvnw 
SCONNECT phvnwemit coll BY pplug 
SCONNECT phvnwemit hpbase BY pplug 
SCONNECT phvnwemit hpwcol BY pplug 
SCONNECT phvnwemit hvpdfd BY pplug 
SCONNECT phvnwemit hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT phvnwemit hvpdfd_pdd BY pplug_inhvnw 
SCONNECT phvnwemit hvpdfd_shp BY pplug_inhvnw 
SCONNECT phvnwemit hvpsf_shp BY pplug 
SCONNECT phvnwemit hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT phvnwemit hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT phvnwemit hvpwbase_ga BY pplug_inhvnw 
SCONNECT phvnwemit hvpwbase_gb BY pplug 
SCONNECT phvnwemit iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT phvnwemit n_psub BY n_pplug 
#ENDIF
SCONNECT phvnwemit nddcol BY pplug 
SCONNECT phvnwemit phvnwcol BY pplug 
SCONNECT phvnwemit psub BY pplug 
SCONNECT phvnwemit psub_term BY pplug 
SCONNECT phvnwemit psub_term_ac BY pplug_ac 
SCONNECT phvnwemit psub_term_nw BY pplug 
SCONNECT phvnwemit psub_under_ANWEL BY pplug 
SCONNECT phvnwemit psub_under_DPW_co_imp BY pplug 
SCONNECT phvnwemit pw_iso BY pplug 
SCONNECT phvnwemit shpcol_hvnw BY pplug_inhvnw 

SCONNECT stack_esd_plus HVPBi BY pplug_inhvnw 
SCONNECT stack_esd_plus HVPW BY pplug 
SCONNECT stack_esd_plus PDD BY pplug_inhvnw 
SCONNECT stack_esd_plus SH_P BY pplug_inhvnw 
SCONNECT stack_esd_plus coll BY pplug 
SCONNECT stack_esd_plus hpbase BY pplug 
SCONNECT stack_esd_plus hpwcol BY pplug 
SCONNECT stack_esd_plus hvpdfd BY pplug 
SCONNECT stack_esd_plus hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT stack_esd_plus hvpdfd_pdd BY pplug_inhvnw 
SCONNECT stack_esd_plus hvpdfd_shp BY pplug_inhvnw 
SCONNECT stack_esd_plus hvpsf_shp BY pplug 
SCONNECT stack_esd_plus hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT stack_esd_plus hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT stack_esd_plus hvpwbase_ga BY pplug_inhvnw 
SCONNECT stack_esd_plus hvpwbase_gb BY pplug 
SCONNECT stack_esd_plus iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT stack_esd_plus n_psub BY n_pplug 
#ENDIF
SCONNECT stack_esd_plus nddcol BY pplug 
SCONNECT stack_esd_plus phvnwcol BY pplug 
SCONNECT stack_esd_plus psub BY pplug 
SCONNECT stack_esd_plus psub_term BY pplug 
SCONNECT stack_esd_plus psub_term_ac BY pplug_ac 
SCONNECT stack_esd_plus psub_term_nw BY pplug 
SCONNECT stack_esd_plus psub_under_ANWEL BY pplug 
SCONNECT stack_esd_plus psub_under_DPW_co_imp BY pplug 
SCONNECT stack_esd_plus pw_iso BY pplug 
SCONNECT stack_esd_plus shpcol_hvnw BY pplug_inhvnw 

SCONNECT tpdiff_woR HVPBi BY pplug_inhvnw 
SCONNECT tpdiff_woR HVPW BY pplug 
SCONNECT tpdiff_woR PDD BY pplug_inhvnw 
SCONNECT tpdiff_woR SH_P BY pplug_inhvnw 
SCONNECT tpdiff_woR coll BY pplug 
SCONNECT tpdiff_woR hpbase BY pplug 
SCONNECT tpdiff_woR hpwcol BY pplug 
SCONNECT tpdiff_woR hvpdfd BY pplug 
SCONNECT tpdiff_woR hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT tpdiff_woR hvpdfd_pdd BY pplug_inhvnw 
SCONNECT tpdiff_woR hvpdfd_shp BY pplug_inhvnw 
SCONNECT tpdiff_woR hvpsf_shp BY pplug 
SCONNECT tpdiff_woR hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT tpdiff_woR hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT tpdiff_woR hvpwbase_ga BY pplug_inhvnw 
SCONNECT tpdiff_woR hvpwbase_gb BY pplug 
SCONNECT tpdiff_woR iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT tpdiff_woR n_psub BY n_pplug 
#ENDIF
SCONNECT tpdiff_woR nddcol BY pplug 
SCONNECT tpdiff_woR phvnwcol BY pplug 
SCONNECT tpdiff_woR psub BY pplug 
SCONNECT tpdiff_woR psub_term BY pplug 
SCONNECT tpdiff_woR psub_term_ac BY pplug_ac 
SCONNECT tpdiff_woR psub_term_nw BY pplug 
SCONNECT tpdiff_woR psub_under_ANWEL BY pplug 
SCONNECT tpdiff_woR psub_under_DPW_co_imp BY pplug 
SCONNECT tpdiff_woR pw_iso BY pplug 
SCONNECT tpdiff_woR shpcol_hvnw BY pplug_inhvnw 

SCONNECT schottky_p HVPBi BY pplug_inhvnw 
SCONNECT schottky_p HVPW BY pplug 
SCONNECT schottky_p PDD BY pplug_inhvnw 
SCONNECT schottky_p SH_P BY pplug_inhvnw 
SCONNECT schottky_p coll BY pplug 
SCONNECT schottky_p hpbase BY pplug 
SCONNECT schottky_p hpwcol BY pplug 
SCONNECT schottky_p hvpdfd BY pplug 
SCONNECT schottky_p hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT schottky_p hvpdfd_pdd BY pplug_inhvnw 
SCONNECT schottky_p hvpdfd_shp BY pplug_inhvnw 
SCONNECT schottky_p hvpsf_shp BY pplug 
SCONNECT schottky_p hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT schottky_p hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT schottky_p hvpwbase_ga BY pplug_inhvnw 
SCONNECT schottky_p hvpwbase_gb BY pplug 
SCONNECT schottky_p iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT schottky_p n_psub BY n_pplug 
#ENDIF
SCONNECT schottky_p nddcol BY pplug 
SCONNECT schottky_p phvnwcol BY pplug 
SCONNECT schottky_p psub BY pplug 
SCONNECT schottky_p psub_term BY pplug 
SCONNECT schottky_p psub_term_ac BY pplug_ac 
SCONNECT schottky_p psub_term_nw BY pplug 
SCONNECT schottky_p psub_under_ANWEL BY pplug 
SCONNECT schottky_p psub_under_DPW_co_imp BY pplug 
SCONNECT schottky_p pw_iso BY pplug 
SCONNECT schottky_p shpcol_hvnw BY pplug_inhvnw 

SCONNECT sbd_hv_dio_gen2_dio HVPBi BY pplug_inhvnw 
SCONNECT sbd_hv_dio_gen2_dio HVPW BY pplug 
SCONNECT sbd_hv_dio_gen2_dio PDD BY pplug_inhvnw 
SCONNECT sbd_hv_dio_gen2_dio SH_P BY pplug_inhvnw 
SCONNECT sbd_hv_dio_gen2_dio coll BY pplug 
SCONNECT sbd_hv_dio_gen2_dio hpbase BY pplug 
SCONNECT sbd_hv_dio_gen2_dio hpwcol BY pplug 
SCONNECT sbd_hv_dio_gen2_dio hvpdfd BY pplug 
SCONNECT sbd_hv_dio_gen2_dio hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT sbd_hv_dio_gen2_dio hvpdfd_pdd BY pplug_inhvnw 
SCONNECT sbd_hv_dio_gen2_dio hvpdfd_shp BY pplug_inhvnw 
SCONNECT sbd_hv_dio_gen2_dio hvpsf_shp BY pplug 
SCONNECT sbd_hv_dio_gen2_dio hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT sbd_hv_dio_gen2_dio hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT sbd_hv_dio_gen2_dio hvpwbase_ga BY pplug_inhvnw 
SCONNECT sbd_hv_dio_gen2_dio hvpwbase_gb BY pplug 
SCONNECT sbd_hv_dio_gen2_dio iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT sbd_hv_dio_gen2_dio n_psub BY n_pplug 
#ENDIF
SCONNECT sbd_hv_dio_gen2_dio nddcol BY pplug 
SCONNECT sbd_hv_dio_gen2_dio phvnwcol BY pplug 
SCONNECT sbd_hv_dio_gen2_dio psub BY pplug 
SCONNECT sbd_hv_dio_gen2_dio psub_term BY pplug 
SCONNECT sbd_hv_dio_gen2_dio psub_term_ac BY pplug_ac 
SCONNECT sbd_hv_dio_gen2_dio psub_term_nw BY pplug 
SCONNECT sbd_hv_dio_gen2_dio psub_under_ANWEL BY pplug 
SCONNECT sbd_hv_dio_gen2_dio psub_under_DPW_co_imp BY pplug 
SCONNECT sbd_hv_dio_gen2_dio pw_iso BY pplug 
SCONNECT sbd_hv_dio_gen2_dio shpcol_hvnw BY pplug_inhvnw 

SCONNECT tpdiff_s HVPBi BY pplug_inhvnw 
SCONNECT tpdiff_s HVPW BY pplug 
SCONNECT tpdiff_s PDD BY pplug_inhvnw 
SCONNECT tpdiff_s SH_P BY pplug_inhvnw 
SCONNECT tpdiff_s coll BY pplug 
SCONNECT tpdiff_s hpbase BY pplug 
SCONNECT tpdiff_s hpwcol BY pplug 
SCONNECT tpdiff_s hvpdfd BY pplug 
SCONNECT tpdiff_s hvpdfd_hvpb BY pplug_inhvnw 
SCONNECT tpdiff_s hvpdfd_pdd BY pplug_inhvnw 
SCONNECT tpdiff_s hvpdfd_shp BY pplug_inhvnw 
SCONNECT tpdiff_s hvpsf_shp BY pplug 
SCONNECT tpdiff_s hvpwbase_7t_ga_b1 BY pplug_inhvnw 
SCONNECT tpdiff_s hvpwbase_7t_ga_b8 BY pplug_inhvnw 
SCONNECT tpdiff_s hvpwbase_ga BY pplug_inhvnw 
SCONNECT tpdiff_s hvpwbase_gb BY pplug 
SCONNECT tpdiff_s iocoll BY pplug 
#IFNDEF NW_RING
  SCONNECT tpdiff_s n_psub BY n_pplug 
#ENDIF
SCONNECT tpdiff_s nddcol BY pplug 
SCONNECT tpdiff_s phvnwcol BY pplug 
SCONNECT tpdiff_s psub BY pplug 
SCONNECT tpdiff_s psub_term BY pplug 
SCONNECT tpdiff_s psub_term_ac BY pplug_ac 
SCONNECT tpdiff_s psub_term_nw BY pplug 
SCONNECT tpdiff_s psub_under_ANWEL BY pplug 
SCONNECT tpdiff_s psub_under_DPW_co_imp BY pplug 
SCONNECT tpdiff_s pw_iso BY pplug 
SCONNECT tpdiff_s shpcol_hvnw BY pplug_inhvnw 

#ENDIF
//#############################################
//# FORM DEVICE                               #
//#############################################

#IFDEF RC_DECK
ngate_aux = (SIZE ngate BY WPED) AND c_nmcore
DEVICE MN(N) ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <ngate_aux> netlist model nch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2
   L = area(ngate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate,ngate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate,ngate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bngate_aux = (SIZE bngate BY WPED) AND c_nmIO
DEVICE MN(ND) bngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bngate_aux> netlist model nch_5 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate, tndiff ) + perimeter_inside(bngate, tndiff)) / 2
   L = area(bngate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bngate,bngate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bngate,bngate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

DEVICE MN(nanch5_biso) bnlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> netlist model nanch5_biso [
  property sa,sb,W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bnlgate, tndiff ) + perimeter_inside(bnlgate, tndiff)) / 2
   L = area(bnlgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nanch5_biso) bnlgate_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> netlist model nanch5_biso_mac netlist element "X" [
  property sa,sb,W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bnlgate_mis, tndiff ) + perimeter_inside(bnlgate_mis, tndiff)) / 2
   L = area(bnlgate_mis) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nanch5_biso_wo) bnlgate_wo poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> netlist model nanch5_biso_wo [
  property sa,sb,W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bnlgate_wo, tndiff ) + perimeter_inside(bnlgate_wo, tndiff)) / 2
   L = area(bnlgate_wo) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nanch5_biso_wo) bnlgate_wo_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> netlist model nanch5_biso_wo_mac netlist element "X" [
  property sa,sb,W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bnlgate_wo_mis, tndiff ) + perimeter_inside(bnlgate_wo_mis, tndiff)) / 2
   L = area(bnlgate_wo_mis) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nanch_biso) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> netlist model nanch_biso [
  property sa,sb,W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L = area(nlgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nanch_biso) nlgate_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> netlist model nanch_biso_mac netlist element "X" [
  property sa,sb,W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(nlgate_mis, tndiff ) + perimeter_inside(nlgate_mis, tndiff)) / 2
   L = area(nlgate_mis) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nch5_lvt_dd) bngate_dd poly(G) tndiff(S) tndiff(D) psub(B) <nthin> netlist model nch5_lvt_dd [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate_dd, tndiff ) + perimeter_inside(bngate_dd, tndiff)) / 2
   L = area(bngate_dd) / W
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nch5_lvt_dd) bngate_dd_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> netlist model nch5_lvt_dd_mac netlist element "X" [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate_dd_mis, tndiff ) + perimeter_inside(bngate_dd_mis, tndiff)) / 2
   L = area(bngate_dd_mis) / W
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nch_5_fgd_mac) bngate_fgd poly(G) tndiff(S) tndiff(D) psub(B) <mdiff> netlist model nch_5_fgd_mac netlist element "X" [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate_fgd, tndiff ) + perimeter_inside(bngate_fgd, tndiff)) / 2
   L = area(bngate_fgd) / W
   PI_S_OD = perimeter_inside(S,mdiff)
   PI_D_OD = perimeter_inside(D,mdiff)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

bngate_mis_aux = (SIZE bngate_mis BY WPED) AND c_nmIO
DEVICE MN(ND) bngate_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bngate_mis_aux> netlist model nch_5_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate_mis, tndiff ) + perimeter_inside(bngate_mis, tndiff)) / 2
   L = area(bngate_mis) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bngate_mis,bngate_mis_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bngate_mis,bngate_mis_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

DEVICE MN(nch_5_ngd_mac) bngate_ngd poly(G) tndiff(S) tndiff(D) psub(B) <nthin> netlist model nch_5_ngd_mac netlist element "X" [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate_ngd, tndiff ) + perimeter_inside(bngate_ngd, tndiff)) / 2
   L = area(bngate_ngd) / W
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

bngate_dep_aux = (SIZE bngate_dep BY WPED) AND c_nmIO
DEVICE MN(nch_dep5) bngate_dep poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bngate_dep_aux> netlist model nch_dep5 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate_dep, tndiff ) + perimeter_inside(bngate_dep, tndiff)) / 2
   L = area(bngate_dep) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bngate_dep,bngate_dep_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bngate_dep,bngate_dep_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bngate_dep_mis_aux = (SIZE bngate_dep_mis BY WPED) AND c_nmIO
DEVICE MN(nch_dep5) bngate_dep_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <bngate_dep_mis_aux> netlist model nch_dep5_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(bngate_dep_mis, tndiff ) + perimeter_inside(bngate_dep_mis, tndiff)) / 2
   L = area(bngate_dep_mis) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bngate_dep_mis,bngate_dep_mis_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bngate_dep_mis,bngate_dep_mis_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_mis_aux = (SIZE ngate_mis BY WPED) AND c_nmcore
DEVICE MN(N) ngate_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <ngate_mis_aux> netlist model nch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_mis, tndiff ) + perimeter_inside(ngate_mis, tndiff)) / 2
   L = area(ngate_mis) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_mis,ngate_mis_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_mis,ngate_mis_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_aux = (SIZE pgate BY WPED) AND c_pmcore
DEVICE MP(P) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_aux> netlist model pch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2
   L = area(pgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate,pgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate,pgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

bpgate_aux = (SIZE bpgate BY WPED) AND c_pmIO
DEVICE MP(PD) bpgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <bpgate_aux> netlist model pch_5 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(bpgate, tpdiff ) + perimeter_inside(bpgate, tpdiff)) / 2
   L = area(bpgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bpgate,bpgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bpgate,bpgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

DEVICE MP(pch5_lvt_dd) bpgate_dd poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pch5_lvt_dd [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bpgate_dd, tpdiff ) + perimeter_inside(bpgate_dd, tpdiff)) / 2
   L = area(bpgate_dd) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pch5_lvt_dd) bpgate_dd_mis poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pch5_lvt_dd_mac netlist element "X" [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(bpgate_dd_mis, tpdiff ) + perimeter_inside(bpgate_dd_mis, tpdiff)) / 2
   L = area(bpgate_dd_mis) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

bpgate_mis_aux = (SIZE bpgate_mis BY WPED) AND c_pmIO
DEVICE MP(PD) bpgate_mis poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <bpgate_mis_aux> netlist model pch_5_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(bpgate_mis, tpdiff ) + perimeter_inside(bpgate_mis, tpdiff)) / 2
   L = area(bpgate_mis) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(bpgate_mis,bpgate_mis_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(bpgate_mis,bpgate_mis_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_mis_aux = (SIZE pgate_mis BY WPED) AND c_pmcore
DEVICE MP(P) pgate_mis poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_mis_aux> netlist model pch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_mis, tpdiff ) + perimeter_inside(pgate_mis, tpdiff)) / 2
   L = area(pgate_mis) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_mis,pgate_mis_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_mis,pgate_mis_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

#ELSE

#IFDEF extract_as_ad
DEVICE MN(N) ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2
   L=area(ngate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(ND) bngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate, tndiff ) + perimeter_inside(bngate, tndiff)) / 2
   L=area(bngate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nanch5_biso) bnlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bnlgate, tndiff ) + perimeter_inside(bnlgate, tndiff)) / 2
   L=area(bnlgate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nanch5_biso) bnlgate_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bnlgate_mis, tndiff ) + perimeter_inside(bnlgate_mis, tndiff)) / 2
   L=area(bnlgate_mis) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nanch5_biso_wo) bnlgate_wo poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bnlgate_wo, tndiff ) + perimeter_inside(bnlgate_wo, tndiff)) / 2
   L=area(bnlgate_wo) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nanch5_biso_wo) bnlgate_wo_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bnlgate_wo_mis, tndiff ) + perimeter_inside(bnlgate_wo_mis, tndiff)) / 2
   L=area(bnlgate_wo_mis) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nanch_biso) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L=area(nlgate) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nanch_biso) nlgate_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlgate_mis, tndiff ) + perimeter_inside(nlgate_mis, tndiff)) / 2
   L=area(nlgate_mis) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch5_lvt_dd) bngate_dd poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate_dd, tndiff ) + perimeter_inside(bngate_dd, tndiff)) / 2
   L=area(bngate_dd) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch5_lvt_dd) bngate_dd_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate_dd_mis, tndiff ) + perimeter_inside(bngate_dd_mis, tndiff)) / 2
   L=area(bngate_dd_mis) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_5_fgd_mac) bngate_fgd poly(G) tndiff(S) tndiff(D) psub(B) <mdiff> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate_fgd, tndiff ) + perimeter_inside(bngate_fgd, tndiff)) / 2
   L=area(bngate_fgd) / W
  PI_S_OD = perimeter_inside(S,mdiff)
  PI_D_OD = perimeter_inside(D,mdiff)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,mdiff)
  AD = area(D) * W /perimeter_inside(D,mdiff)
  }
  ]
DEVICE MN(ND) bngate_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate_mis, tndiff ) + perimeter_inside(bngate_mis, tndiff)) / 2
   L=area(bngate_mis) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_5_ngd_mac) bngate_ngd poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate_ngd, tndiff ) + perimeter_inside(bngate_ngd, tndiff)) / 2
   L=area(bngate_ngd) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_dep5) bngate_dep poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate_dep, tndiff ) + perimeter_inside(bngate_dep, tndiff)) / 2
   L=area(bngate_dep) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_dep5) bngate_dep_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bngate_dep_mis, tndiff ) + perimeter_inside(bngate_dep_mis, tndiff)) / 2
   L=area(bngate_dep_mis) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(N) ngate_mis poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_mis, tndiff ) + perimeter_inside(ngate_mis, tndiff)) / 2
   L=area(ngate_mis) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MP(P) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2 
   L=area(pgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(PD) bpgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bpgate, tpdiff ) + perimeter_inside(bpgate, tpdiff)) / 2 
   L=area(bpgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch5_lvt_dd) bpgate_dd poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bpgate_dd, tpdiff ) + perimeter_inside(bpgate_dd, tpdiff)) / 2 
   L=area(bpgate_dd) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch5_lvt_dd) bpgate_dd_mis poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bpgate_dd_mis, tpdiff ) + perimeter_inside(bpgate_dd_mis, tpdiff)) / 2 
   L=area(bpgate_dd_mis) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(PD) bpgate_mis poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(bpgate_mis, tpdiff ) + perimeter_inside(bpgate_mis, tpdiff)) / 2 
   L=area(bpgate_mis) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(P) pgate_mis poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_mis, tpdiff ) + perimeter_inside(pgate_mis, tpdiff)) / 2 
   L=area(pgate_mis) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]


#ELSE
DEVICE MN(N) ngate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2 
   L=area(ngate) / W
]
DEVICE MN(ND) bngate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate, tndiff ) + perimeter_inside(bngate, tndiff)) / 2 
   L=area(bngate) / W
]
DEVICE MN(nanch5_biso) bnlgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bnlgate, tndiff ) + perimeter_inside(bnlgate, tndiff)) / 2 
   L=area(bnlgate) / W
]
DEVICE MN(nanch5_biso) bnlgate_mis poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bnlgate_mis, tndiff ) + perimeter_inside(bnlgate_mis, tndiff)) / 2 
   L=area(bnlgate_mis) / W
]
DEVICE MN(nanch5_biso_wo) bnlgate_wo poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bnlgate_wo, tndiff ) + perimeter_inside(bnlgate_wo, tndiff)) / 2 
   L=area(bnlgate_wo) / W
]
DEVICE MN(nanch5_biso_wo) bnlgate_wo_mis poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bnlgate_wo_mis, tndiff ) + perimeter_inside(bnlgate_wo_mis, tndiff)) / 2 
   L=area(bnlgate_wo_mis) / W
]
DEVICE MN(nanch_biso) nlgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2 
   L=area(nlgate) / W
]
DEVICE MN(nanch_biso) nlgate_mis poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlgate_mis, tndiff ) + perimeter_inside(nlgate_mis, tndiff)) / 2 
   L=area(nlgate_mis) / W
]
DEVICE MN(nch5_lvt_dd) bngate_dd poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate_dd, tndiff ) + perimeter_inside(bngate_dd, tndiff)) / 2 
   L=area(bngate_dd) / W
]
DEVICE MN(nch5_lvt_dd) bngate_dd_mis poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate_dd_mis, tndiff ) + perimeter_inside(bngate_dd_mis, tndiff)) / 2 
   L=area(bngate_dd_mis) / W
]
DEVICE MN(nch_5_fgd_mac) bngate_fgd poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate_fgd, tndiff ) + perimeter_inside(bngate_fgd, tndiff)) / 2 
   L=area(bngate_fgd) / W
]
DEVICE MN(ND) bngate_mis poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate_mis, tndiff ) + perimeter_inside(bngate_mis, tndiff)) / 2 
   L=area(bngate_mis) / W
]
DEVICE MN(nch_5_ngd_mac) bngate_ngd poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate_ngd, tndiff ) + perimeter_inside(bngate_ngd, tndiff)) / 2 
   L=area(bngate_ngd) / W
]
DEVICE MN(nch_dep5) bngate_dep poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate_dep, tndiff ) + perimeter_inside(bngate_dep, tndiff)) / 2 
   L=area(bngate_dep) / W
]
DEVICE MN(nch_dep5) bngate_dep_mis poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(bngate_dep_mis, tndiff ) + perimeter_inside(bngate_dep_mis, tndiff)) / 2 
   L=area(bngate_dep_mis) / W
]
DEVICE MN(N) ngate_mis poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_mis, tndiff ) + perimeter_inside(ngate_mis, tndiff)) / 2 
   L=area(ngate_mis) / W
]
DEVICE MP(P) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2 
   L=area(pgate) / W
]
DEVICE MP(PD) bpgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(bpgate, tpdiff ) + perimeter_inside(bpgate, tpdiff)) / 2 
   L=area(bpgate) / W
]
DEVICE MP(pch5_lvt_dd) bpgate_dd poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(bpgate_dd, tpdiff ) + perimeter_inside(bpgate_dd, tpdiff)) / 2 
   L=area(bpgate_dd) / W
]
DEVICE MP(pch5_lvt_dd) bpgate_dd_mis poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(bpgate_dd_mis, tpdiff ) + perimeter_inside(bpgate_dd_mis, tpdiff)) / 2 
   L=area(bpgate_dd_mis) / W
]
DEVICE MP(PD) bpgate_mis poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(bpgate_mis, tpdiff ) + perimeter_inside(bpgate_mis, tpdiff)) / 2 
   L=area(bpgate_mis) / W
]
DEVICE MP(P) pgate_mis poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_mis, tpdiff ) + perimeter_inside(pgate_mis, tpdiff)) / 2 
   L=area(pgate_mis) / W
]


#ENDIF

#ENDIF


#IFNDEF RC_DECK
TRACE PROPERTY MN(N) L L 0
TRACE PROPERTY MN(N) W W 0
TRACE PROPERTY MN(ND) L L 0
TRACE PROPERTY MN(ND) W W 0
TRACE PROPERTY MN(nanch5_biso) L L 0
TRACE PROPERTY MN(nanch5_biso) W W 0
TRACE PROPERTY MN(nanch5_biso_wo) L L 0
TRACE PROPERTY MN(nanch5_biso_wo) W W 0
TRACE PROPERTY MN(nanch_biso) L L 0
TRACE PROPERTY MN(nanch_biso) W W 0
TRACE PROPERTY MN(nch5_lvt_dd) L L 0
TRACE PROPERTY MN(nch5_lvt_dd) W W 0
TRACE PROPERTY MN(nch_5_fgd_mac) L L 0
TRACE PROPERTY MN(nch_5_fgd_mac) W W 0
TRACE PROPERTY MN(nch_5_ngd_mac) L L 0
TRACE PROPERTY MN(nch_5_ngd_mac) W W 0
TRACE PROPERTY MN(nch_dep5) L L 0
TRACE PROPERTY MN(nch_dep5) W W 0
TRACE PROPERTY MP(P) L L 0
TRACE PROPERTY MP(P) W W 0
TRACE PROPERTY MP(PD) L L 0
TRACE PROPERTY MP(PD) W W 0
TRACE PROPERTY MP(pch5_lvt_dd) L L 0
TRACE PROPERTY MP(pch5_lvt_dd) W W 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp10_5_poly) ioemit10_poly iocoll ionbase ioemit_poly netlist model pnp10_5_poly
#ELSE
  DEVICE Q(pnp10_5_poly) ioemit10_poly iocoll ionbase ioemit_poly [
		property A
		A = area(ioemit_poly)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp10_5_poly) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp10_5_rpo) ioemit10_rpo iocoll ionbase ioemit netlist model pnp10_5_rpo
#ELSE
  DEVICE Q(pnp10_5_rpo) ioemit10_rpo iocoll ionbase ioemit [
		property A
		A = area(ioemit)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp10_5_rpo) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp10_rpo) emit10_rpo coll nbase emit_rpo netlist model pnp10_rpo
#ELSE
  DEVICE Q(pnp10_rpo) emit10_rpo coll nbase emit_rpo [
		property A
		A = area(emit_rpo)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp10_rpo) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp2_5_poly) ioemit2_poly iocoll ionbase ioemit_poly netlist model pnp2_5_poly
#ELSE
  DEVICE Q(pnp2_5_poly) ioemit2_poly iocoll ionbase ioemit_poly [
		property A
		A = area(ioemit_poly)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp2_5_poly) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp2_rpo) emit2_rpo coll nbase emit_rpo netlist model pnp2_rpo
#ELSE
  DEVICE Q(pnp2_rpo) emit2_rpo coll nbase emit_rpo [
		property A
		A = area(emit_rpo)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp2_rpo) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp5_5_poly) ioemit5_poly iocoll ionbase ioemit_poly netlist model pnp5_5_poly
#ELSE
  DEVICE Q(pnp5_5_poly) ioemit5_poly iocoll ionbase ioemit_poly [
		property A
		A = area(ioemit_poly)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp5_5_poly) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp5_rpo) emit5_rpo coll nbase emit_rpo netlist model pnp5_rpo
#ELSE
  DEVICE Q(pnp5_rpo) emit5_rpo coll nbase emit_rpo [
		property A
		A = area(emit_rpo)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp5_rpo) A A 0
#ENDIF

DEVICE D(D1) pdio_od2 tpdiff nxwell netlist model pdio_5
  TRACE PROPERTY D(D1) A A 0
DEVICE D(D2) ndio_od2 psub tndiff netlist model ndio_5
  TRACE PROPERTY D(D2) A A 0
DEVICE D(D3) nwdio_od2 psub nxwell netlist model nwdio_5
  TRACE PROPERTY D(D3) A A 0
DEVICE D(DN) ndio psub tndiff netlist model ndio
  TRACE PROPERTY D(DN) A A 0
DEVICE D(DP) pdio tpdiff nxwell netlist model pdio
  TRACE PROPERTY D(DP) A A 0
DEVICE D(DW) nwdio psub nxwell netlist model nwdio
  TRACE PROPERTY D(DW) A A 0
DEVICE D(nhvpw_dio_v2_gb) nhvpw_dio_gb_reg psub_term_ac tndiff netlist model nhvpw_dio_v2_gb
  TRACE PROPERTY D(nhvpw_dio_v2_gb) A A 0
DEVICE D(npdd_dio_v2_ga) npdddio_ga psub_term_ac tndiff netlist model npdd_dio_v2_ga
  TRACE PROPERTY D(npdd_dio_v2_ga) A A 0
DEVICE D(shnnblpsubshp_dio_ga) shnnblpsubshp_dio_ga_reg psub_term_ac NBL netlist model shnnblpsubshp_dio_ga
  TRACE PROPERTY D(shnnblpsubshp_dio_ga) A A 0
DEVICE D(shnnblpsubshp_dio_gb) shnnblpsubshp_dio_gb_reg psub_term_ac NBL netlist model shnnblpsubshp_dio_gb
  TRACE PROPERTY D(shnnblpsubshp_dio_gb) A A 0
DEVICE D(shnpsubshp_dio_ga) shnpsubshp_dio_ga_reg psub_term_ac SH_N netlist model shnpsubshp_dio_ga
  TRACE PROPERTY D(shnpsubshp_dio_ga) A A 0
#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(M1) mt1res metal1 metal1 netlist model rm1 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt1res,metal1)/2
      A = area(mt1res)
      l = A/w
      R = RVM1*l/w
    ]
    //TRACE PROPERTY R(M1) w w 0
    //TRACE PROPERTY R(M1) l l 0
    TRACE PROPERTY R(M1) R R 2
  #ELSE
    DEVICE R(M1) mt1res metal1 metal1 [
      property R
      w = perimeter_coincide(mt1res,metal1)/2
      A = area(mt1res)
      l = A/w
      R = RVM1*l/w
    ]
    TRACE PROPERTY R(M1) R R 2
  #ENDIF
#ELSE
  DEVICE R(M1) mt1res metal1 metal1 [RVM1]
    TRACE PROPERTY R(M1) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(M2) mt2res metal2 metal2 netlist model rm2 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt2res,metal2)/2
      A = area(mt2res)
      l = A/w
      R = RVM2*l/w
    ]
    //TRACE PROPERTY R(M2) w w 0
    //TRACE PROPERTY R(M2) l l 0
    TRACE PROPERTY R(M2) R R 2
  #ELSE
    DEVICE R(M2) mt2res metal2 metal2 [
      property R
      w = perimeter_coincide(mt2res,metal2)/2
      A = area(mt2res)
      l = A/w
      R = RVM2*l/w
    ]
    TRACE PROPERTY R(M2) R R 2
  #ENDIF
#ELSE
  DEVICE R(M2) mt2res metal2 metal2 [RVM2]
    TRACE PROPERTY R(M2) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(M3) mt3res metal3 metal3 netlist model rm3 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt3res,metal3)/2
      A = area(mt3res)
      l = A/w
      R = RVM3*l/w
    ]
    //TRACE PROPERTY R(M3) w w 0
    //TRACE PROPERTY R(M3) l l 0
    TRACE PROPERTY R(M3) R R 2
  #ELSE
    DEVICE R(M3) mt3res metal3 metal3 [
      property R
      w = perimeter_coincide(mt3res,metal3)/2
      A = area(mt3res)
      l = A/w
      R = RVM3*l/w
    ]
    TRACE PROPERTY R(M3) R R 2
  #ENDIF
#ELSE
  DEVICE R(M3) mt3res metal3 metal3 [RVM3]
    TRACE PROPERTY R(M3) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(ND) nrdop tndiff tndiff netlist model rnodrpo netlist element "X" [
      property w,l,R
      w = perimeter_coincide(nrdop,tndiff)/2
      A = area(nrdop)
      l = A/w
      R = RVND*l/w
    ]
    //TRACE PROPERTY R(ND) w w 0
    //TRACE PROPERTY R(ND) l l 0
    TRACE PROPERTY R(ND) R R 2
  #ELSE
    DEVICE R(ND) nrdop tndiff tndiff [
      property R
      w = perimeter_coincide(nrdop,tndiff)/2
      A = area(nrdop)
      l = A/w
      R = RVND*l/w
    ]
    TRACE PROPERTY R(ND) R R 2
  #ENDIF
#ELSE
  DEVICE R(ND) nrdop tndiff tndiff [RVND]
    TRACE PROPERTY R(ND) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NI) rnodip tndiff tndiff netlist model rnod netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rnodip,tndiff)/2
      A = area(rnodip)
      l = A/w
      R = RVNI1*l/w
    ]
    //TRACE PROPERTY R(NI) w w 0
    //TRACE PROPERTY R(NI) l l 0
    TRACE PROPERTY R(NI) R R 2
  #ELSE
    DEVICE R(NI) rnodip tndiff tndiff [
      property R
      w = perimeter_coincide(rnodip,tndiff)/2
      A = area(rnodip)
      l = A/w
      R = RVNI1*l/w
    ]
    TRACE PROPERTY R(NI) R R 2
  #ENDIF
#ELSE
  DEVICE R(NI) rnodip tndiff tndiff [RVNI1]
    TRACE PROPERTY R(NI) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NI) rnodipw tndiff tndiff netlist model rnodw netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rnodipw,tndiff)/2
      A = area(rnodipw)
      l = A/w
      R = RVNI2*l/w
    ]
  #ELSE
    DEVICE R(NI) rnodipw tndiff tndiff [
      property R
      w = perimeter_coincide(rnodipw,tndiff)/2
      A = area(rnodipw)
      l = A/w
      R = RVNI2*l/w
    ]
  #ENDIF
#ELSE
  DEVICE R(NI) rnodipw tndiff tndiff [RVNI2]
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NR) rnporpo poly poly netlist model rnpo1rpo netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rnporpo,poly)/2
      A = area(rnporpo)
      l = A/w
      R = RVNR*l/w
    ]
    //TRACE PROPERTY R(NR) w w 0
    //TRACE PROPERTY R(NR) l l 0
    TRACE PROPERTY R(NR) R R 2
  #ELSE
    DEVICE R(NR) rnporpo poly poly [
      property R
      w = perimeter_coincide(rnporpo,poly)/2
      A = area(rnporpo)
      l = A/w
      R = RVNR*l/w
    ]
    TRACE PROPERTY R(NR) R R 2
  #ENDIF
#ELSE
  DEVICE R(NR) rnporpo poly poly [RVNR]
    TRACE PROPERTY R(NR) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NS) rnpoip poly poly netlist model rnpo1 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rnpoip,poly)/2
      A = area(rnpoip)
      l = A/w
      R = RVNS1*l/w
    ]
    //TRACE PROPERTY R(NS) w w 0
    //TRACE PROPERTY R(NS) l l 0
    TRACE PROPERTY R(NS) R R 2
  #ELSE
    DEVICE R(NS) rnpoip poly poly [
      property R
      w = perimeter_coincide(rnpoip,poly)/2
      A = area(rnpoip)
      l = A/w
      R = RVNS1*l/w
    ]
    TRACE PROPERTY R(NS) R R 2
  #ENDIF
#ELSE
  DEVICE R(NS) rnpoip poly poly [RVNS1]
    TRACE PROPERTY R(NS) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(NS) rnpoipw poly poly netlist model rnpo1w netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rnpoipw,poly)/2
      A = area(rnpoipw)
      l = A/w
      R = RVNS2*l/w
    ]
  #ELSE
    DEVICE R(NS) rnpoipw poly poly [
      property R
      w = perimeter_coincide(rnpoipw,poly)/2
      A = area(rnpoipw)
      l = A/w
      R = RVNS2*l/w
    ]
  #ENDIF
#ELSE
  DEVICE R(NS) rnpoipw poly poly [RVNS2]
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PD) prdop tpdiff tpdiff netlist model rpodrpo netlist element "X" [
      property w,l,R
      w = perimeter_coincide(prdop,tpdiff)/2
      A = area(prdop)
      l = A/w
      R = RVPD*l/w
    ]
    //TRACE PROPERTY R(PD) w w 0
    //TRACE PROPERTY R(PD) l l 0
    TRACE PROPERTY R(PD) R R 2
  #ELSE
    DEVICE R(PD) prdop tpdiff tpdiff [
      property R
      w = perimeter_coincide(prdop,tpdiff)/2
      A = area(prdop)
      l = A/w
      R = RVPD*l/w
    ]
    TRACE PROPERTY R(PD) R R 2
  #ENDIF
#ELSE
  DEVICE R(PD) prdop tpdiff tpdiff [RVPD]
    TRACE PROPERTY R(PD) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PI) rpodip tpdiff tpdiff netlist model rpod netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rpodip,tpdiff)/2
      A = area(rpodip)
      l = A/w
      R = RVPI1*l/w
    ]
    //TRACE PROPERTY R(PI) w w 0
    //TRACE PROPERTY R(PI) l l 0
    TRACE PROPERTY R(PI) R R 2
  #ELSE
    DEVICE R(PI) rpodip tpdiff tpdiff [
      property R
      w = perimeter_coincide(rpodip,tpdiff)/2
      A = area(rpodip)
      l = A/w
      R = RVPI1*l/w
    ]
    TRACE PROPERTY R(PI) R R 2
  #ENDIF
#ELSE
  DEVICE R(PI) rpodip tpdiff tpdiff [RVPI1]
    TRACE PROPERTY R(PI) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PI) rpodipw tpdiff tpdiff netlist model rpodw netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rpodipw,tpdiff)/2
      A = area(rpodipw)
      l = A/w
      R = RVPI2*l/w
    ]
  #ELSE
    DEVICE R(PI) rpodipw tpdiff tpdiff [
      property R
      w = perimeter_coincide(rpodipw,tpdiff)/2
      A = area(rpodipw)
      l = A/w
      R = RVPI2*l/w
    ]
  #ENDIF
#ELSE
  DEVICE R(PI) rpodipw tpdiff tpdiff [RVPI2]
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PR) rpporpo poly poly netlist model rppo1rpo netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rpporpo,poly)/2
      A = area(rpporpo)
      l = A/w
      R = RVPR*l/w
    ]
    //TRACE PROPERTY R(PR) w w 0
    //TRACE PROPERTY R(PR) l l 0
    TRACE PROPERTY R(PR) R R 2
  #ELSE
    DEVICE R(PR) rpporpo poly poly [
      property R
      w = perimeter_coincide(rpporpo,poly)/2
      A = area(rpporpo)
      l = A/w
      R = RVPR*l/w
    ]
    TRACE PROPERTY R(PR) R R 2
  #ENDIF
#ELSE
  DEVICE R(PR) rpporpo poly poly [RVPR]
    TRACE PROPERTY R(PR) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PS) rppoip poly poly netlist model rppo1 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rppoip,poly)/2
      A = area(rppoip)
      l = A/w
      R = RVPS1*l/w
    ]
    //TRACE PROPERTY R(PS) w w 0
    //TRACE PROPERTY R(PS) l l 0
    TRACE PROPERTY R(PS) R R 2
  #ELSE
    DEVICE R(PS) rppoip poly poly [
      property R
      w = perimeter_coincide(rppoip,poly)/2
      A = area(rppoip)
      l = A/w
      R = RVPS1*l/w
    ]
    TRACE PROPERTY R(PS) R R 2
  #ENDIF
#ELSE
  DEVICE R(PS) rppoip poly poly [RVPS1]
    TRACE PROPERTY R(PS) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(PS) rppoipw poly poly netlist model rppo1w netlist element "X" [
      property w,l,R
      w = perimeter_coincide(rppoipw,poly)/2
      A = area(rppoipw)
      l = A/w
      R = RVPS2*l/w
    ]
  #ELSE
    DEVICE R(PS) rppoipw poly poly [
      property R
      w = perimeter_coincide(rppoipw,poly)/2
      A = area(rppoipw)
      l = A/w
      R = RVPS2*l/w
    ]
  #ENDIF
#ELSE
  DEVICE R(PS) rppoipw poly poly [RVPS2]
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(WO) nwod nxwell nxwell netlist model rnwod netlist element "X" [
      property w,l,R
      w = perimeter_coincide(nwod,nxwell)/2
      A = area(nwod)
      l = A/w
      R = RVWO*l/w
    ]
    //TRACE PROPERTY R(WO) w w 0
    //TRACE PROPERTY R(WO) l l 0
    TRACE PROPERTY R(WO) R R 2
  #ELSE
    DEVICE R(WO) nwod nxwell nxwell [
      property R
      w = perimeter_coincide(nwod,nxwell)/2
      A = area(nwod)
      l = A/w
      R = RVWO*l/w
    ]
    TRACE PROPERTY R(WO) R R 2
  #ENDIF
#ELSE
  DEVICE R(WO) nwod nxwell nxwell [RVWO]
    TRACE PROPERTY R(WO) R R 0
#ENDIF

#IFDEF ACCURACY
  #IFDEF RC_DECK
    DEVICE R(WR) nwsti nxwell nxwell netlist model rnwsti netlist element "X" [
      property w,l,R
      w = perimeter_coincide(nwsti,nxwell)/2
      A = area(nwsti)
      l = A/w
      R = RVWR*l/w
    ]
    //TRACE PROPERTY R(WR) w w 0
    //TRACE PROPERTY R(WR) l l 0
    TRACE PROPERTY R(WR) R R 2
  #ELSE
    DEVICE R(WR) nwsti nxwell nxwell [
      property R
      w = perimeter_coincide(nwsti,nxwell)/2
      A = area(nwsti)
      l = A/w
      R = RVWR*l/w
    ]
    TRACE PROPERTY R(WR) R R 2
  #ENDIF
#ELSE
  DEVICE R(WR) nwsti nxwell nxwell [RVWR]
    TRACE PROPERTY R(WR) R R 0
#ENDIF


// User define devices 
#IFNDEF top2_thick
#IFDEF ACCURACY
#IFDEF RC_DECK
    DEVICE R(M4) mt4res metal4 metal4 netlist model rm4 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt4res,metal4)/2
      A = area(mt4res)
      l = A/w
      R = RVM4*l/w
    ]
    TRACE PROPERTY R(M4) R R 0
#ELSE
    DEVICE R(M4) mt4res metal4 metal4 [
      property R
      w = perimeter_coincide(mt4res,metal4)/2
      A = area(mt4res)
      l = A/w
      R = RVM4*l/w
    ]
    TRACE PROPERTY R(M4) R R 0
#ENDIF
#ELSE
  DEVICE R(M4) mt4res metal4 metal4 [RVM4]
    TRACE PROPERTY R(M4) R R 0
#ENDIF
    
#ELSE
#IFDEF ACCURACY
#IFDEF RC_DECK
    DEVICE R(M4) mt4res metal4 metal4 netlist model rm6 netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt4res,metal4)/2
      A = area(mt4res)
      l = A/w
      R = RVMT*l/w
    ]
    TRACE PROPERTY R(M4) R R 0
#ELSE
    DEVICE R(M4) mt4res metal4 metal4 [
      property R
      w = perimeter_coincide(mt4res,metal4)/2
      A = area(mt4res)
      l = A/w
      R = RVMT*l/w
    ]
    TRACE PROPERTY R(M4) R R 0
#ENDIF
#ELSE
  DEVICE R(M4) mt4res metal4 metal4 [RVMT]
    TRACE PROPERTY R(M4) R R 0
#ENDIF
#ENDIF

#IFDEF ACCURACY
#IFDEF RC_DECK
    DEVICE R(MT) mt5res metal5 metal5 netlist model rmu_40k netlist element "X" [
      property w,l,R
      w = perimeter_coincide(mt5res,metal5)/2
      A = area(mt5res)
      l = A/w
      R = RV40K*l/w
    ]
    //TRACE PROPERTY R(MT) w w 0
    //TRACE PROPERTY R(MT) l l 0
    TRACE PROPERTY R(MT) R R 0
#ELSE
    DEVICE R(MT) mt5res metal5 metal5 [
      property R
      w = perimeter_coincide(mt5res,metal5)/2
      A = area(mt5res)
      l = A/w
      R = RV40K*l/w
    ]
    TRACE PROPERTY R(MT) R R 0
#ENDIF
#ELSE
  DEVICE R(MT) mt5res metal5 metal5 [RV40K]
    TRACE PROPERTY R(MT) R R 0
#ENDIF

//

//









fmom12_m1_23_reg1     = mom12_4 NOT INTERACT RFDUMMY
fmom12_m1_23_reg2     = fmom12_m1_23_reg1 NOT HVNW
fmom12_m1_23_reg3     = fmom12_m1_23_reg2 NOT HVOX
fmom12_m1_23_reg4     = fmom12_m1_23_reg3 INTERACT MOMDMY100
fmom12_m1_23_reg5     = fmom12_m1_23_reg4 NOT INTERACT MOMDMY34
fmom12_m1_23_reg6     = fmom12_m1_23_reg5 NOT INTERACT MOMDMY35
fmom12_m1_23_reg7     = fmom12_m1_23_reg6 INTERACT MOMDMY36
fmom12_m1_23_reg8     = fmom12_m1_23_reg7 NOT INTERACT MOMDMY37
fmom12_m1_23_reg_2t   = fmom12_m1_23_reg8 INTERACT MOMDMYBB
fmom12_m1_23_reg_3t   = fmom12_m1_23_reg8 NOT INTERACT MOMDMYBB

fmom12_m1_28_reg1     = mom12_4 NOT INTERACT RFDUMMY
fmom12_m1_28_reg2     = fmom12_m1_28_reg1 NOT HVNW
fmom12_m1_28_reg3     = fmom12_m1_28_reg2 NOT HVOX
fmom12_m1_28_reg4     = fmom12_m1_28_reg3 INTERACT MOMDMY100
fmom12_m1_28_reg5     = fmom12_m1_28_reg4 NOT INTERACT MOMDMY34
fmom12_m1_28_reg6     = fmom12_m1_28_reg5 NOT INTERACT MOMDMY35
fmom12_m1_28_reg7     = fmom12_m1_28_reg6 NOT INTERACT MOMDMY36
fmom12_m1_28_reg8     = fmom12_m1_28_reg7 INTERACT MOMDMY37
fmom12_m1_28_reg_2t   = fmom12_m1_28_reg8 INTERACT MOMDMYBB
fmom12_m1_28_reg_3t   = fmom12_m1_28_reg8 NOT INTERACT MOMDMYBB



#IFDEF top2_thick
DEVICE cfmom_m1_0d23_2t fmom12_m1_23_reg_2t metal2(PLUS) metal2(MINUS) <MOM_field2> <F_reg2> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field2)
    lr = (perimeter_coincide(F_reg2,MOM_field2)/2)/(nr-1)
    spm = 2
]

DEVICE cfmom_m1_0d28_2t fmom12_m1_28_reg_2t metal2(PLUS) metal2(MINUS) <MOM_field2> <F_reg2> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field2)
    lr = (perimeter_coincide(F_reg2,MOM_field2)/2)/(nr-1)
    spm = 2
]
DEVICE cfmom_m1_0d23 fmom12_m1_23_reg_3t metal2(PLUS) metal2(MINUS) poly(BULK) <MOM_field2> <F_reg2> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field2)
    lr = (perimeter_coincide(F_reg2,MOM_field2)/2)/(nr-1)
    spm = 2
]

DEVICE cfmom_m1_0d28 fmom12_m1_28_reg_3t metal2(PLUS) metal2(MINUS) poly(BULK) <MOM_field2> <F_reg2> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field2)
    lr = (perimeter_coincide(F_reg2,MOM_field2)/2)/(nr-1)
    spm = 2
]
#ENDIF








fmom13_m1_23_reg1     = mom13_4 NOT INTERACT RFDUMMY
fmom13_m1_23_reg2     = fmom13_m1_23_reg1 NOT HVNW
fmom13_m1_23_reg3     = fmom13_m1_23_reg2 NOT HVOX
fmom13_m1_23_reg4     = fmom13_m1_23_reg3 INTERACT MOMDMY100
fmom13_m1_23_reg5     = fmom13_m1_23_reg4 NOT INTERACT MOMDMY34
fmom13_m1_23_reg6     = fmom13_m1_23_reg5 NOT INTERACT MOMDMY35
fmom13_m1_23_reg7     = fmom13_m1_23_reg6 INTERACT MOMDMY36
fmom13_m1_23_reg8     = fmom13_m1_23_reg7 NOT INTERACT MOMDMY37
fmom13_m1_23_reg_2t   = fmom13_m1_23_reg8 INTERACT MOMDMYBB
fmom13_m1_23_reg_3t   = fmom13_m1_23_reg8 NOT INTERACT MOMDMYBB

fmom13_m1_28_reg1     = mom13_4 NOT INTERACT RFDUMMY
fmom13_m1_28_reg2     = fmom13_m1_28_reg1 NOT HVNW
fmom13_m1_28_reg3     = fmom13_m1_28_reg2 NOT HVOX
fmom13_m1_28_reg4     = fmom13_m1_28_reg3 INTERACT MOMDMY100
fmom13_m1_28_reg5     = fmom13_m1_28_reg4 NOT INTERACT MOMDMY34
fmom13_m1_28_reg6     = fmom13_m1_28_reg5 NOT INTERACT MOMDMY35
fmom13_m1_28_reg7     = fmom13_m1_28_reg6 NOT INTERACT MOMDMY36
fmom13_m1_28_reg8     = fmom13_m1_28_reg7 INTERACT MOMDMY37
fmom13_m1_28_reg_2t   = fmom13_m1_28_reg8 INTERACT MOMDMYBB
fmom13_m1_28_reg_3t   = fmom13_m1_28_reg8 NOT INTERACT MOMDMYBB



#IFDEF top2_thick
DEVICE cfmom_m1_0d23_2t fmom13_m1_23_reg_2t metal3(PLUS) metal3(MINUS) <MOM_field3> <F_reg3> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field3)
    lr = (perimeter_coincide(F_reg3,MOM_field3)/2)/(nr-1)
    spm = 3
]

DEVICE cfmom_m1_0d28_2t fmom13_m1_28_reg_2t metal3(PLUS) metal3(MINUS) <MOM_field3> <F_reg3> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field3)
    lr = (perimeter_coincide(F_reg3,MOM_field3)/2)/(nr-1)
    spm = 3
]
DEVICE cfmom_m1_0d23 fmom13_m1_23_reg_3t metal3(PLUS) metal3(MINUS) poly(BULK) <MOM_field3> <F_reg3> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field3)
    lr = (perimeter_coincide(F_reg3,MOM_field3)/2)/(nr-1)
    spm = 3
]

DEVICE cfmom_m1_0d28 fmom13_m1_28_reg_3t metal3(PLUS) metal3(MINUS) poly(BULK) <MOM_field3> <F_reg3> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field3)
    lr = (perimeter_coincide(F_reg3,MOM_field3)/2)/(nr-1)
    spm = 3
]
#ENDIF


#IFDEF top2_thick
TRACE PROPERTY cfmom_m1_0d23_2t nr  nr  0 
TRACE PROPERTY cfmom_m1_0d23_2t lr  lr  0 
TRACE PROPERTY cfmom_m1_0d23_2t spm spm 0 

TRACE PROPERTY cfmom_m1_0d28_2t nr  nr  0 
TRACE PROPERTY cfmom_m1_0d28_2t lr  lr  0 
TRACE PROPERTY cfmom_m1_0d28_2t spm spm 0 

TRACE PROPERTY cfmom_m1_0d23 nr  nr  0 
TRACE PROPERTY cfmom_m1_0d23 lr  lr  0 
TRACE PROPERTY cfmom_m1_0d23 spm spm 0 

TRACE PROPERTY cfmom_m1_0d28 nr  nr  0 
TRACE PROPERTY cfmom_m1_0d28 lr  lr  0 
TRACE PROPERTY cfmom_m1_0d28 spm spm 0 
#ENDIF


//

//

//

//










fmom14_tm_m1_23_reg1     = mom14_4 NOT INTERACT RFDUMMY
fmom14_tm_m1_23_reg2     = fmom14_tm_m1_23_reg1 NOT HVNW
fmom14_tm_m1_23_reg3     = fmom14_tm_m1_23_reg2 NOT HVOX
fmom14_tm_m1_23_reg4     = fmom14_tm_m1_23_reg3 INTERACT MOMDMY100
fmom14_tm_m1_23_reg5     = fmom14_tm_m1_23_reg4 INTERACT MOMDMY34
fmom14_tm_m1_23_reg6     = fmom14_tm_m1_23_reg5 NOT INTERACT MOMDMY35
fmom14_tm_m1_23_reg7     = fmom14_tm_m1_23_reg6 NOT INTERACT MOMDMY36
fmom14_tm_m1_23_reg8     = fmom14_tm_m1_23_reg7 NOT INTERACT MOMDMY37
fmom14_tm_m1_23_reg_2t   = fmom14_tm_m1_23_reg8 INTERACT MOMDMYBB
fmom14_tm_m1_23_reg_3t   = fmom14_tm_m1_23_reg8 NOT INTERACT MOMDMYBB

fmom14_tm_m1_28_reg1     = mom14_4 NOT INTERACT RFDUMMY
fmom14_tm_m1_28_reg2     = fmom14_tm_m1_28_reg1 NOT HVNW
fmom14_tm_m1_28_reg3     = fmom14_tm_m1_28_reg2 NOT HVOX
fmom14_tm_m1_28_reg4     = fmom14_tm_m1_28_reg3 INTERACT MOMDMY100
fmom14_tm_m1_28_reg5     = fmom14_tm_m1_28_reg4 NOT INTERACT MOMDMY34
fmom14_tm_m1_28_reg6     = fmom14_tm_m1_28_reg5 INTERACT MOMDMY35
fmom14_tm_m1_28_reg7     = fmom14_tm_m1_28_reg6 NOT INTERACT MOMDMY36
fmom14_tm_m1_28_reg8     = fmom14_tm_m1_28_reg7 NOT INTERACT MOMDMY37
fmom14_tm_m1_28_reg_2t   = fmom14_tm_m1_28_reg8 INTERACT MOMDMYBB
fmom14_tm_m1_28_reg_3t   = fmom14_tm_m1_28_reg8 NOT INTERACT MOMDMYBB



#IFDEF top2_thick
DEVICE cfmom_tm_m1_0d23_2t fmom14_tm_m1_23_reg_2t metal4(PLUS) metal4(MINUS) <MOM_field4> <tm_F_reg4> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field4)
    lr = (perimeter_coincide(tm_F_reg4,MOM_field4)/2)/(nr-1)
    spm = 4
]

DEVICE cfmom_tm_m1_0d28_2t fmom14_tm_m1_28_reg_2t metal4(PLUS) metal4(MINUS) <MOM_field4> <tm_F_reg4> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field4)
    lr = (perimeter_coincide(tm_F_reg4,MOM_field4)/2)/(nr-1)
    spm = 4
]
DEVICE cfmom_tm_m1_0d23 fmom14_tm_m1_23_reg_3t metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field4> <tm_F_reg4> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field4)
    lr = (perimeter_coincide(tm_F_reg4,MOM_field4)/2)/(nr-1)
    spm = 4
]

DEVICE cfmom_tm_m1_0d28 fmom14_tm_m1_28_reg_3t metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field4> <tm_F_reg4> (PLUS MINUS) [
    property nr,lr,spm
    nr = count(MOM_field4)
    lr = (perimeter_coincide(tm_F_reg4,MOM_field4)/2)/(nr-1)
    spm = 4
]
#ENDIF


#IFDEF top2_thick
TRACE PROPERTY cfmom_tm_m1_0d23_2t nr nr 0 
TRACE PROPERTY cfmom_tm_m1_0d23_2t lr lr 0 
TRACE PROPERTY cfmom_tm_m1_0d23_2t spm  spm 0 

TRACE PROPERTY cfmom_tm_m1_0d28_2t nr nr 0 
TRACE PROPERTY cfmom_tm_m1_0d28_2t lr lr 0 
TRACE PROPERTY cfmom_tm_m1_0d28_2t spm  spm 0 

TRACE PROPERTY cfmom_tm_m1_0d23 nr nr 0 
TRACE PROPERTY cfmom_tm_m1_0d23 lr lr 0 
TRACE PROPERTY cfmom_tm_m1_0d23 spm  spm 0 

TRACE PROPERTY cfmom_tm_m1_0d28 nr nr 0 
TRACE PROPERTY cfmom_tm_m1_0d28 lr lr 0 
TRACE PROPERTY cfmom_tm_m1_0d28 spm  spm 0 
#ENDIF


//

//


MOM_field1 = M1 AND MOMDMY1
MOM_field2 = M2 AND MOMDMY2
MOM_field3 = M3 AND MOMDMY3
MOM_field4 = M4 AND MOMDMY4
MOM_field5 = M5 AND MOMDMY5

F_reg1a = EXT MOM_field1 < 0.565 OPPOSITE REGION
F_reg1b = F_reg1a INSIDE MOMDMY1
F_reg1  = ( F_reg1b AND MOMDMY1 ) NOT M1
tm_F_reg1a = EXT MOM_field1 < 0.905 OPPOSITE REGION
tm_F_reg1  = ( tm_F_reg1a AND MOMDMY1 ) NOT M1
F_reg2a = EXT MOM_field2 < 0.565 OPPOSITE REGION
F_reg2b = F_reg2a INSIDE MOMDMY2
F_reg2  = ( F_reg2b AND MOMDMY2 ) NOT M2
tm_F_reg2a = EXT MOM_field2 < 0.905 OPPOSITE REGION
tm_F_reg2  = ( tm_F_reg2a AND MOMDMY2 ) NOT M2
F_reg3a = EXT MOM_field3 < 0.565 OPPOSITE REGION
F_reg3b = F_reg3a INSIDE MOMDMY3
F_reg3  = ( F_reg3b AND MOMDMY3 ) NOT M3
tm_F_reg3a = EXT MOM_field3 < 0.905 OPPOSITE REGION
tm_F_reg3  = ( tm_F_reg3a AND MOMDMY3 ) NOT M3
F_reg4a = EXT MOM_field4 < 0.565 OPPOSITE REGION
F_reg4b = F_reg4a INSIDE MOMDMY4
F_reg4  = ( F_reg4b AND MOMDMY4 ) NOT M4
tm_F_reg4a = EXT MOM_field4 < 0.905 OPPOSITE REGION
tm_F_reg4  = ( tm_F_reg4a AND MOMDMY4 ) NOT M4
F_reg5a = EXT MOM_field5 < 0.565 OPPOSITE REGION
F_reg5b = F_reg5a INSIDE MOMDMY5
F_reg5  = ( F_reg5b AND MOMDMY5 ) NOT M5
tm_F_reg5a = EXT MOM_field5 < 0.905 OPPOSITE REGION
tm_F_reg5  = ( tm_F_reg5a AND MOMDMY5 ) NOT M5





mom12_1 = MOMDMY2 INTERACT MOM_field1

mom12_2 = mom12_1 INTERACT MOM_field2


mom12_3 = mom12_2 NOT INTERACT MOM_field3
mom12_4 = mom12_3 NOT INTERACT MOM_field4

mom12_reg3 = mom12_4 NOT INTERACT RFDUMMY
mom12_reg2 = mom12_reg3 NOT HVNW
mom12_reg4 = mom12_reg2 NOT HVOX
mom12_reg  = mom12_reg4 NOT INTERACT MOMDMY100



mom13_1 = MOMDMY3 INTERACT MOM_field1

mom13_2 = mom13_1 INTERACT MOM_field2

mom13_3 = mom13_2 INTERACT MOM_field3


mom13_4 = mom13_3 NOT INTERACT MOM_field4

mom13_reg3 = mom13_4 NOT INTERACT RFDUMMY
mom13_reg2 = mom13_reg3 NOT HVNW
mom13_reg4 = mom13_reg2 NOT HVOX
mom13_reg  = mom13_reg4 NOT INTERACT MOMDMY100



mom14_1 = MOMDMY4 INTERACT MOM_field1

mom14_2 = mom14_1 INTERACT MOM_field2

mom14_3 = mom14_2 INTERACT MOM_field3

mom14_4 = mom14_3 INTERACT MOM_field4



mom14_reg3 = mom14_4 NOT INTERACT RFDUMMY
mom14_reg2 = mom14_reg3 NOT HVNW
mom14_reg4 = mom14_reg2 NOT HVOX
mom14_reg  = mom14_reg4 NOT INTERACT MOMDMY100



mom15_1 = MOMDMY5 INTERACT MOM_field1

mom15_2 = mom15_1 INTERACT MOM_field2

mom15_3 = mom15_2 INTERACT MOM_field3

mom15_4 = mom15_3 INTERACT MOM_field4

mom15_5 = mom15_4 INTERACT MOM_field5



mom15_reg3 = mom15_5 NOT INTERACT RFDUMMY
mom15_reg2 = mom15_reg3 NOT HVNW
mom15_reg4 = mom15_reg2 NOT HVOX
mom15_reg  = mom15_reg4 NOT INTERACT MOMDMY100



mom24_1 = MOMDMY4 NOT INTERACT MOM_field1   


mom24_2 = mom24_1 INTERACT MOM_field2

mom24_3 = mom24_2 INTERACT MOM_field3

mom24_4 = mom24_3 INTERACT MOM_field4



mom24_reg3 = mom24_4 NOT INTERACT RFDUMMY
mom24_reg2 = mom24_reg3 NOT HVNW
mom24_reg4 = mom24_reg2 NOT HVOX
mom24_reg  = mom24_reg4 NOT INTERACT MOMDMY100











fmom13_reg1     = mom13_4 NOT INTERACT RFDUMMY
fmom13_reg2     = fmom13_reg1 NOT HVNW
fmom13_reg3     = fmom13_reg2 NOT HVOX
fmom13_reg4     = fmom13_reg3 INTERACT MOMDMY100
fmom13_reg5     = fmom13_reg4 NOT INTERACT MOMDMYBB
fmom13_reg6     = fmom13_reg5 NOT INTERACT MOMDMY34
fmom13_reg7     = fmom13_reg6 NOT INTERACT MOMDMY35
fmom13_reg8     = fmom13_reg7 NOT INTERACT MOMDMY36
fmom13_reg9     = fmom13_reg8 NOT INTERACT MOMDMY37
fmom13_reg10    = fmom13_reg9 NOT INTERACT MOMDMY22
fmom13_reg      = fmom13_reg10 INTERACT NIMP

fmom13_mx_reg1  = MOMDMY22 NOT INTERACT RFDUMMY
fmom13_mx_reg2  = fmom13_mx_reg1 NOT HVNW
fmom13_mx_reg3  = fmom13_mx_reg2 NOT HVOX
fmom13_mx_reg4  = fmom13_mx_reg3 NOT INTERACT RFDUMMY1
fmom13_mx_reg5  = fmom13_mx_reg4 INTERACT mom13_4		    
fmom13_mx_reg6  = fmom13_mx_reg5 INTERACT MOMDMY100
fmom13_mx_reg7  = fmom13_mx_reg6 NOT INTERACT MOMDMYBB
fmom13_mx_reg8  = fmom13_mx_reg7 NOT INTERACT MOMDMY34
fmom13_mx_reg9  = fmom13_mx_reg8 NOT INTERACT MOMDMY35
fmom13_mx_reg10 = fmom13_mx_reg9 NOT INTERACT MOMDMY36
fmom13_mx_reg11 = fmom13_mx_reg10 NOT INTERACT MOMDMY37
fmom13_mx_reg   = fmom13_mx_reg11 INTERACT NIMP
mom13_mx_aux    = mom13_4 AND MOMDMY22



DEVICE crtmom mom13_reg metal3(PLUS) metal3(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w  = perimeter_coincide(MOM_field2,mom13_reg)/ nh
    s  = ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 3
] 

DEVICE cfmom fmom13_reg metal3(PLUS) metal3(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field1,fmom13_reg)/ nr
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(nr-1)
    stm = 1
    spm = 3
]
DEVICE cfmom_mx fmom13_mx_reg mom3p1(PLUS1) mom3m1(MINUS1) mom3p2(PLUS2) mom3m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom13_mx_aux> [
     property w,s,nr,lr,stm,spm
     mf1 = count(mom13_mx_aux)
     mf = mf1/2
     nr = count(MOM_field1)/mf1
     w =  perimeter_coincide(MOM_field2,mom13_mx_aux)/ (nr*mf1)
     s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
     lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(mf1*(nr-1))
     stm = 1
     spm = 3
]









fmom14_reg1     = mom14_4 NOT INTERACT RFDUMMY
fmom14_reg2     = fmom14_reg1 NOT HVNW
fmom14_reg3     = fmom14_reg2 NOT HVOX
fmom14_reg4     = fmom14_reg3 INTERACT MOMDMY100
fmom14_reg5     = fmom14_reg4 NOT INTERACT MOMDMYBB
fmom14_reg6     = fmom14_reg5 NOT INTERACT MOMDMY34
fmom14_reg7     = fmom14_reg6 NOT INTERACT MOMDMY35
fmom14_reg8     = fmom14_reg7 NOT INTERACT MOMDMY36
fmom14_reg9     = fmom14_reg8 NOT INTERACT MOMDMY37
fmom14_reg10    = fmom14_reg9 NOT INTERACT MOMDMY22
fmom14_reg      = fmom14_reg10 INTERACT NIMP

fmom14_mx_reg1  = MOMDMY22 NOT INTERACT RFDUMMY
fmom14_mx_reg2  = fmom14_mx_reg1 NOT HVNW
fmom14_mx_reg3  = fmom14_mx_reg2 NOT HVOX
fmom14_mx_reg4  = fmom14_mx_reg3 NOT INTERACT RFDUMMY1
fmom14_mx_reg5  = fmom14_mx_reg4 INTERACT mom14_4		    
fmom14_mx_reg6  = fmom14_mx_reg5 INTERACT MOMDMY100
fmom14_mx_reg7  = fmom14_mx_reg6 NOT INTERACT MOMDMYBB
fmom14_mx_reg8  = fmom14_mx_reg7 NOT INTERACT MOMDMY34
fmom14_mx_reg9  = fmom14_mx_reg8 NOT INTERACT MOMDMY35
fmom14_mx_reg10 = fmom14_mx_reg9 NOT INTERACT MOMDMY36
fmom14_mx_reg11 = fmom14_mx_reg10 NOT INTERACT MOMDMY37
fmom14_mx_reg   = fmom14_mx_reg11 INTERACT NIMP
mom14_mx_aux    = mom14_4 AND MOMDMY22



#IFNDEF top2_thick
DEVICE crtmom mom14_reg metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w  = perimeter_coincide(MOM_field2,mom14_reg)/ nh
    s  = ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 4
] 

DEVICE cfmom fmom14_reg metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field1)
    w =  perimeter_coincide(MOM_field1,fmom14_reg)/ nr
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(nr-1)
    stm = 1
    spm = 4
]
DEVICE cfmom_mx fmom14_mx_reg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) poly(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom14_mx_aux> [
     property w,s,nr,lr,stm,spm
     mf1 = count(mom14_mx_aux)
     mf = mf1/2
     nr = count(MOM_field1)/mf1
     w =  perimeter_coincide(MOM_field2,mom14_mx_aux)/ (nr*mf1)
     s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nr-1))
     lr = (perimeter_coincide(F_reg1,MOM_field1)/2)/(mf1*(nr-1))
     stm = 1
     spm = 4
]
#ENDIF










fmom24_reg1     = mom24_4 NOT INTERACT RFDUMMY
fmom24_reg2     = fmom24_reg1 NOT HVNW
fmom24_reg3     = fmom24_reg2 NOT HVOX
fmom24_reg4     = fmom24_reg3 INTERACT MOMDMY100
fmom24_reg5     = fmom24_reg4 NOT INTERACT MOMDMYBB
fmom24_reg6     = fmom24_reg5 NOT INTERACT MOMDMY34
fmom24_reg7     = fmom24_reg6 NOT INTERACT MOMDMY35
fmom24_reg8     = fmom24_reg7 NOT INTERACT MOMDMY36
fmom24_reg9     = fmom24_reg8 NOT INTERACT MOMDMY37
fmom24_reg10    = fmom24_reg9 NOT INTERACT MOMDMY22
fmom24_reg      = fmom24_reg10 INTERACT NIMP

fmom24_mx_reg1  = MOMDMY22 NOT INTERACT RFDUMMY
fmom24_mx_reg2  = fmom24_mx_reg1 NOT HVNW
fmom24_mx_reg3  = fmom24_mx_reg2 NOT HVOX
fmom24_mx_reg4  = fmom24_mx_reg3 NOT INTERACT RFDUMMY1
fmom24_mx_reg5  = fmom24_mx_reg4 INTERACT mom24_4		    
fmom24_mx_reg6  = fmom24_mx_reg5 INTERACT MOMDMY100
fmom24_mx_reg7  = fmom24_mx_reg6 NOT INTERACT MOMDMYBB
fmom24_mx_reg8  = fmom24_mx_reg7 NOT INTERACT MOMDMY34
fmom24_mx_reg9  = fmom24_mx_reg8 NOT INTERACT MOMDMY35
fmom24_mx_reg10 = fmom24_mx_reg9 NOT INTERACT MOMDMY36
fmom24_mx_reg11 = fmom24_mx_reg10 NOT INTERACT MOMDMY37
fmom24_mx_reg   = fmom24_mx_reg11 INTERACT NIMP
mom24_mx_aux    = mom24_4 AND MOMDMY22



#IFNDEF top2_thick
DEVICE crtmom mom24_reg metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w  = perimeter_coincide(MOM_field2,mom24_reg)/ nh
    s  = ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 4
] 

DEVICE cfmom fmom24_reg metal4(PLUS) metal4(MINUS) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> (PLUS MINUS) [
    property w,s,nr,lr,stm,spm
    nr = count(MOM_field3)
    w =  perimeter_coincide(MOM_field3,fmom24_reg)/ nr
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nr-1)
    lr = (perimeter_coincide(F_reg2,MOM_field2)/2)/(nr-1)
    stm = 2
    spm = 4
]
DEVICE cfmom_mx fmom24_mx_reg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) poly(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom24_mx_aux> [
     property w,s,nr,lr,stm,spm
     mf1 = count(mom24_mx_aux)
     mf = mf1/2
     nr = count(MOM_field3)/mf1
     w =  perimeter_coincide(MOM_field2,mom24_mx_aux)/ (nr*mf1)
     s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nr-1))
     lr = (perimeter_coincide(F_reg2,MOM_field3)/2)/(mf1*(nr-1))
     stm = 2
     spm = 4
]
#ENDIF




TRACE PROPERTY crtmom nv nv 0 
TRACE PROPERTY crtmom nh nh 0 
TRACE PROPERTY crtmom s  s 0 
TRACE PROPERTY crtmom w  w 0
TRACE PROPERTY crtmom stm stm 0
TRACE PROPERTY crtmom spm spm 0

TRACE PROPERTY cfmom nr nr   0 
TRACE PROPERTY cfmom s  s    0
TRACE PROPERTY cfmom w  w    0
TRACE PROPERTY cfmom lr  lr  0
TRACE PROPERTY cfmom stm stm 0
TRACE PROPERTY cfmom spm spm 0

TRACE PROPERTY cfmom_mx nr nr   0 
TRACE PROPERTY cfmom_mx s  s    0
TRACE PROPERTY cfmom_mx w  w    0
TRACE PROPERTY cfmom_mx lr  lr  0
TRACE PROPERTY cfmom_mx stm stm 0
TRACE PROPERTY cfmom_mx spm spm 0


#IFDEF top2_thick
DEVICE mimcap_1p0_sin capm4_1p0_2t ctm(TOP) metal3(BOT)  [
     property lt, wt
     A_CAP = area(capm4_1p0_2t)
     P_CAP = perimeter(capm4_1p0_2t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
]     
#ELSE
#IFDEF top_metal_mim
DEVICE mimcap_1p0_sin capm4_1p0_2t ctm(TOP) metal4(BOT)  [
     property lt, wt
     A_CAP = area(capm4_1p0_2t)
     P_CAP = perimeter(capm4_1p0_2t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
]     
#ELSE
DEVICE mimcap_1p0_sin capm4_1p0_2t ctm(TOP) metal3(BOT)  [
     property lt, wt
     A_CAP = area(capm4_1p0_2t)
     P_CAP = perimeter(capm4_1p0_2t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
]     
#ENDIF
#ENDIF
     TRACE PROPERTY mimcap_1p0_sin lt lt 0
     TRACE PROPERTY mimcap_1p0_sin wt wt 0

#IFDEF top2_thick
DEVICE mimcap_1p0_sin_3t capm4_1p0_3t ctm(PLUS) metal3(MINUS) mim_term(BULK)  [
     property wt, lt, lay
     A_CAP = area(capm4_1p0_3t)
     P_CAP = perimeter(capm4_1p0_3t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
     lay = 4
]    
#ELSE
#IFDEF top_metal_mim
DEVICE mimcap_1p0_sin_3t capm4_1p0_3t ctm(PLUS) metal4(MINUS) mim_term(BULK)  [
     property wt, lt, lay
     A_CAP = area(capm4_1p0_3t)
     P_CAP = perimeter(capm4_1p0_3t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
     lay = 5
]    
#ELSE
DEVICE mimcap_1p0_sin_3t capm4_1p0_3t ctm(PLUS) metal3(MINUS) mim_term(BULK)  [
     property wt, lt, lay
     A_CAP = area(capm4_1p0_3t)
     P_CAP = perimeter(capm4_1p0_3t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
     lay = 4
]    
#ENDIF 
#ENDIF 
     TRACE PROPERTY mimcap_1p0_sin_3t Lt Lt 0
     TRACE PROPERTY mimcap_1p0_sin_3t wt wt 0
     TRACE PROPERTY mimcap_1p0_sin_3t lay lay 0

#IFDEF top2_thick
DEVICE mimcap_2p0_sin capm4_2p0_2t ctm(TOP) metal3(BOT)  [
     property lt, wt
     A_CAP = area(capm4_2p0_2t)
     P_CAP = perimeter(capm4_2p0_2t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
]     
#ELSE
#IFDEF top_metal_mim
DEVICE mimcap_2p0_sin capm4_2p0_2t ctm(TOP) metal4(BOT)  [
     property lt, wt
     A_CAP = area(capm4_2p0_2t)
     P_CAP = perimeter(capm4_2p0_2t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
]     
#ELSE
DEVICE mimcap_2p0_sin capm4_2p0_2t ctm(TOP) metal3(BOT)  [
     property lt, wt
     A_CAP = area(capm4_2p0_2t)
     P_CAP = perimeter(capm4_2p0_2t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
]     
#ENDIF
#ENDIF
     TRACE PROPERTY mimcap_2p0_sin lt lt 0
     TRACE PROPERTY mimcap_2p0_sin wt wt 0

#IFDEF top2_thick
DEVICE mimcap_2p0_sin_3t capm4_2p0_3t ctm(PLUS) metal3(MINUS) mim_term(BULK)  [
     property wt, lt, lay
     A_CAP = area(capm4_2p0_3t)
     P_CAP = perimeter(capm4_2p0_3t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
     lay = 4
]    
#ELSE
#IFDEF top_metal_mim
DEVICE mimcap_2p0_sin_3t capm4_2p0_3t ctm(PLUS) metal4(MINUS) mim_term(BULK)  [
     property wt, lt, lay
     A_CAP = area(capm4_2p0_3t)
     P_CAP = perimeter(capm4_2p0_3t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
     lay = 5
]    
#ELSE
DEVICE mimcap_2p0_sin_3t capm4_2p0_3t ctm(PLUS) metal3(MINUS) mim_term(BULK)  [
     property wt, lt, lay
     A_CAP = area(capm4_2p0_3t)
     P_CAP = perimeter(capm4_2p0_3t)
     P_2_CAP = P_CAP * P_CAP
     AC4 = A_CAP * 16
     KKK = P_2_CAP-AC4
     IF(KKK<0) {
     KKK=0
     }
     SQ = sqrt(KKK)
     lt = (P_CAP+SQ)/4
     wt = (P_CAP-SQ)/4
     lay = 4
]    
#ENDIF 
#ENDIF 
     TRACE PROPERTY mimcap_2p0_sin_3t Lt Lt 0
     TRACE PROPERTY mimcap_2p0_sin_3t wt wt 0
     TRACE PROPERTY mimcap_2p0_sin_3t lay lay 0

na20_g5a_cfp_mac_reg_w = NDD COINCIDENT EDGE na20_g5a_cfp_mac_reg
NDD_na20_g5a_cfp_mac_reg = DFM PROPERTY NDD na20_g5a_cfp_mac_reg na20_g5a_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(na20_g5a_cfp_mac_reg)] [NW = LENGTH(na20_g5a_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE na20_g5a_cfp_mac na20_g5a_cfp_mac_reg NDD(D) poly(G) hvndfs(S) psub(B) <NDD_na20_g5a_cfp_mac_reg> <nthin> <SH_P> <hvnmos_na29_ga_poly> netlist model na20_g5a_cfp_mac [
  property W,L,AS,AD,PS,PD
  W = perimeter_coincide(na20_g5a_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na29_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na20_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = area(D) * W /AW
  PD = perimeter(D) * W /AW
]
#ELSE

#IFDEF extract_as_ad
DEVICE na20_g5a_cfp_mac na20_g5a_cfp_mac_reg NDD(D) poly(G) hvndfs(S) psub(B) <NDD_na20_g5a_cfp_mac_reg> <nthin> <SH_P> <hvnmos_na29_ga_poly> netlist model na20_g5a_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(na20_g5a_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na29_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na20_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = area(D) * W /AW
  PD = perimeter(D) * W /AW
]
#ELSE
DEVICE na20_g5a_cfp_mac na20_g5a_cfp_mac_reg NDD(D) poly(G) hvndfs(S) psub(B) <hvnmos_na29_ga_poly> [
  property W,L
  W = perimeter_coincide(na20_g5a_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na29_ga_poly) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY na20_g5a_cfp_mac L L 0
TRACE PROPERTY na20_g5a_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS na20_g5a_cfp_mac [D=D G=G S=S]
//LVS REDUCE na20_g5a_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


na20_g5a_nbl_cfp_mac_reg_w = na20_g5a_nbl_cfp_mac_reg COINCIDENT EDGE NDD_no_poly
NDD_na20_g5a_nbl_cfp_mac_reg = DFM PROPERTY NDD na20_g5a_nbl_cfp_mac_reg na20_g5a_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(na20_g5a_nbl_cfp_mac_reg)] [NW = LENGTH(na20_g5a_nbl_cfp_mac_reg_w)]

#IFDEF RC_DECK

DEVICE na20_g5a_nbl_cfp_mac na20_g5a_nbl_cfp_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <NDD_na20_g5a_nbl_cfp_mac_reg> <nthin> <hvnmos_na_ga_poly> <NBL> netlist model na20_g5a_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,area_total
  W = perimeter_coincide(na20_g5a_nbl_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na20_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  area_total = AREA(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE na20_g5a_nbl_cfp_mac na20_g5a_nbl_cfp_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <NDD_na20_g5a_nbl_cfp_mac_reg> <nthin> <hvnmos_na_ga_poly> netlist model na20_g5a_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(na20_g5a_nbl_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na20_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE na20_g5a_nbl_cfp_mac na20_g5a_nbl_cfp_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <hvnmos_na_ga_poly> [
  property W,L
  W = perimeter_coincide(na20_g5a_nbl_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY na20_g5a_nbl_cfp_mac L L 0
TRACE PROPERTY na20_g5a_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS na20_g5a_nbl_cfp_mac [D=D G=G S=S]
//LVS REDUCE na20_g5a_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


na29_g5a_cfp_mac_reg_w = NDD COINCIDENT EDGE na29_g5a_cfp_mac_reg
NDD_na29_g5a_cfp_mac_reg = DFM PROPERTY NDD na29_g5a_cfp_mac_reg na29_g5a_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(na29_g5a_cfp_mac_reg)] [NW = LENGTH(na29_g5a_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE na29_g5a_cfp_mac na29_g5a_cfp_mac_reg NDD(D) poly(G) hvndfs(S) psub(B) <NDD_na29_g5a_cfp_mac_reg> <nthin> <SH_P> <hvnmos_na29_ga_poly> netlist model na29_g5a_cfp_mac [
  property W,L,AS,AD,PS,PD
  W = perimeter_coincide(na29_g5a_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na29_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na29_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = area(D) * W /AW
  PD = perimeter(D) * W /AW
]
#ELSE

#IFDEF extract_as_ad
DEVICE na29_g5a_cfp_mac na29_g5a_cfp_mac_reg NDD(D) poly(G) hvndfs(S) psub(B) <NDD_na29_g5a_cfp_mac_reg> <nthin> <SH_P> <hvnmos_na29_ga_poly> netlist model na29_g5a_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(na29_g5a_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na29_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na29_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = area(D) * W /AW
  PD = perimeter(D) * W /AW
]
#ELSE
DEVICE na29_g5a_cfp_mac na29_g5a_cfp_mac_reg NDD(D) poly(G) hvndfs(S) psub(B) <hvnmos_na29_ga_poly> [
  property W,L
  W = perimeter_coincide(na29_g5a_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na29_ga_poly) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY na29_g5a_cfp_mac L L 0
TRACE PROPERTY na29_g5a_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS na29_g5a_cfp_mac [D=D G=G S=S]
//LVS REDUCE na29_g5a_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


na29_g5a_nbl_cfp_mac_reg_w = na29_g5a_nbl_cfp_mac_reg COINCIDENT EDGE NDD_no_poly
NDD_na29_g5a_nbl_cfp_mac_reg = DFM PROPERTY NDD na29_g5a_nbl_cfp_mac_reg na29_g5a_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(na29_g5a_nbl_cfp_mac_reg)] [NW = LENGTH(na29_g5a_nbl_cfp_mac_reg_w)]

#IFDEF RC_DECK

DEVICE na29_g5a_nbl_cfp_mac na29_g5a_nbl_cfp_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <NDD_na29_g5a_nbl_cfp_mac_reg> <nthin> <hvnmos_na_ga_poly> <NBL> netlist model na29_g5a_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,area_total
  W = perimeter_coincide(na29_g5a_nbl_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na29_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  area_total = AREA(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE na29_g5a_nbl_cfp_mac na29_g5a_nbl_cfp_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <NDD_na29_g5a_nbl_cfp_mac_reg> <nthin> <hvnmos_na_ga_poly> netlist model na29_g5a_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(na29_g5a_nbl_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na29_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE na29_g5a_nbl_cfp_mac na29_g5a_nbl_cfp_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <hvnmos_na_ga_poly> [
  property W,L
  W = perimeter_coincide(na29_g5a_nbl_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY na29_g5a_nbl_cfp_mac L L 0
TRACE PROPERTY na29_g5a_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS na29_g5a_nbl_cfp_mac [D=D G=G S=S]
//LVS REDUCE na29_g5a_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


na6_g5a_nbl_v2_mac_reg_w = na6_g5a_nbl_v2_mac_reg COINCIDENT EDGE NDD_no_poly
NDD_na6_g5a_nbl_v2_mac_reg = DFM PROPERTY NDD na6_g5a_nbl_v2_mac_reg na6_g5a_nbl_v2_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(na6_g5a_nbl_v2_mac_reg)] [NW = LENGTH(na6_g5a_nbl_v2_mac_reg_w)]

#IFDEF RC_DECK

DEVICE na6_g5a_nbl_v2_mac na6_g5a_nbl_v2_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <NDD_na6_g5a_nbl_v2_mac_reg> <nthin> <hvnmos_na_ga_poly> <NBL> netlist model na6_g5a_nbl_v2_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,area_total
  W = perimeter_coincide(na6_g5a_nbl_v2_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na6_g5a_nbl_v2_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  area_total = AREA(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE na6_g5a_nbl_v2_mac na6_g5a_nbl_v2_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <NDD_na6_g5a_nbl_v2_mac_reg> <nthin> <hvnmos_na_ga_poly> netlist model na6_g5a_nbl_v2_mac [
  property W,L,AS,AD
  W = perimeter_coincide(na6_g5a_nbl_v2_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_na6_g5a_nbl_v2_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE na6_g5a_nbl_v2_mac na6_g5a_nbl_v2_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <hvnmos_na_ga_poly> [
  property W,L
  W = perimeter_coincide(na6_g5a_nbl_v2_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY na6_g5a_nbl_v2_mac L L 0
TRACE PROPERTY na6_g5a_nbl_v2_mac W W 0

LVS DEVICE TYPE LDDNMOS na6_g5a_nbl_v2_mac [D=D G=G S=S]
//LVS REDUCE na6_g5a_nbl_v2_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



ioldnmos_reg_w = ioldnmos_reg COINCIDENT EDGE nxwell
nxwell_ioldnmos_reg = DFM PROPERTY nxwell ioldnmos_reg ioldnmos_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(ioldnmos_reg)] [NW = LENGTH(ioldnmos_reg_w)]
#IFDEF RC_DECK
DEVICE nch_hv5_5vnw_ac ioldnmos_reg nxwell_ioldnmos_reg(D) poly(G) tndiff(S) psub(B) <nthin> <ioldnmos_l> netlist model nch_hv5_5vnw_ac [
  property W,L,AS,AD,PS,PD
  W = (perimeter_coincide(ioldnmos_reg,tndiff) + perimeter_coincide(ioldnmos_reg,nxwell_ioldnmos_reg)) / 2
  L = area(ioldnmos_l) / W
  AW = DFM_NUM_VAL (nxwell_ioldnmos_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_D_OD > 0) {
    AD = (area(nxwell_ioldnmos_reg) * W/AW) //Myron example for divided by ratio of length
    PD = (perimeter(nxwell_ioldnmos_reg) * W/AW) //Myron example for divided by ratio of length
  } ELSE { AD=0 PD=0 }
]
#ELSE

#IFDEF extract_as_ad
DEVICE nch_hv5_5vnw_ac ioldnmos_reg nxwell_ioldnmos_reg(D) poly(G) tndiff(S) psub(B) <nthin> <ioldnmos_l> netlist model nch_hv5_5vnw_ac [
  property W,L,AS,AD
  W = (perimeter_coincide(ioldnmos_reg,tndiff) + perimeter_coincide(ioldnmos_reg,nxwell_ioldnmos_reg)) / 2
  L = area(ioldnmos_l) / W
  AW = DFM_NUM_VAL (nxwell_ioldnmos_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_D_OD > 0) {
    AD = (area(nxwell_ioldnmos_reg) * W/AW) //Myron example for divided by ratio of length
  } ELSE { AD=0 }
]
#ELSE
DEVICE nch_hv5_5vnw_ac ioldnmos_reg nxwell_ioldnmos_reg(D) poly(G) tndiff(S) psub(B) <ioldnmos_l> netlist model nch_hv5_5vnw_ac [
  property W,L
  W = (perimeter_coincide(ioldnmos_reg,tndiff) + perimeter_coincide(ioldnmos_reg,nxwell_ioldnmos_reg)) / 2
  L = area(ioldnmos_l) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nch_hv5_5vnw_ac L L 0
TRACE PROPERTY nch_hv5_5vnw_ac W W 0

nda29_g3a_nbl_cfp_mac_reg_w = nda29_g3a_nbl_cfp_mac_reg COINCIDENT EDGE NDD_no_poly
NDD_nda29_g3a_nbl_cfp_mac_reg = DFM PROPERTY NDD nda29_g3a_nbl_cfp_mac_reg nda29_g3a_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nda29_g3a_nbl_cfp_mac_reg)] [NW = LENGTH(nda29_g3a_nbl_cfp_mac_reg_w)]

#IFDEF RC_DECK

DEVICE nda29_g3a_nbl_cfp_mac nda29_g3a_nbl_cfp_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <NDD_nda29_g3a_nbl_cfp_mac_reg> <nthin> <hvnmos_na_ga_poly> <NBL> netlist model nda29_g3a_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,area_total
  W = perimeter_coincide(nda29_g3a_nbl_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_nda29_g3a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  area_total = AREA(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nda29_g3a_nbl_cfp_mac nda29_g3a_nbl_cfp_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <NDD_nda29_g3a_nbl_cfp_mac_reg> <nthin> <hvnmos_na_ga_poly> netlist model nda29_g3a_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nda29_g3a_nbl_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
  AW = DFM_NUM_VAL (NDD_nda29_g3a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,nthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nda29_g3a_nbl_cfp_mac nda29_g3a_nbl_cfp_mac_reg NDD(D) poly(G) hvndfs(S) hvpsf_shp(B) psub_term_ac(SUB) <hvnmos_na_ga_poly> [
  property W,L
  W = perimeter_coincide(nda29_g3a_nbl_cfp_mac_reg,hvndfs)
  L = area(hvnmos_na_ga_poly) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nda29_g3a_nbl_cfp_mac L L 0
TRACE PROPERTY nda29_g3a_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS nda29_g3a_nbl_cfp_mac [D=D G=G S=S]
//LVS REDUCE nda29_g3a_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


#IFDEF RC_DECK
DEVICE nda45_g3b_nbl_cfp_mac nda45_g3b_nbl_cfp_mac_reg hvndfd_shn(D) poly(G) hvndfs(BS) psub_term_ac(SUB) <NBL> <mdiff> <nda45_g3b_nbl_cfp_mac_aux> <tnpdiff> [
	property W,L,AS,PS,AD,PD,SHNNBLPSUBSHP_AREA,SHNNBLPSUBSHP_PJ,AREA_TOTAL
	W=perimeter_coincide(nda45_g3b_nbl_cfp_mac_reg,hvndfd_shn)
	L=area(nda45_g3b_nbl_cfp_mac_aux)/W
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	PI_D_OD=perimeter_inside(D,mdiff)
	IF(PI_D_OD > 0) {
		AD=area(D)*W/PI_D_OD
		PD=perimeter(D)*W/PI_D_OD
	}ELSE{
		AD=0
		PD=0
	}
	shnnblpsubshp_area=0
	shnnblpsubshp_pj=0
	area_total=area(NBL)
]
#ELSE
#IFDEF extract_as_ad
DEVICE nda45_g3b_nbl_cfp_mac nda45_g3b_nbl_cfp_mac_reg hvndfd_shn(D) poly(G) hvndfs(BS) psub_term_ac(SUB) <NBL> <mdiff> <nda45_g3b_nbl_cfp_mac_aux> <tnpdiff> [
	property W,L,AS,AD,area_total
	W=perimeter_coincide(nda45_g3b_nbl_cfp_mac_reg,hvndfd_shn)
	L=area(nda45_g3b_nbl_cfp_mac_aux)/W
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	PI_D_OD=perimeter_inside(D,mdiff)
	IF(PI_D_OD > 0) {
		AD=area(D)*W/PI_D_OD
	}ELSE{
		AD=0
	}
	area_total=area(NBL)
]
#ELSE
DEVICE nda45_g3b_nbl_cfp_mac nda45_g3b_nbl_cfp_mac_reg hvndfd_shn(D) poly(G) hvndfs(BS) psub_term_ac(SUB) <nda45_g3b_nbl_cfp_mac_aux> [
	property W,L
	W=perimeter_coincide(nda45_g3b_nbl_cfp_mac_reg,hvndfd_shn)
	L=area(nda45_g3b_nbl_cfp_mac_aux)/W
]
TRACE PROPERTY nda45_g3b_nbl_cfp_mac W W 0
TRACE PROPERTY nda45_g3b_nbl_cfp_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDNMOS nda45_g3b_nbl_cfp_mac [D=D G=G S=BS]

sbd_w = EXT schottky_p schottky_n < 0.49 OPPOSITE REGION

DEVICE ndio_sbd_mac sbd_rf_nw_od2 schottky_p(PLUS) schottky_n(MINUS) <sbd_w> [
  property l,w,nf
  nf = count(schottky_p)
  w = perimeter_coincide(schottky_p,sbd_w)/2/nf
  l = area(schottky_p)/(w*nf)
 
]
TRACE PROPERTY ndio_sbd_mac nf nf 0
TRACE PROPERTY ndio_sbd_mac w w 0
TRACE PROPERTY ndio_sbd_mac l l 0


nld12_g5a_cfp_mac_reg_w = hvndfd_ndd COIN EDGE nld12_g5a_cfp_mac_reg
hvndfd_ndd_nld12_g5a_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld12_g5a_cfp_mac_reg nld12_g5a_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld12_g5a_cfp_mac_reg)] [NW = LENGTH(nld12_g5a_cfp_mac_reg_w)]

#IFDEF RC_DECK
DEVICE nld12_g5a_cfp_mac nld12_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld12_g5a_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL
	W=perimeter_coincide(nld12_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld12_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PD=perimeter(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
#IFDEF extract_as_ad
DEVICE nld12_g5a_cfp_mac nld12_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld12_g5a_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(nld12_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld12_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
DEVICE nld12_g5a_cfp_mac nld12_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(nld12_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY nld12_g5a_cfp_mac W W 0
TRACE PROPERTY nld12_g5a_cfp_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDNMOS nld12_g5a_cfp_mac [D=D G=G S=BS]

nld12_g5a_iso_cfp_mac_reg_w = nld12_g5a_iso_cfp_mac_reg COINCIDENT EDGE hvndfd_ndd
hvndfd_ndd_nld12_g5a_iso_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld12_g5a_iso_cfp_mac_reg nld12_g5a_iso_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld12_g5a_iso_cfp_mac_reg)] [NW = LENGTH(nld12_g5a_iso_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE nld12_g5a_iso_cfp_mac nld12_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld12_g5a_iso_cfp_mac_reg> <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld12_g5a_iso_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,AREA_TOTAL
  W = perimeter_coincide(nld12_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld12_g5a_iso_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
    PS = perimeter(BS) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  AREA_TOTAL = area(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld12_g5a_iso_cfp_mac nld12_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld12_g5a_iso_cfp_mac_reg>  <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld12_g5a_iso_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld12_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld12_g5a_iso_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld12_g5a_iso_cfp_mac nld12_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld12_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld12_g5a_iso_cfp_mac L L 0
TRACE PROPERTY nld12_g5a_iso_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS nld12_g5a_iso_cfp_mac [D=D G=G S=BS]
//LVS REDUCE nld12_g5a_iso_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



nld16_g5a_cfp_mac_reg_w = hvndfd_ndd COIN EDGE nld16_g5a_cfp_mac_reg
hvndfd_ndd_nld16_g5a_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld16_g5a_cfp_mac_reg nld16_g5a_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld16_g5a_cfp_mac_reg)] [NW = LENGTH(nld16_g5a_cfp_mac_reg_w)]

#IFDEF RC_DECK
DEVICE nld16_g5a_cfp_mac nld16_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld16_g5a_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL
	W=perimeter_coincide(nld16_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld16_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PD=perimeter(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
#IFDEF extract_as_ad
DEVICE nld16_g5a_cfp_mac nld16_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld16_g5a_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(nld16_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld16_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
DEVICE nld16_g5a_cfp_mac nld16_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(nld16_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY nld16_g5a_cfp_mac W W 0
TRACE PROPERTY nld16_g5a_cfp_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDNMOS nld16_g5a_cfp_mac [D=D G=G S=BS]

nld16_g5a_iso_cfp_mac_reg_w = nld16_g5a_iso_cfp_mac_reg COINCIDENT EDGE hvndfd_ndd
hvndfd_ndd_nld16_g5a_iso_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld16_g5a_iso_cfp_mac_reg nld16_g5a_iso_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld16_g5a_iso_cfp_mac_reg)] [NW = LENGTH(nld16_g5a_iso_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE nld16_g5a_iso_cfp_mac nld16_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld16_g5a_iso_cfp_mac_reg> <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld16_g5a_iso_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,AREA_TOTAL
  W = perimeter_coincide(nld16_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld16_g5a_iso_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
    PS = perimeter(BS) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  AREA_TOTAL = area(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld16_g5a_iso_cfp_mac nld16_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld16_g5a_iso_cfp_mac_reg>  <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld16_g5a_iso_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld16_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld16_g5a_iso_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld16_g5a_iso_cfp_mac nld16_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld16_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld16_g5a_iso_cfp_mac L L 0
TRACE PROPERTY nld16_g5a_iso_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS nld16_g5a_iso_cfp_mac [D=D G=G S=BS]
//LVS REDUCE nld16_g5a_iso_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



nld20_g5a_cfp_mac_reg_w = hvndfd_ndd COIN EDGE nld20_g5a_cfp_mac_reg
hvndfd_ndd_nld20_g5a_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld20_g5a_cfp_mac_reg nld20_g5a_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld20_g5a_cfp_mac_reg)] [NW = LENGTH(nld20_g5a_cfp_mac_reg_w)]

#IFDEF RC_DECK
DEVICE nld20_g5a_cfp_mac nld20_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld20_g5a_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL
	W=perimeter_coincide(nld20_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld20_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PD=perimeter(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
#IFDEF extract_as_ad
DEVICE nld20_g5a_cfp_mac nld20_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld20_g5a_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(nld20_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld20_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
DEVICE nld20_g5a_cfp_mac nld20_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(nld20_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY nld20_g5a_cfp_mac W W 0
TRACE PROPERTY nld20_g5a_cfp_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDNMOS nld20_g5a_cfp_mac [D=D G=G S=BS]

nld20_g5a_iso_cfp_mac_reg_w = nld20_g5a_iso_cfp_mac_reg COINCIDENT EDGE hvndfd_ndd
hvndfd_ndd_nld20_g5a_iso_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld20_g5a_iso_cfp_mac_reg nld20_g5a_iso_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld20_g5a_iso_cfp_mac_reg)] [NW = LENGTH(nld20_g5a_iso_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE nld20_g5a_iso_cfp_mac nld20_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld20_g5a_iso_cfp_mac_reg> <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld20_g5a_iso_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,AREA_TOTAL
  W = perimeter_coincide(nld20_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld20_g5a_iso_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
    PS = perimeter(BS) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  AREA_TOTAL = area(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld20_g5a_iso_cfp_mac nld20_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld20_g5a_iso_cfp_mac_reg>  <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld20_g5a_iso_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld20_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld20_g5a_iso_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld20_g5a_iso_cfp_mac nld20_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld20_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld20_g5a_iso_cfp_mac L L 0
TRACE PROPERTY nld20_g5a_iso_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS nld20_g5a_iso_cfp_mac [D=D G=G S=BS]
//LVS REDUCE nld20_g5a_iso_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



nld24_g5a_cfp_mac_reg_w = hvndfd_ndd COIN EDGE nld24_g5a_cfp_mac_reg
hvndfd_ndd_nld24_g5a_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld24_g5a_cfp_mac_reg nld24_g5a_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld24_g5a_cfp_mac_reg)] [NW = LENGTH(nld24_g5a_cfp_mac_reg_w)]

#IFDEF RC_DECK
DEVICE nld24_g5a_cfp_mac nld24_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld24_g5a_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL
	W=perimeter_coincide(nld24_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld24_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PD=perimeter(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
#IFDEF extract_as_ad
DEVICE nld24_g5a_cfp_mac nld24_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld24_g5a_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(nld24_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld24_g5a_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
DEVICE nld24_g5a_cfp_mac nld24_g5a_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(nld24_g5a_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY nld24_g5a_cfp_mac W W 0
TRACE PROPERTY nld24_g5a_cfp_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDNMOS nld24_g5a_cfp_mac [D=D G=G S=BS]

nld24_g5a_iso_cfp_mac_reg_w = nld24_g5a_iso_cfp_mac_reg COINCIDENT EDGE hvndfd_ndd
hvndfd_ndd_nld24_g5a_iso_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld24_g5a_iso_cfp_mac_reg nld24_g5a_iso_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld24_g5a_iso_cfp_mac_reg)] [NW = LENGTH(nld24_g5a_iso_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE nld24_g5a_iso_cfp_mac nld24_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld24_g5a_iso_cfp_mac_reg> <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld24_g5a_iso_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,AREA_TOTAL
  W = perimeter_coincide(nld24_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld24_g5a_iso_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
    PS = perimeter(BS) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  AREA_TOTAL = area(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld24_g5a_iso_cfp_mac nld24_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld24_g5a_iso_cfp_mac_reg>  <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld24_g5a_iso_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld24_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld24_g5a_iso_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld24_g5a_iso_cfp_mac nld24_g5a_iso_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld24_g5a_iso_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld24_g5a_iso_cfp_mac L L 0
TRACE PROPERTY nld24_g5a_iso_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS nld24_g5a_iso_cfp_mac [D=D G=G S=BS]
//LVS REDUCE nld24_g5a_iso_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


nld24_g5a_iso_switch_cfp_mac_reg_w = nld24_g5a_iso_switch_cfp_mac_reg COINCIDENT EDGE hvndfd_ndd
hvndfd_ndd_nld24_g5a_iso_switch_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld24_g5a_iso_switch_cfp_mac_reg nld24_g5a_iso_switch_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld24_g5a_iso_switch_cfp_mac_reg)] [NW = LENGTH(nld24_g5a_iso_switch_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE nld24_g5a_iso_switch_cfp_mac nld24_g5a_iso_switch_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld24_g5a_iso_switch_cfp_mac_reg> <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld24_g5a_iso_switch_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,AREA_TOTAL
  W = perimeter_coincide(nld24_g5a_iso_switch_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld24_g5a_iso_switch_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
    PS = perimeter(BS) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  AREA_TOTAL = area(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld24_g5a_iso_switch_cfp_mac nld24_g5a_iso_switch_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld24_g5a_iso_switch_cfp_mac_reg>  <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld24_g5a_iso_switch_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld24_g5a_iso_switch_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld24_g5a_iso_switch_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld24_g5a_iso_switch_cfp_mac nld24_g5a_iso_switch_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld24_g5a_iso_switch_cfp_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld24_g5a_iso_switch_cfp_mac L L 0
TRACE PROPERTY nld24_g5a_iso_switch_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS nld24_g5a_iso_switch_cfp_mac [D=D G=G S=BS]
//LVS REDUCE nld24_g5a_iso_switch_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



nld24_g5a_switch_cfp_mac_reg_w = hvndfd_ndd COIN EDGE nld24_g5a_switch_cfp_mac_reg
hvndfd_ndd_nld24_g5a_switch_cfp_mac_reg = DFM PROPERTY hvndfd_ndd nld24_g5a_switch_cfp_mac_reg nld24_g5a_switch_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld24_g5a_switch_cfp_mac_reg)] [NW = LENGTH(nld24_g5a_switch_cfp_mac_reg_w)]

#IFDEF RC_DECK
DEVICE nld24_g5a_switch_cfp_mac nld24_g5a_switch_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld24_g5a_switch_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL
	W=perimeter_coincide(nld24_g5a_switch_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld24_g5a_switch_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PD=perimeter(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
#IFDEF extract_as_ad
DEVICE nld24_g5a_switch_cfp_mac nld24_g5a_switch_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld24_g5a_switch_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(nld24_g5a_switch_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld24_g5a_switch_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
DEVICE nld24_g5a_switch_cfp_mac nld24_g5a_switch_cfp_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(nld24_g5a_switch_cfp_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY nld24_g5a_switch_cfp_mac W W 0
TRACE PROPERTY nld24_g5a_switch_cfp_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDNMOS nld24_g5a_switch_cfp_mac [D=D G=G S=BS]

nld36_g5b_nbl_cfp_mac_reg_w = nld36_g5b_nbl_cfp_mac_reg COINCIDENT EDGE hvndfd_shn
HVNW_nld36_g5b_nbl_cfp_mac_reg = DFM PROPERTY HVNW nld36_g5b_nbl_cfp_mac_reg nld36_g5b_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld36_g5b_nbl_cfp_mac_reg)] [NW = LENGTH(nld36_g5b_nbl_cfp_mac_reg_w)]

#IFDEF RC_DECK

DEVICE nld36_g5b_nbl_cfp_mac nld36_g5b_nbl_cfp_mac_reg hvndfd_shn(D) poly(G) hvndfs(BS) psub_term_ac(SUB) <HVNW_nld36_g5b_nbl_cfp_mac_reg> <HVPW> <hvmos_poly_sti> <hvndfd_shn_area> <NBL> <tnpdiff> <mdiff> netlist model nld36_g5b_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,area_total
  W = perimeter_coincide(nld36_g5b_nbl_cfp_mac_reg,hvndfd_shn)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (HVNW_nld36_g5b_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH()
  PI_S_OD=perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
          AS=area(BS)*W/PI_S_OD
          PS=perimeter(BS)*W/PI_S_OD
  }ELSE{
          AS=0
          PS=0
  }
  AD = (area(hvndfd_shn_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_shn_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  area_total = area(NBL) 
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld36_g5b_nbl_cfp_mac nld36_g5b_nbl_cfp_mac_reg hvndfd_shn(D) poly(G) hvndfs(BS) psub_term_ac(SUB) <HVNW_nld36_g5b_nbl_cfp_mac_reg> <HVPW> <hvmos_poly_sti> <hvndfd_shn_area> <tnpdiff> <mdiff> netlist model nld36_g5b_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld36_g5b_nbl_cfp_mac_reg,hvndfd_shn)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (HVNW_nld36_g5b_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD=perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
          AS=area(BS)*W/PI_S_OD
  }ELSE{
          AS=0
  }
  AD = (area(hvndfd_shn_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld36_g5b_nbl_cfp_mac nld36_g5b_nbl_cfp_mac_reg hvndfd_shn(D) poly(G) hvndfs(BS)  psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld36_g5b_nbl_cfp_mac_reg,hvndfd_shn)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld36_g5b_nbl_cfp_mac L L 0
TRACE PROPERTY nld36_g5b_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS nld36_g5b_nbl_cfp_mac [D=D G=G S=BS]
//LVS REDUCE nld36_g5b_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


nld45_g5b_nbl_cfp_mac_reg_w = nld45_g5b_nbl_cfp_mac_reg COINCIDENT EDGE hvndfd_shn
HVNW_nld45_g5b_nbl_cfp_mac_reg = DFM PROPERTY HVNW nld45_g5b_nbl_cfp_mac_reg nld45_g5b_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld45_g5b_nbl_cfp_mac_reg)] [NW = LENGTH(nld45_g5b_nbl_cfp_mac_reg_w)]

#IFDEF RC_DECK

DEVICE nld45_g5b_nbl_cfp_mac nld45_g5b_nbl_cfp_mac_reg hvndfd_shn(D) poly(G) hvndfs(BS) psub_term_ac(SUB) <HVNW_nld45_g5b_nbl_cfp_mac_reg> <HVPW> <hvmos_poly_sti> <hvndfd_shn_area> <NBL> <tnpdiff> <mdiff> netlist model nld45_g5b_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,area_total
  W = perimeter_coincide(nld45_g5b_nbl_cfp_mac_reg,hvndfd_shn)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (HVNW_nld45_g5b_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH()
  PI_S_OD=perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
          AS=area(BS)*W/PI_S_OD
          PS=perimeter(BS)*W/PI_S_OD
  }ELSE{
          AS=0
          PS=0
  }
  AD = (area(hvndfd_shn_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_shn_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  area_total = area(NBL) 
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld45_g5b_nbl_cfp_mac nld45_g5b_nbl_cfp_mac_reg hvndfd_shn(D) poly(G) hvndfs(BS) psub_term_ac(SUB) <HVNW_nld45_g5b_nbl_cfp_mac_reg> <HVPW> <hvmos_poly_sti> <hvndfd_shn_area> <tnpdiff> <mdiff> netlist model nld45_g5b_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld45_g5b_nbl_cfp_mac_reg,hvndfd_shn)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (HVNW_nld45_g5b_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD=perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
          AS=area(BS)*W/PI_S_OD
  }ELSE{
          AS=0
  }
  AD = (area(hvndfd_shn_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld45_g5b_nbl_cfp_mac nld45_g5b_nbl_cfp_mac_reg hvndfd_shn(D) poly(G) hvndfs(BS)  psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld45_g5b_nbl_cfp_mac_reg,hvndfd_shn)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld45_g5b_nbl_cfp_mac L L 0
TRACE PROPERTY nld45_g5b_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDNMOS nld45_g5b_nbl_cfp_mac [D=D G=G S=BS]
//LVS REDUCE nld45_g5b_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


nld5_g5a_iso_switch_mac_reg_w = nld5_g5a_iso_switch_mac_reg COINCIDENT EDGE hvndfd_ndd
hvndfd_ndd_nld5_g5a_iso_switch_mac_reg = DFM PROPERTY hvndfd_ndd nld5_g5a_iso_switch_mac_reg nld5_g5a_iso_switch_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld5_g5a_iso_switch_mac_reg)] [NW = LENGTH(nld5_g5a_iso_switch_mac_reg_w)]
#IFDEF RC_DECK

DEVICE nld5_g5a_iso_switch_mac nld5_g5a_iso_switch_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld5_g5a_iso_switch_mac_reg> <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld5_g5a_iso_switch_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,AREA_TOTAL
  W = perimeter_coincide(nld5_g5a_iso_switch_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld5_g5a_iso_switch_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
    PS = perimeter(BS) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  AREA_TOTAL = area(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld5_g5a_iso_switch_mac nld5_g5a_iso_switch_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld5_g5a_iso_switch_mac_reg>  <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld5_g5a_iso_switch_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld5_g5a_iso_switch_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld5_g5a_iso_switch_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld5_g5a_iso_switch_mac nld5_g5a_iso_switch_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld5_g5a_iso_switch_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld5_g5a_iso_switch_mac L L 0
TRACE PROPERTY nld5_g5a_iso_switch_mac W W 0

LVS DEVICE TYPE LDDNMOS nld5_g5a_iso_switch_mac [D=D G=G S=BS]
//LVS REDUCE nld5_g5a_iso_switch_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


nld6_g5_de_iso_mac_reg_w = nld6_g5_de_iso_mac_reg COINCIDENT EDGE hvndfd_ndd
hvndfd_ndd_nld6_g5_de_iso_mac_reg = DFM PROPERTY hvndfd_ndd nld6_g5_de_iso_mac_reg nld6_g5_de_iso_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld6_g5_de_iso_mac_reg)] [NW = LENGTH(nld6_g5_de_iso_mac_reg_w)]
#IFDEF RC_DECK

DEVICE nld6_g5a_de_iso_v2_mac nld6_g5_de_iso_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld6_g5_de_iso_mac_reg> <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld6_g5a_de_iso_v2_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,AREA_TOTAL
  W = perimeter_coincide(nld6_g5_de_iso_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld6_g5_de_iso_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
    PS = perimeter(BS) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  AREA_TOTAL = area(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld6_g5a_de_iso_v2_mac nld6_g5_de_iso_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld6_g5_de_iso_mac_reg>  <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld6_g5a_de_iso_v2_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld6_g5_de_iso_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld6_g5_de_iso_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld6_g5a_de_iso_v2_mac nld6_g5_de_iso_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld6_g5_de_iso_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld6_g5a_de_iso_v2_mac L L 0
TRACE PROPERTY nld6_g5a_de_iso_v2_mac W W 0

LVS DEVICE TYPE LDDNMOS nld6_g5a_de_iso_v2_mac [D=D G=G S=BS]
//LVS REDUCE nld6_g5a_de_iso_v2_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



nld6_g5a_de_mac_reg_w = hvndfd_ndd COIN EDGE nld6_g5a_de_mac_reg
hvndfd_ndd_nld6_g5a_de_mac_reg = DFM PROPERTY hvndfd_ndd nld6_g5a_de_mac_reg nld6_g5a_de_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld6_g5a_de_mac_reg)] [NW = LENGTH(nld6_g5a_de_mac_reg_w)]

#IFDEF RC_DECK
DEVICE nld6_g5a_de_mac nld6_g5a_de_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld6_g5a_de_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL
	W=perimeter_coincide(nld6_g5a_de_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld6_g5a_de_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PD=perimeter(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
#IFDEF extract_as_ad
DEVICE nld6_g5a_de_mac nld6_g5a_de_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld6_g5a_de_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(nld6_g5a_de_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld6_g5a_de_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
DEVICE nld6_g5a_de_mac nld6_g5a_de_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(nld6_g5a_de_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY nld6_g5a_de_mac W W 0
TRACE PROPERTY nld6_g5a_de_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDNMOS nld6_g5a_de_mac [D=D G=G S=BS]

nld6_g5_sa_iso_v2_mac_reg_w = nld6_g5_sa_iso_v2_mac_reg COINCIDENT EDGE hvndfd_ndd
hvndfd_ndd_nld6_g5_sa_iso_v2_mac_reg = DFM PROPERTY hvndfd_ndd nld6_g5_sa_iso_v2_mac_reg nld6_g5_sa_iso_v2_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld6_g5_sa_iso_v2_mac_reg)] [NW = LENGTH(nld6_g5_sa_iso_v2_mac_reg_w)]
#IFDEF RC_DECK

DEVICE nld6_g5a_sa_iso_v2_mac nld6_g5_sa_iso_v2_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld6_g5_sa_iso_v2_mac_reg> <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld6_g5a_sa_iso_v2_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,AREA_TOTAL
  W = perimeter_coincide(nld6_g5_sa_iso_v2_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld6_g5_sa_iso_v2_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
    PS = perimeter(BS) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  AREA_TOTAL = area(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld6_g5a_sa_iso_v2_mac nld6_g5_sa_iso_v2_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld6_g5_sa_iso_v2_mac_reg>  <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld6_g5a_sa_iso_v2_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld6_g5_sa_iso_v2_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld6_g5_sa_iso_v2_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld6_g5a_sa_iso_v2_mac nld6_g5_sa_iso_v2_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld6_g5_sa_iso_v2_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld6_g5a_sa_iso_v2_mac L L 0
TRACE PROPERTY nld6_g5a_sa_iso_v2_mac W W 0

LVS DEVICE TYPE LDDNMOS nld6_g5a_sa_iso_v2_mac [D=D G=G S=BS]
//LVS REDUCE nld6_g5a_sa_iso_v2_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



nld6_g5a_sa_mac_reg_w = hvndfd_ndd COIN EDGE nld6_g5a_sa_mac_reg
hvndfd_ndd_nld6_g5a_sa_mac_reg = DFM PROPERTY hvndfd_ndd nld6_g5a_sa_mac_reg nld6_g5a_sa_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld6_g5a_sa_mac_reg)] [NW = LENGTH(nld6_g5a_sa_mac_reg_w)]

#IFDEF RC_DECK
DEVICE nld6_g5a_sa_mac nld6_g5a_sa_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld6_g5a_sa_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL
	W=perimeter_coincide(nld6_g5a_sa_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld6_g5a_sa_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PD=perimeter(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
#IFDEF extract_as_ad
DEVICE nld6_g5a_sa_mac nld6_g5a_sa_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld6_g5a_sa_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(nld6_g5a_sa_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld6_g5a_sa_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
DEVICE nld6_g5a_sa_mac nld6_g5a_sa_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(nld6_g5a_sa_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY nld6_g5a_sa_mac W W 0
TRACE PROPERTY nld6_g5a_sa_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDNMOS nld6_g5a_sa_mac [D=D G=G S=BS]

nld9_g5a_iso_mac_reg_w = nld9_g5a_iso_mac_reg COINCIDENT EDGE hvndfd_ndd
hvndfd_ndd_nld9_g5a_iso_mac_reg = DFM PROPERTY hvndfd_ndd nld9_g5a_iso_mac_reg nld9_g5a_iso_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld9_g5a_iso_mac_reg)] [NW = LENGTH(nld9_g5a_iso_mac_reg_w)]
#IFDEF RC_DECK

DEVICE nld9_g5a_iso_mac nld9_g5a_iso_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld9_g5a_iso_mac_reg> <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld9_g5a_iso_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj,AREA_TOTAL
  W = perimeter_coincide(nld9_g5a_iso_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld9_g5a_iso_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
    PS = perimeter(BS) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  shpnblshn_area = 0
  shpnblshn_pj = 0
  AREA_TOTAL = area(NBL)
]
#ELSE

#IFDEF extract_as_ad
DEVICE nld9_g5a_iso_mac nld9_g5a_iso_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvndfd_ndd_nld9_g5a_iso_mac_reg>  <tnpdiff> <hvmos_poly_sti> <mdiff> <hvndfd_ndd_area> netlist model nld9_g5a_iso_mac [
  property W,L,AS,AD
  W = perimeter_coincide(nld9_g5a_iso_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvndfd_ndd_nld9_g5a_iso_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(tnpdiff,mdiff)
  IF(PI_S_OD > 0) {
    AS = area(BS) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(hvndfd_ndd_area) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE nld9_g5a_iso_mac nld9_g5a_iso_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) NBL(NBL_ISO) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(nld9_g5a_iso_mac_reg,hvndfd_ndd)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY nld9_g5a_iso_mac L L 0
TRACE PROPERTY nld9_g5a_iso_mac W W 0

LVS DEVICE TYPE LDDNMOS nld9_g5a_iso_mac [D=D G=G S=BS]
//LVS REDUCE nld9_g5a_iso_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



nld9_g5a_mac_reg_w = hvndfd_ndd COIN EDGE nld9_g5a_mac_reg
hvndfd_ndd_nld9_g5a_mac_reg = DFM PROPERTY hvndfd_ndd nld9_g5a_mac_reg nld9_g5a_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(nld9_g5a_mac_reg)] [NW = LENGTH(nld9_g5a_mac_reg_w)]

#IFDEF RC_DECK
DEVICE nld9_g5a_mac nld9_g5a_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld9_g5a_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL
	W=perimeter_coincide(nld9_g5a_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld9_g5a_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PD=perimeter(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
#IFDEF extract_as_ad
DEVICE nld9_g5a_mac nld9_g5a_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <NDD> <hvmos_poly_sti> <hvndfd_ndd_area> <hvndfd_ndd_nld9_g5a_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(nld9_g5a_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvndfd_ndd_nld9_g5a_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(hvndfd_ndd_area)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NDD)
]
#ELSE
DEVICE nld9_g5a_mac nld9_g5a_mac_reg hvndfd_ndd(D) poly(G) hvndfs(BS) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(nld9_g5a_mac_reg,hvndfd_ndd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY nld9_g5a_mac W W 0
TRACE PROPERTY nld9_g5a_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDNMOS nld9_g5a_mac [D=D G=G S=BS]

DEVICE nmoscap nthin_var  poly(PLUS) tndiff(MINUS) <vargt> netlist model nmoscap  [
       property wr,lr,mr
       mr = count(vargt)
       lr = (perimeter_coincide(vargt,nthin_var)/mr)/2
       A  = area(vargt)/mr
       wr = A/lr
]       
       TRACE PROPERTY nmoscap lr lr 0
       TRACE PROPERTY nmoscap wr wr 0
       TRACE PROPERTY nmoscap mr mr 0

DEVICE nmoscap_5 nthin_bvar  poly(PLUS) tndiff(MINUS) <bvargt> netlist model nmoscap_5 [
       property wr,lr,mr
       mr = count(bvargt)
       lr = (perimeter_coincide(bvargt,nthin_bvar)/mr)/2
       A  = area(bvargt)/mr
       wr = A/lr
]       
       TRACE PROPERTY nmoscap_5 lr lr 0
       TRACE PROPERTY nmoscap_5 wr wr 0
       TRACE PROPERTY nmoscap_5 mr mr 0

DEVICE nmoscap_5_mis nthin_bvar_mis  poly(PLUS) tndiff(MINUS) <bvargt_mis> netlist model nmoscap_5_mis  [
       property wr,lr,mr
       mr = count(bvargt_mis)
       lr = (perimeter_coincide(bvargt_mis,nthin_bvar_mis)/mr)/2
       A  = area(bvargt_mis)/mr
       wr = A/lr
]       
       TRACE PROPERTY nmoscap_5_mis lr lr 0
       TRACE PROPERTY nmoscap_5_mis wr wr 0
       TRACE PROPERTY nmoscap_5_mis mr mr 0

DEVICE npddshnnbl10_ga_bgr8_7t npddshnnbl10_ga_bgr8_7t_reg hncol_shp_7t_c1(C1) hncol_shp_7t_c8(C8) hvpwbase_7t_ga_b1(B1) hvpwbase_7t_ga_b8(B8) shpemit_7t_e1(E1) shpemit_7t_e8(E8) psub_term_ac(SUB) 

DEVICE npddshnnbl10_ga_poly_4t npddshnnbl_emit10_ga_poly hncol_shp(C) hvpwbase_ga(B) shpemit_poly(E) psub_term_ac(SUB) netlist model npddshnnbl10_ga_poly_4t 

DEVICE npddshnnbl2_ga_poly_4t npddshnnbl_emit2_ga_poly hncol_shp(C) hvpwbase_ga(B) shpemit_poly(E) psub_term_ac(SUB) netlist model npddshnnbl2_ga_poly_4t 

DEVICE npddshnnbl5_ga_poly_4t npddshnnbl_emit5_ga_poly hncol_shp(C) hvpwbase_ga(B) shpemit_poly(E) psub_term_ac(SUB) netlist model npddshnnbl5_ga_poly_4t 

DEVICE npwshnnbl10_ga_bgr8_7t npwshnnbl10_ga_bgr8_7t_reg hncol_shp_7t_c1(C1) hncol_shp_7t_c8(C8) hvpwbase_7t_ga_b1(B1) hvpwbase_7t_ga_b8(B8) shpemit_7t_e1(E1) shpemit_7t_e8(E8) psub_term_ac(SUB) 

DEVICE npwshnnbl10_ga_poly_4t npwshnnbl_emit10_ga_poly hncol_shp(C) hvpwbase_ga(B) shpemit_poly(E) psub_term_ac(SUB) netlist model npwshnnbl10_ga_poly_4t 

DEVICE npwshnnbl2_ga_poly_4t npwshnnbl_emit2_ga_poly hncol_shp(C) hvpwbase_ga(B) shpemit_poly(E) psub_term_ac(SUB) netlist model npwshnnbl2_ga_poly_4t 

DEVICE npwshnnbl5_ga_poly_4t npwshnnbl_emit5_ga_poly hncol_shp(C) hvpwbase_ga(B) shpemit_poly(E) psub_term_ac(SUB) netlist model npwshnnbl5_ga_poly_4t 

#IFDEF extract_parasitic_diodes
DEVICE D(nwdio_5_iso) nwdio_5_iso_reg12 psub_under_ANWEL nxwell <nwdio_5_iso_area> netlist model nwdio_5_iso [
   property a,pj
   a = area(nwdio_5_iso_area)
   pj = perimeter(nwdio_5_iso_area)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(nwdio_5_iso) a a 0
#ENDIF
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(pnwdio_5_iso) nwdio_5_iso_reg3 psub_under_ANWEL nxwell <nwdio_5_iso_area> netlist model nwdio_5_iso [
   property a,pj
   a = area(nwdio_5_iso_area)
   pj = perimeter(nwdio_5_iso_area)
]
LVS FILTER D(pnwdio_5_iso) LAYOUT OPEN
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(nwdio_iso) nwdio_iso_reg12 psub_under_ANWEL nxwell <nwdio_iso_reg> netlist model nwdio_iso [
   property a,pj
   a = area(nwdio_iso_reg)
   pj = perimeter(nwdio_iso_reg)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(nwdio_iso) a a 0
#ENDIF
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(pnwdio_iso) nwdio_iso_reg3 psub_under_ANWEL nxwell <nwdio_iso_reg> netlist model nwdio_iso [
   property a,pj
   a = area(nwdio_iso_reg)
   pj = perimeter(nwdio_iso_reg)
]
LVS FILTER D(pnwdio_iso) LAYOUT OPEN
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(nwdpwshp_dio_5_iso) nwdpwshpdio_5_iso_reg12 psub_under_ANWEL nxwell netlist model nwdpwshp_dio_5_iso [
   property a,pj
   a = area(nwdpwshpdio_5_iso_reg12)
   pj = perimeter(nwdpwshpdio_5_iso_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(nwdpwshp_dio_5_iso) a a 0
#ENDIF
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(nwdpwshp_dio_iso) nwdpwshpdio_iso_reg12 psub_under_ANWEL nxwell netlist model nwdpwshp_dio_iso [
   property a,pj
   a = area(nwdpwshpdio_iso_reg12)
   pj = perimeter(nwdpwshpdio_iso_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(nwdpwshp_dio_iso) a a 0
#ENDIF
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(nwpdddpwshp_dio_5_iso) nwpdddpwshp_dio_5_iso_reg psub_under_ANWEL nxwell netlist model nwpdddpwshp_dio_5_iso [
   property a,pj
   a = area(nwpdddpwshp_dio_5_iso_reg)
   pj = perimeter(nwpdddpwshp_dio_5_iso_reg)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(nwpdddpwshp_dio_5_iso) a a 0
#ENDIF
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(nwpddshp_dio_5_iso) nwpddshp_dio_5_iso_reg psub_under_ANWEL nxwell <nwdio_5_iso_area> netlist model nwpddshp_dio_5_iso [
   property a,pj
   a = area(nwdio_5_iso_area)
   pj = perimeter(nwdio_5_iso_area)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(nwpddshp_dio_5_iso) a a 0
#ENDIF
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(pnwpddshp_dio_5_iso) nwpddshp_dio_5_iso_reg3 psub_under_ANWEL nxwell <nwdio_5_iso_area> netlist model nwpddshp_dio_5_iso [
   property a,pj
   a = area(nwdio_5_iso_area)
   pj = perimeter(nwdio_5_iso_area)
]
LVS FILTER D(pnwpddshp_dio_5_iso) LAYOUT OPEN
#ENDIF


pa12_g5a_nbl_slit_v2_mac_reg_w = hvpdfd_pdd COIN EDGE pa12_g5a_nbl_slit_v2_mac_reg
hvpdfd_pdd_pa12_g5a_nbl_slit_v2_mac_reg = DFM PROPERTY hvpdfd_pdd pa12_g5a_nbl_slit_v2_mac_reg pa12_g5a_nbl_slit_v2_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa12_g5a_nbl_slit_v2_mac_reg)] [NW = LENGTH(pa12_g5a_nbl_slit_v2_mac_reg_w)]

#IFDEF RC_DECK
DEVICE pa12_g5a_nbl_slit_v2_mac pa12_g5a_nbl_slit_v2_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <NBL> <hvmos_poly_sti> <hvpdfd_pdd_pa12_g5a_nbl_slit_v2_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL,SHNNBLPSUBSHP_AREA,SHNNBLPSUBSHP_PJ
	W=perimeter_coincide(pa12_g5a_nbl_slit_v2_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvpdfd_pdd_pa12_g5a_nbl_slit_v2_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(D)*W/AW
	PD=perimeter(D)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NBL)
	SHNNBLPSUBSHP_area=0
	SHNNBLPSUBSHP_pj=0
]
#ELSE
#IFDEF extract_as_ad
DEVICE pa12_g5a_nbl_slit_v2_mac pa12_g5a_nbl_slit_v2_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <NBL> <hvmos_poly_sti> <hvpdfd_pdd_pa12_g5a_nbl_slit_v2_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(pa12_g5a_nbl_slit_v2_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvpdfd_pdd_pa12_g5a_nbl_slit_v2_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(D)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NBL)
]
#ELSE
DEVICE pa12_g5a_nbl_slit_v2_mac pa12_g5a_nbl_slit_v2_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(pa12_g5a_nbl_slit_v2_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY pa12_g5a_nbl_slit_v2_mac W W 0
TRACE PROPERTY pa12_g5a_nbl_slit_v2_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDPMOS pa12_g5a_nbl_slit_v2_mac [D=D G=G S=BS]

pa12_g5a_nbl_v2_mac_reg_w = hvpdfd_pdd INSIDE EDGE pa12_g5a_nbl_v2_mac_reg 
hvpdfd_pdd_pa12_g5a_nbl_v2_mac_reg = DFM PROPERTY hvpdfd_pdd pa12_g5a_nbl_v2_mac_reg pa12_g5a_nbl_v2_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa12_g5a_nbl_v2_mac_reg)] [NW = LENGTH(pa12_g5a_nbl_v2_mac_reg_w)]
#IFDEF RC_DECK

DEVICE pa12_g5a_nbl_v2_mac pa12_g5a_nbl_v2_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_pdd_pa12_g5a_nbl_v2_mac_reg> <pthin> <hvmos_poly_sti> <NBLi> netlist model pa12_g5a_nbl_v2_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,AREA_TOTAL 
  W = perimeter_coincide(pa12_g5a_nbl_v2_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_pdd_pa12_g5a_nbl_v2_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  AREA_TOTAL = area(NBLi)
]
#ELSE

#IFDEF extract_as_ad
DEVICE pa12_g5a_nbl_v2_mac pa12_g5a_nbl_v2_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_pdd_pa12_g5a_nbl_v2_mac_reg> <pthin> <hvmos_poly_sti>  netlist model pa12_g5a_nbl_v2_mac [
  property W,L,AS,AD
  W = perimeter_coincide(pa12_g5a_nbl_v2_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_pdd_pa12_g5a_nbl_v2_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE pa12_g5a_nbl_v2_mac pa12_g5a_nbl_v2_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(pa12_g5a_nbl_v2_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY pa12_g5a_nbl_v2_mac L L 0
TRACE PROPERTY pa12_g5a_nbl_v2_mac W W 0

LVS DEVICE TYPE LDDPMOS pa12_g5a_nbl_v2_mac [D=D G=G S=S]
//LVS REDUCE pa12_g5a_nbl_v2_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


pa16_g5a_nbl_cfp_mac_reg_w = hvpdfd_pdd INSIDE EDGE pa16_g5a_nbl_cfp_mac_reg 
hvpdfd_pdd_pa16_g5a_nbl_cfp_mac_reg = DFM PROPERTY hvpdfd_pdd pa16_g5a_nbl_cfp_mac_reg pa16_g5a_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa16_g5a_nbl_cfp_mac_reg)] [NW = LENGTH(pa16_g5a_nbl_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE pa16_g5a_nbl_cfp_mac pa16_g5a_nbl_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_pdd_pa16_g5a_nbl_cfp_mac_reg> <pthin> <hvmos_poly_sti> <NBLi> netlist model pa16_g5a_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,AREA_TOTAL 
  W = perimeter_coincide(pa16_g5a_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_pdd_pa16_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  AREA_TOTAL = area(NBLi)
]
#ELSE

#IFDEF extract_as_ad
DEVICE pa16_g5a_nbl_cfp_mac pa16_g5a_nbl_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_pdd_pa16_g5a_nbl_cfp_mac_reg> <pthin> <hvmos_poly_sti>  netlist model pa16_g5a_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(pa16_g5a_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_pdd_pa16_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE pa16_g5a_nbl_cfp_mac pa16_g5a_nbl_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(pa16_g5a_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY pa16_g5a_nbl_cfp_mac L L 0
TRACE PROPERTY pa16_g5a_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDPMOS pa16_g5a_nbl_cfp_mac [D=D G=G S=S]
//LVS REDUCE pa16_g5a_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



pa16_g5a_nbl_slit_cfp_mac_reg_w = hvpdfd_pdd COIN EDGE pa16_g5a_nbl_slit_cfp_mac_reg
hvpdfd_pdd_pa16_g5a_nbl_slit_cfp_mac_reg = DFM PROPERTY hvpdfd_pdd pa16_g5a_nbl_slit_cfp_mac_reg pa16_g5a_nbl_slit_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa16_g5a_nbl_slit_cfp_mac_reg)] [NW = LENGTH(pa16_g5a_nbl_slit_cfp_mac_reg_w)]

#IFDEF RC_DECK
DEVICE pa16_g5a_nbl_slit_cfp_mac pa16_g5a_nbl_slit_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <NBL> <hvmos_poly_sti> <hvpdfd_pdd_pa16_g5a_nbl_slit_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL,SHNNBLPSUBSHP_AREA,SHNNBLPSUBSHP_PJ
	W=perimeter_coincide(pa16_g5a_nbl_slit_cfp_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvpdfd_pdd_pa16_g5a_nbl_slit_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(D)*W/AW
	PD=perimeter(D)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NBL)
	SHNNBLPSUBSHP_area=0
	SHNNBLPSUBSHP_pj=0
]
#ELSE
#IFDEF extract_as_ad
DEVICE pa16_g5a_nbl_slit_cfp_mac pa16_g5a_nbl_slit_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <NBL> <hvmos_poly_sti> <hvpdfd_pdd_pa16_g5a_nbl_slit_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(pa16_g5a_nbl_slit_cfp_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvpdfd_pdd_pa16_g5a_nbl_slit_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(D)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NBL)
]
#ELSE
DEVICE pa16_g5a_nbl_slit_cfp_mac pa16_g5a_nbl_slit_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(pa16_g5a_nbl_slit_cfp_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY pa16_g5a_nbl_slit_cfp_mac W W 0
TRACE PROPERTY pa16_g5a_nbl_slit_cfp_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDPMOS pa16_g5a_nbl_slit_cfp_mac [D=D G=G S=BS]

pa20_g5a_nbl_cfp_mac_reg_w = hvpdfd_pdd INSIDE EDGE pa20_g5a_nbl_cfp_mac_reg 
hvpdfd_pdd_pa20_g5a_nbl_cfp_mac_reg = DFM PROPERTY hvpdfd_pdd pa20_g5a_nbl_cfp_mac_reg pa20_g5a_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa20_g5a_nbl_cfp_mac_reg)] [NW = LENGTH(pa20_g5a_nbl_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE pa20_g5a_nbl_cfp_mac pa20_g5a_nbl_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_pdd_pa20_g5a_nbl_cfp_mac_reg> <pthin> <hvmos_poly_sti> <NBLi> netlist model pa20_g5a_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,AREA_TOTAL 
  W = perimeter_coincide(pa20_g5a_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_pdd_pa20_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  AREA_TOTAL = area(NBLi)
]
#ELSE

#IFDEF extract_as_ad
DEVICE pa20_g5a_nbl_cfp_mac pa20_g5a_nbl_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_pdd_pa20_g5a_nbl_cfp_mac_reg> <pthin> <hvmos_poly_sti>  netlist model pa20_g5a_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(pa20_g5a_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_pdd_pa20_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE pa20_g5a_nbl_cfp_mac pa20_g5a_nbl_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(pa20_g5a_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY pa20_g5a_nbl_cfp_mac L L 0
TRACE PROPERTY pa20_g5a_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDPMOS pa20_g5a_nbl_cfp_mac [D=D G=G S=S]
//LVS REDUCE pa20_g5a_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



pa20_g5a_nbl_slit_cfp_mac_reg_w = hvpdfd_pdd COIN EDGE pa20_g5a_nbl_slit_cfp_mac_reg
hvpdfd_pdd_pa20_g5a_nbl_slit_cfp_mac_reg = DFM PROPERTY hvpdfd_pdd pa20_g5a_nbl_slit_cfp_mac_reg pa20_g5a_nbl_slit_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa20_g5a_nbl_slit_cfp_mac_reg)] [NW = LENGTH(pa20_g5a_nbl_slit_cfp_mac_reg_w)]

#IFDEF RC_DECK
DEVICE pa20_g5a_nbl_slit_cfp_mac pa20_g5a_nbl_slit_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <NBL> <hvmos_poly_sti> <hvpdfd_pdd_pa20_g5a_nbl_slit_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL,SHNNBLPSUBSHP_AREA,SHNNBLPSUBSHP_PJ
	W=perimeter_coincide(pa20_g5a_nbl_slit_cfp_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvpdfd_pdd_pa20_g5a_nbl_slit_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(D)*W/AW
	PD=perimeter(D)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NBL)
	SHNNBLPSUBSHP_area=0
	SHNNBLPSUBSHP_pj=0
]
#ELSE
#IFDEF extract_as_ad
DEVICE pa20_g5a_nbl_slit_cfp_mac pa20_g5a_nbl_slit_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <NBL> <hvmos_poly_sti> <hvpdfd_pdd_pa20_g5a_nbl_slit_cfp_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(pa20_g5a_nbl_slit_cfp_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvpdfd_pdd_pa20_g5a_nbl_slit_cfp_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(D)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NBL)
]
#ELSE
DEVICE pa20_g5a_nbl_slit_cfp_mac pa20_g5a_nbl_slit_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(pa20_g5a_nbl_slit_cfp_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY pa20_g5a_nbl_slit_cfp_mac W W 0
TRACE PROPERTY pa20_g5a_nbl_slit_cfp_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDPMOS pa20_g5a_nbl_slit_cfp_mac [D=D G=G S=BS]

pa29_g5a_nbl_cfp_mac_reg_w = PDD_WOSHN COINCIDENT EDGE pa29_g5a_nbl_cfp_mac_reg 
PDD_WOSHN_pa29_g5a_nbl_cfp_mac_reg = DFM PROPERTY PDD_WOSHN pa29_g5a_nbl_cfp_mac_reg pa29_g5a_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa29_g5a_nbl_cfp_mac_reg)] [NW = LENGTH(pa29_g5a_nbl_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE pa29_g5a_nbl_cfp_mac pa29_g5a_nbl_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <PDD_WOSHN_pa29_g5a_nbl_cfp_mac_reg> <pthin> <PDD_WOSHN> <hvmos_poly_sti> <NBLi> netlist model pa29_g5a_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,AREA_TOTAL 
  W = perimeter_coincide(pa29_g5a_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (PDD_WOSHN_pa29_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(PDD_WOSHN) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(PDD_WOSHN) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  AREA_TOTAL = area(NBLi)
]
#ELSE

#IFDEF extract_as_ad
DEVICE pa29_g5a_nbl_cfp_mac pa29_g5a_nbl_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <PDD_WOSHN_pa29_g5a_nbl_cfp_mac_reg> <pthin> <PDD_WOSHN> <hvmos_poly_sti>  netlist model pa29_g5a_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(pa29_g5a_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (PDD_WOSHN_pa29_g5a_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(PDD_WOSHN) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE pa29_g5a_nbl_cfp_mac pa29_g5a_nbl_cfp_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(pa29_g5a_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY pa29_g5a_nbl_cfp_mac L L 0
TRACE PROPERTY pa29_g5a_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDPMOS pa29_g5a_nbl_cfp_mac [D=D G=G S=S]
//LVS REDUCE pa29_g5a_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


pa36_g5b_nbl_cfp_mac_reg_w = HVPW INSIDE EDGE pa36_g5b_nbl_cfp_mac_reg 
HVPW_pa36_g5b_nbl_cfp_mac_reg = DFM PROPERTY HVPW pa36_g5b_nbl_cfp_mac_reg pa36_g5b_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa36_g5b_nbl_cfp_mac_reg)] [NW = LENGTH(pa36_g5b_nbl_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE pa36_g5b_nbl_cfp_mac pa36_g5b_nbl_cfp_mac_reg HVPW(D) poly(G) hvpdfs(S) NBL(B) psub_term_ac(SUB) <HVPW_pa36_g5b_nbl_cfp_mac_reg> <pthin> <hvmos_poly_sti> netlist model pa36_g5b_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,area_total
  W = perimeter_coincide(pa36_g5b_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (HVPW_pa36_g5b_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  area_total=AREA(NBL) 
]
#ELSE

#IFDEF extract_as_ad
DEVICE pa36_g5b_nbl_cfp_mac pa36_g5b_nbl_cfp_mac_reg HVPW(D) poly(G) hvpdfs(S) NBL(B) psub_term_ac(SUB) <HVPW_pa36_g5b_nbl_cfp_mac_reg> <pthin> <hvmos_poly_sti> netlist model pa36_g5b_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(pa36_g5b_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (HVPW_pa36_g5b_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE pa36_g5b_nbl_cfp_mac pa36_g5b_nbl_cfp_mac_reg HVPW(D) poly(G) hvpdfs(S) NBL(B) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(pa36_g5b_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY pa36_g5b_nbl_cfp_mac L L 0
TRACE PROPERTY pa36_g5b_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDPMOS pa36_g5b_nbl_cfp_mac [D=D G=G S=S]
//LVS REDUCE pa36_g5b_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


pa45_g5b_nbl_cfp_mac_reg_w = HVPW INSIDE EDGE pa45_g5b_nbl_cfp_mac_reg 
HVPW_pa45_g5b_nbl_cfp_mac_reg = DFM PROPERTY HVPW pa45_g5b_nbl_cfp_mac_reg pa45_g5b_nbl_cfp_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa45_g5b_nbl_cfp_mac_reg)] [NW = LENGTH(pa45_g5b_nbl_cfp_mac_reg_w)]
#IFDEF RC_DECK

DEVICE pa45_g5b_nbl_cfp_mac pa45_g5b_nbl_cfp_mac_reg HVPW(D) poly(G) hvpdfs(S) NBL(B) psub_term_ac(SUB) <HVPW_pa45_g5b_nbl_cfp_mac_reg> <pthin> <hvmos_poly_sti> netlist model pa45_g5b_nbl_cfp_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,area_total
  W = perimeter_coincide(pa45_g5b_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (HVPW_pa45_g5b_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  area_total=AREA(NBL) 
]
#ELSE

#IFDEF extract_as_ad
DEVICE pa45_g5b_nbl_cfp_mac pa45_g5b_nbl_cfp_mac_reg HVPW(D) poly(G) hvpdfs(S) NBL(B) psub_term_ac(SUB) <HVPW_pa45_g5b_nbl_cfp_mac_reg> <pthin> <hvmos_poly_sti> netlist model pa45_g5b_nbl_cfp_mac [
  property W,L,AS,AD
  W = perimeter_coincide(pa45_g5b_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (HVPW_pa45_g5b_nbl_cfp_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE pa45_g5b_nbl_cfp_mac pa45_g5b_nbl_cfp_mac_reg HVPW(D) poly(G) hvpdfs(S) NBL(B) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(pa45_g5b_nbl_cfp_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY pa45_g5b_nbl_cfp_mac L L 0
TRACE PROPERTY pa45_g5b_nbl_cfp_mac W W 0

LVS DEVICE TYPE LDDPMOS pa45_g5b_nbl_cfp_mac [D=D G=G S=S]
//LVS REDUCE pa45_g5b_nbl_cfp_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


pa6_g5_de_nbl_mac_reg_w = hvpdfd_shp INSIDE EDGE pa6_g5_de_nbl_mac_reg 
hvpdfd_shp_pa6_g5_de_nbl_mac_reg = DFM PROPERTY hvpdfd_shp pa6_g5_de_nbl_mac_reg pa6_g5_de_nbl_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa6_g5_de_nbl_mac_reg)] [NW = LENGTH(pa6_g5_de_nbl_mac_reg_w)]
#IFDEF RC_DECK

DEVICE pa6_g5a_de_nbl_v2_mac pa6_g5_de_nbl_mac_reg hvpdfd_shp(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_shp_pa6_g5_de_nbl_mac_reg> <pthin> <hvmos_poly_sti> <HVPW> <NBLi> netlist model pa6_g5a_de_nbl_v2_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,AREA_TOTAL 
  W = perimeter_coincide(pa6_g5_de_nbl_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_shp_pa6_g5_de_nbl_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(HVPW) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(HVPW) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  AREA_TOTAL = area(NBLi)
]
#ELSE

#IFDEF extract_as_ad
DEVICE pa6_g5a_de_nbl_v2_mac pa6_g5_de_nbl_mac_reg hvpdfd_shp(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_shp_pa6_g5_de_nbl_mac_reg> <pthin> <hvmos_poly_sti> <HVPW> netlist model pa6_g5a_de_nbl_v2_mac [
  property W,L,AS,AD
  W = perimeter_coincide(pa6_g5_de_nbl_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_shp_pa6_g5_de_nbl_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(HVPW) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE pa6_g5a_de_nbl_v2_mac pa6_g5_de_nbl_mac_reg hvpdfd_shp(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(pa6_g5_de_nbl_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY pa6_g5a_de_nbl_v2_mac L L 0
TRACE PROPERTY pa6_g5a_de_nbl_v2_mac W W 0

LVS DEVICE TYPE LDDPMOS pa6_g5a_de_nbl_v2_mac [D=D G=G S=S]
//LVS REDUCE pa6_g5a_de_nbl_v2_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


pa6_g5_sa_nbl_mac_reg_w = hvpdfd_shp INSIDE EDGE pa6_g5_sa_nbl_mac_reg 
hvpdfd_shp_pa6_g5_sa_nbl_mac_reg = DFM PROPERTY hvpdfd_shp pa6_g5_sa_nbl_mac_reg pa6_g5_sa_nbl_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa6_g5_sa_nbl_mac_reg)] [NW = LENGTH(pa6_g5_sa_nbl_mac_reg_w)]
#IFDEF RC_DECK

DEVICE pa6_g5a_sa_nbl_v2_mac pa6_g5_sa_nbl_mac_reg hvpdfd_shp(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_shp_pa6_g5_sa_nbl_mac_reg> <pthin> <hvmos_poly_sti> <HVPW> <NBLi> netlist model pa6_g5a_sa_nbl_v2_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,AREA_TOTAL 
  W = perimeter_coincide(pa6_g5_sa_nbl_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_shp_pa6_g5_sa_nbl_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(HVPW) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(HVPW) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  AREA_TOTAL = area(NBLi)
]
#ELSE

#IFDEF extract_as_ad
DEVICE pa6_g5a_sa_nbl_v2_mac pa6_g5_sa_nbl_mac_reg hvpdfd_shp(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_shp_pa6_g5_sa_nbl_mac_reg> <pthin> <hvmos_poly_sti> <HVPW> netlist model pa6_g5a_sa_nbl_v2_mac [
  property W,L,AS,AD
  W = perimeter_coincide(pa6_g5_sa_nbl_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_shp_pa6_g5_sa_nbl_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(HVPW) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE pa6_g5a_sa_nbl_v2_mac pa6_g5_sa_nbl_mac_reg hvpdfd_shp(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(pa6_g5_sa_nbl_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY pa6_g5a_sa_nbl_v2_mac L L 0
TRACE PROPERTY pa6_g5a_sa_nbl_v2_mac W W 0

LVS DEVICE TYPE LDDPMOS pa6_g5a_sa_nbl_v2_mac [D=D G=G S=S]
//LVS REDUCE pa6_g5a_sa_nbl_v2_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]


pa9_g5a_nbl_mac_reg_w = hvpdfd_pdd INSIDE EDGE pa9_g5a_nbl_mac_reg 
hvpdfd_pdd_pa9_g5a_nbl_mac_reg = DFM PROPERTY hvpdfd_pdd pa9_g5a_nbl_mac_reg pa9_g5a_nbl_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa9_g5a_nbl_mac_reg)] [NW = LENGTH(pa9_g5a_nbl_mac_reg_w)]
#IFDEF RC_DECK

DEVICE pa9_g5a_nbl_mac pa9_g5a_nbl_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_pdd_pa9_g5a_nbl_mac_reg> <pthin> <hvmos_poly_sti> <NBLi> netlist model pa9_g5a_nbl_mac [
  property W,L,AS,AD,PS,PD,shnnblpsubshp_area,shnnblpsubshp_pj,AREA_TOTAL 
  W = perimeter_coincide(pa9_g5a_nbl_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_pdd_pa9_g5a_nbl_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
    PS = perimeter(S) * W /PI_S_OD
  } ELSE { AS=0 PS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
  PD = (perimeter(D) * W/AW) //Myron example for divided by ratio of length
  shnnblpsubshp_area = 0
  shnnblpsubshp_pj = 0
  AREA_TOTAL = area(NBLi)
]
#ELSE

#IFDEF extract_as_ad
DEVICE pa9_g5a_nbl_mac pa9_g5a_nbl_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvpdfd_pdd_pa9_g5a_nbl_mac_reg> <pthin> <hvmos_poly_sti>  netlist model pa9_g5a_nbl_mac [
  property W,L,AS,AD
  W = perimeter_coincide(pa9_g5a_nbl_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
  AW = DFM_NUM_VAL (hvpdfd_pdd_pa9_g5a_nbl_mac_reg,"NW") * UNIT_LENGTH() 
  PI_S_OD = perimeter_inside(S,pthin)
  IF(PI_S_OD > 0) {
    AS = area(S) * W /PI_S_OD
  } ELSE { AS=0 }
  AD = (area(D) * W/AW) //Myron example for divided by ratio of length
]
#ELSE
DEVICE pa9_g5a_nbl_mac pa9_g5a_nbl_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(S) SH_N(B) psub_term_ac(SUB) <hvmos_poly_sti> [
  property W,L
  W = perimeter_coincide(pa9_g5a_nbl_mac_reg,hvpdfs)
  L = area(hvmos_poly_sti) / W
]
#ENDIF
#ENDIF

TRACE PROPERTY pa9_g5a_nbl_mac L L 0
TRACE PROPERTY pa9_g5a_nbl_mac W W 0

LVS DEVICE TYPE LDDPMOS pa9_g5a_nbl_mac [D=D G=G S=S]
//LVS REDUCE pa9_g5a_nbl_mac PARALLEL YES 
//[  
//   EFFECTIVE w,l
//   P = sum( W * L )  // Sum of Wi * Li 
//   Q = sum( W / L )  // Sum of Wi / Li 
//   W = sqrt( P * Q ) // Effective W 
//   L = sqrt( P / Q ) // Effective L 
//]



pa9_g5a_nbl_slit_mac_reg_w = hvpdfd_pdd COIN EDGE pa9_g5a_nbl_slit_mac_reg
hvpdfd_pdd_pa9_g5a_nbl_slit_mac_reg = DFM PROPERTY hvpdfd_pdd pa9_g5a_nbl_slit_mac_reg pa9_g5a_nbl_slit_mac_reg_w OVERLAP ABUT ALSO MULTI [ NG = COUNT(pa9_g5a_nbl_slit_mac_reg)] [NW = LENGTH(pa9_g5a_nbl_slit_mac_reg_w)]

#IFDEF RC_DECK
DEVICE pa9_g5a_nbl_slit_mac pa9_g5a_nbl_slit_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <NBL> <hvmos_poly_sti> <hvpdfd_pdd_pa9_g5a_nbl_slit_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,PD,AS,PS,AREA_TOTAL,SHNNBLPSUBSHP_AREA,SHNNBLPSUBSHP_PJ
	W=perimeter_coincide(pa9_g5a_nbl_slit_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvpdfd_pdd_pa9_g5a_nbl_slit_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(D)*W/AW
	PD=perimeter(D)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	AREA_TOTAL=area(NBL)
	SHNNBLPSUBSHP_area=0
	SHNNBLPSUBSHP_pj=0
]
#ELSE
#IFDEF extract_as_ad
DEVICE pa9_g5a_nbl_slit_mac pa9_g5a_nbl_slit_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <NBL> <hvmos_poly_sti> <hvpdfd_pdd_pa9_g5a_nbl_slit_mac_reg> <mdiff> <tnpdiff> [
	property W,L,AD,AS,AREA_TOTAL
	W=perimeter_coincide(pa9_g5a_nbl_slit_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
	AW=DFM_NUM_VAL(hvpdfd_pdd_pa9_g5a_nbl_slit_mac_reg,"NW") * UNIT_LENGTH()
	AD=area(D)*W/AW
	PI_S_OD=perimeter_inside(tnpdiff,mdiff)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
	AREA_TOTAL=area(NBL)
]
#ELSE
DEVICE pa9_g5a_nbl_slit_mac pa9_g5a_nbl_slit_mac_reg hvpdfd_pdd(D) poly(G) hvpdfs(BS) psub_term_ac(SUB) <hvmos_poly_sti> [
	property W,L
	W=perimeter_coincide(pa9_g5a_nbl_slit_mac_reg,hvpdfd_pdd)
	L=area(hvmos_poly_sti)/W
]
TRACE PROPERTY pa9_g5a_nbl_slit_mac W W 0
TRACE PROPERTY pa9_g5a_nbl_slit_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDPMOS pa9_g5a_nbl_slit_mac [D=D G=G S=BS]

#IFDEF RC_DECK
DEVICE pbhvnwshnnbl_esd_dio_shp_gb_3t pbhvnwshnnbl_esd tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(pbhvnwshnnbl_esd)/2.0e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pbhvnwshnnbl_esd_dio_shp_gb_3t pbhvnwshnnbl_esd tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l
    l = area(pbhvnwshnnbl_esd)/2.0e-6
]
#ENDIF
TRACE PROPERTY pbhvnwshnnbl_esd_dio_shp_gb_3t l l 0

#IFDEF RC_DECK
DEVICE pbshnnbl_dio_shp_ga_3t pbshnnbl_dio_shp_ga_3t_reg tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property area,pj,shnnblpsubshp_area,shnnblpsubshp_pj
    area = area(pbshnnbl_dio_shp_ga_3t_reg)
    pj = perimeter(pbshnnbl_dio_shp_ga_3t_reg)
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pbshnnbl_dio_shp_ga_3t pbshnnbl_dio_shp_ga_3t_reg tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property area,pj
    area = area(pbshnnbl_dio_shp_ga_3t_reg)
    pj = perimeter(pbshnnbl_dio_shp_ga_3t_reg)
]
#ENDIF
TRACE PROPERTY pbshnnbl_dio_shp_ga_3t "area" "area" 0
LVS DEVICE TYPE DIODE pbshnnbl_dio_shp_ga_3t [POS=PLUS NEG=MINUS]
LVS REDUCE pbshnnbl_dio_shp_ga_3t PARALLEL YES 
[  
   EFFECTIVE area
   area = sum( area )  
]

#IFDEF RC_DECK
DEVICE pch5_as_switch_mac pch5_as_sw_reg tpdiff(D) poly(G) tpdiff_s(BS) psub_term_ac(SUB) <pthin> [
	property W,L,AD,PD,AS,PS,SHNNBLPSUBSHP_AREA,SHNNBLPSUBSHP_PJ
	W=perimeter_coincide(pch5_as_sw_reg,tpdiff)
	L=area(pch5_as_sw_reg)/W
	PI_D_OD=perimeter_inside(tpdiff,pthin)
	IF(PI_D_OD > 0) {
		AD=area(D)*W/PI_D_OD
		PD=perimeter(D)*W/PI_D_OD
	}ELSE{
		AD=0
		PD=0
	}
	PI_S_OD=perimeter_inside(tpdiff_s,pthin)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
		PS=perimeter(BS)*W/PI_S_OD
	}ELSE{
		AS=0
		PS=0
	}
	shnnblpsubshp_area=0
	shnnblpsubshp_pj=0
]
#ELSE
#IFDEF extract_as_ad
DEVICE pch5_as_switch_mac pch5_as_sw_reg tpdiff(D) poly(G) tpdiff_s(BS) psub_term_ac(SUB) <pthin> [
	property W,L,AD,AS
	W=perimeter_coincide(pch5_as_sw_reg,tpdiff)
	L=area(pch5_as_sw_reg)/W
	PI_D_OD=perimeter_inside(tpdiff,pthin)
	IF(PI_D_OD > 0) {
		AD=area(D)*W/PI_D_OD
	}ELSE{
		AD=0
	}
	PI_S_OD=perimeter_inside(tpdiff_s,pthin)
	IF(PI_S_OD > 0) {
		AS=area(BS)*W/PI_S_OD
	}ELSE{
		AS=0
	}
]
#ELSE
DEVICE pch5_as_switch_mac pch5_as_sw_reg tpdiff(D) poly(G) tpdiff_s(BS) psub_term_ac(SUB) [
	property W,L
	W=perimeter_coincide(pch5_as_sw_reg,tpdiff)
	L=area(pch5_as_sw_reg)/W
]
TRACE PROPERTY pch5_as_switch_mac W W 0
TRACE PROPERTY pch5_as_switch_mac L L 0
#ENDIF
#ENDIF
LVS DEVICE TYPE LDDPMOS pch5_as_switch_mac [D=D G=G S=BS]

#IFDEF RC_DECK
DEVICE pddshnnbl_dio_shp_ga_3t pddshnnbl_dio_3t_reg tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <PDD> [
    property area,pj,shnnblpsubshp_area,shnnblpsubshp_pj
    area = area(PDD)
    pj = perimeter(PDD)
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pddshnnbl_dio_shp_ga_3t pddshnnbl_dio_3t_reg tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <PDD> [
    property area,pj
    area = area(PDD)
    pj = perimeter(PDD)
]
#ENDIF
TRACE PROPERTY pddshnnbl_dio_shp_ga_3t "area" "area" 0
LVS DEVICE TYPE DIODE pddshnnbl_dio_shp_ga_3t [POS=PLUS NEG=MINUS]
LVS REDUCE pddshnnbl_dio_shp_ga_3t PARALLEL YES 
[  
   EFFECTIVE area
   area = sum( area )  
]

#IFDEF RC_DECK
DEVICE pdio_esd_ga_12_pdd_3t esd_ga_12_pdd_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <esd_3tdio_rpo_auxi> [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(esd_3tdio_rpo_auxi)/1.02e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pdio_esd_ga_12_pdd_3t esd_ga_12_pdd_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <esd_3tdio_rpo_auxi> [
    property l
    l = area(esd_3tdio_rpo_auxi)/1.02e-6
]
#ENDIF
TRACE PROPERTY pdio_esd_ga_12_pdd_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_ga_12_v4_3t esd_ga_12_v4_3t_reg stack_esd_plus(PLUS) stack_esd_minus(MINUS) psub_term_ac(SUB) <esd_ga_12_v4_3t> [
    property multi,l,shnnblpsubshp_area,shnnblpsubshp_pj
    multi = count(esd_ga_12_v4_3t)
    l_all = area(esd_ga_12_v4_3t)/0.46e-6
    l = l_all/multi
    shnnblpsubshp_area = area(stack_esd_minus)/multi
    shnnblpsubshp_pj = perimeter(stack_esd_minus)/multi
]
#ELSE
DEVICE pdio_esd_ga_12_v4_3t esd_ga_12_v4_3t_reg stack_esd_plus(PLUS) stack_esd_minus(MINUS) psub_term_ac(SUB) <esd_ga_12_v4_3t> [
    property multi,l
    multi = count(esd_ga_12_v4_3t)
    l_all = area(esd_ga_12_v4_3t)/0.46e-6
    l = l_all/multi
]
#ENDIF
TRACE PROPERTY pdio_esd_ga_12_v4_3t multi multi 0
TRACE PROPERTY pdio_esd_ga_12_v4_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_ga_16_v3_3t esd_ga_16_v3_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <esd_3tdio_rpo_auxi> [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(esd_3tdio_rpo_auxi)/1.02e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pdio_esd_ga_16_v3_3t esd_ga_16_v3_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <esd_3tdio_rpo_auxi> [
    property l
    l = area(esd_3tdio_rpo_auxi)/1.02e-6
]
#ENDIF
TRACE PROPERTY pdio_esd_ga_16_v3_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_ga_20_pdd_3t esd_ga_20_pdd_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <esd_3tdio_rpo_auxi> [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(esd_3tdio_rpo_auxi)/1.02e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pdio_esd_ga_20_pdd_3t esd_ga_20_pdd_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <esd_3tdio_rpo_auxi> [
    property l
    l = area(esd_3tdio_rpo_auxi)/1.02e-6
]
#ENDIF
TRACE PROPERTY pdio_esd_ga_20_pdd_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_ga_20_v3_3t esd_ga_20_v2_3t_reg stack_esd_plus(PLUS) stack_esd_minus(MINUS) psub_term_ac(SUB) <pdio_esd_ga_20_v3_3t_aux> <esd_ga_20_v2_3t> [
    property multi,l,shnnblpsubshp_area,shnnblpsubshp_pj
    multi = count(esd_ga_20_v2_3t)
    l_all = area(pdio_esd_ga_20_v3_3t_aux)/1.02e-6
    l = l_all/multi
    shnnblpsubshp_area = area(stack_esd_minus)/multi
    shnnblpsubshp_pj = perimeter(stack_esd_minus)/multi
]
#ELSE
DEVICE pdio_esd_ga_20_v3_3t esd_ga_20_v2_3t_reg stack_esd_plus(PLUS) stack_esd_minus(MINUS) psub_term_ac(SUB) <pdio_esd_ga_20_v3_3t_aux> <esd_ga_20_v2_3t> [
    property multi,l
    multi = count(esd_ga_20_v2_3t)
    l_all = area(pdio_esd_ga_20_v3_3t_aux)/1.02e-6
    l = l_all/multi
]
#ENDIF
TRACE PROPERTY pdio_esd_ga_20_v3_3t multi multi 0
TRACE PROPERTY pdio_esd_ga_20_v3_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_ga_24_v3_3t esd_ga_24_v2_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <esd_3tdio_rpo_auxi> [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(esd_3tdio_rpo_auxi)/1.02e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pdio_esd_ga_24_v3_3t esd_ga_24_v2_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <esd_3tdio_rpo_auxi> [
    property l
    l = area(esd_3tdio_rpo_auxi)/1.02e-6
]
#ENDIF
TRACE PROPERTY pdio_esd_ga_24_v3_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_ga_29_v3_3t esd_ga_29_v2_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(esd_ga_29_v2_3t)/0.46e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pdio_esd_ga_29_v3_3t esd_ga_29_v2_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l
    l = area(esd_ga_29_v2_3t)/0.46e-6
]
#ENDIF
TRACE PROPERTY pdio_esd_ga_29_v3_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_ga_6_v3_3t esd_ga_6_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(esd_ga_6_3t)/0.46e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pdio_esd_ga_6_v3_3t esd_ga_6_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l
    l = area(esd_ga_6_3t)/0.46e-6
]
#ENDIF
TRACE PROPERTY pdio_esd_ga_6_v3_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_ga_9_v3_3t esd_ga_9_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(esd_ga_9_3t)/0.46e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pdio_esd_ga_9_v3_3t esd_ga_9_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l
    l = area(esd_ga_9_3t)/0.46e-6
]
#ENDIF
TRACE PROPERTY pdio_esd_ga_9_v3_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_gb_36_3t esd_gb_36_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(esd_gb_36_3t)/2.0e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pdio_esd_gb_36_3t esd_gb_36_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l
    l = area(esd_gb_36_3t)/2.0e-6
]
#ENDIF
TRACE PROPERTY pdio_esd_gb_36_3t l l 0

#IFDEF RC_DECK
DEVICE pdio_esd_gb_45_cit_v3_3t esd_gb_45_cit_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(esd_gb_45_cit_3t)/2.0e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE pdio_esd_gb_45_cit_v3_3t esd_gb_45_cit_3t tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l
    l = area(esd_gb_45_cit_3t)/2.0e-6
]
#ENDIF
TRACE PROPERTY pdio_esd_gb_45_cit_v3_3t l l 0

DEVICE phvnwpsub10_gb_poly phnpsub_emit10_gb_poly phvnwcol(C) phvnwbase(B) phvnwemit(E) netlist model phvnwpsub10_gb_poly

DEVICE phvnwpsub2_gb_poly phnpsub_emit2_gb_poly phvnwcol(C) phvnwbase(B) phvnwemit(E) netlist model phvnwpsub2_gb_poly

DEVICE phvnwpsub5_gb_poly phnpsub_emit5_gb_poly phvnwcol(C) phvnwbase(B) phvnwemit(E) netlist model phvnwpsub5_gb_poly

DEVICE pnddpsub10_ga_poly pnddpsub_emit10_ga_poly nddcol(C) nddbase(B) nddemit(E) netlist model pnddpsub10_ga_poly

DEVICE pnddpsub2_ga_poly pnddpsub_emit2_ga_poly nddcol(C) nddbase(B) nddemit(E) netlist model pnddpsub2_ga_poly

DEVICE pnddpsub5_ga_poly pnddpsub_emit5_ga_poly nddcol(C) nddbase(B) nddemit(E) netlist model pnddpsub5_ga_poly

DEVICE pnddshp5_nbl_ga_4t pnddshp5_nbl_ga_4t_reg nddcol(C) NBL(B) nddemit(E) psub_term_ac(SUB) netlist model pnddshp5_nbl_ga_4t 

#IFDEF RC_DECK
DEVICE Q(pnp10_5_poly_mis) ioemit10_poly_mis iocoll(C) ionbase(B) ioemit_poly(E) netlist model pnp10_5_poly_mis netlist element "X"
#ELSE
DEVICE Q(pnp10_5_poly_mis) ioemit10_poly_mis iocoll(C) ionbase(B) ioemit_poly(E) netlist model pnp10_5_poly_mis [
		property A
		A = area(ioemit_poly)
]
TRACE PROPERTY Q(pnp10_5_poly_mis) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp10_5_rpo_mis) ioemit10_rpo_mis iocoll(C) ionbase(B) ioemit(E) netlist model pnp10_5_rpo_mis netlist element "X"
#ELSE
DEVICE Q(pnp10_5_rpo_mis) ioemit10_rpo_mis iocoll(C) ionbase(B) ioemit(E) netlist model pnp10_5_rpo_mis [
		property A
		A = area(ioemit)
]
TRACE PROPERTY Q(pnp10_5_rpo_mis) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp10_rpo_mis) emit10_rpo_mis coll(C) nbase(B) emit_rpo(E) netlist model pnp10_rpo_mis netlist element "X"
#ELSE
DEVICE Q(pnp10_rpo_mis) emit10_rpo_mis coll(C) nbase(B) emit_rpo(E) netlist model pnp10_rpo_mis [
		property A
		A = area(emit_rpo)
]
TRACE PROPERTY Q(pnp10_rpo_mis) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp2_5_poly_mis) ioemit2_poly_mis iocoll(C) ionbase(B) ioemit_poly(E) netlist model pnp2_5_poly_mis netlist element "X"
#ELSE
DEVICE Q(pnp2_5_poly_mis) ioemit2_poly_mis iocoll(C) ionbase(B) ioemit_poly(E) netlist model pnp2_5_poly_mis [
		property A
		A = area(ioemit_poly)
]
TRACE PROPERTY Q(pnp2_5_poly_mis) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp2_rpo_mis) emit2_rpo_mis coll(C) nbase(B) emit_rpo(E) netlist model pnp2_rpo_mis netlist element "X"
#ELSE
DEVICE Q(pnp2_rpo_mis) emit2_rpo_mis coll(C) nbase(B) emit_rpo(E) netlist model pnp2_rpo_mis [
		property A
		A = area(emit_rpo)
]
TRACE PROPERTY Q(pnp2_rpo_mis) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp5_5_poly_mis) ioemit5_poly_mis iocoll(C) ionbase(B) ioemit_poly(E) netlist model pnp5_5_poly_mis netlist element "X"
#ELSE
DEVICE Q(pnp5_5_poly_mis) ioemit5_poly_mis iocoll(C) ionbase(B) ioemit_poly(E) netlist model pnp5_5_poly_mis [
		property A
		A = area(ioemit_poly)
]
TRACE PROPERTY Q(pnp5_5_poly_mis) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp5_rpo_mis) emit5_rpo_mis coll(C) nbase(B) emit_rpo(E) netlist model pnp5_rpo_mis netlist element "X"
#ELSE
DEVICE Q(pnp5_rpo_mis) emit5_rpo_mis coll(C) nbase(B) emit_rpo(E) netlist model pnp5_rpo_mis [
		property A
		A = area(emit_rpo)
]
TRACE PROPERTY Q(pnp5_rpo_mis) A A 0
#ENDIF

DEVICE D(ppnddshp_dio_iso_ac) nddpsubshp_dio_iso_reg psub NDD netlist model nddshp_dio_iso_ac [
   property a,pj
   a = area(nddpsubshp_dio_iso_reg)
   pj = perimeter(nddpsubshp_dio_iso_reg)
]
LVS FILTER D(ppnddshp_dio_iso_ac) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_36_iso) SHNWNBLPSUBSHP_36_ISO_reg4 psub_term_ac NBL netlist model shnnblpsubshp_dio_36_iso [
   property a,pj
   a = area(SHNWNBLPSUBSHP_36_ISO_reg4)
   pj = perimeter(SHNWNBLPSUBSHP_36_ISO_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_36_iso) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_gb_iso) SHNNBLPSUBSHP_gb_ISO_reg4 psub_term NBL netlist model shnnblpsubshp_dio_gb_iso [
   property a,pj
   a = area(SHNNBLPSUBSHP_gb_ISO_reg4)
   pj = perimeter(SHNNBLPSUBSHP_gb_ISO_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_gb_iso) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_gb_iso_ac) SHNNBLPSUBSHP_gb_ISO_ac_reg4 psub_term NBL netlist model shnnblpsubshp_dio_gb_iso_ac [
   property a,pj
   a = area(SHNNBLPSUBSHP_gb_ISO_ac_reg4)
   pj = perimeter(SHNNBLPSUBSHP_gb_ISO_ac_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_gb_iso_ac) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_gb_mv_iso) SHNNBLPSUBSHP_gb_mv_ISO_reg4 psub_term NBL netlist model shnnblpsubshp_dio_gb_mv_iso [
   property a,pj
   a = area(SHNNBLPSUBSHP_gb_mv_ISO_reg4)
   pj = perimeter(SHNNBLPSUBSHP_gb_mv_ISO_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_gb_mv_iso) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_hv_iso) SHNNBLPSUBSHP_hv_ISO_reg4 psub_term NBL netlist model shnnblpsubshp_dio_hv_iso [
   property a,pj
   a = area(SHNNBLPSUBSHP_hv_ISO_reg4)
   pj = perimeter(SHNNBLPSUBSHP_hv_ISO_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_hv_iso) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_hv_iso_ac) SHNNBLPSUBSHP_hv_ISO_ac_reg4 psub_term NBL netlist model shnnblpsubshp_dio_hv_iso_ac [
   property a,pj
   a = area(SHNNBLPSUBSHP_hv_ISO_ac_reg4)
   pj = perimeter(SHNNBLPSUBSHP_hv_ISO_ac_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_hv_iso_ac) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_iso) SHNNBLPSUBSHP_ISO_reg4 psub_term NBL netlist model shnnblpsubshp_dio_iso [
   property a,pj
   a = area(SHNNBLPSUBSHP_ISO_reg4)
   pj = perimeter(SHNNBLPSUBSHP_ISO_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_iso) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_iso_ac) SHNNBLPSUBSHP_ISO_ac_reg4 psub_term NBL netlist model shnnblpsubshp_dio_iso_ac [
   property a,pj
   a = area(SHNNBLPSUBSHP_ISO_ac_reg4)
   pj = perimeter(SHNNBLPSUBSHP_ISO_ac_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_iso_ac) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_mv_iso) SHNNBLPSUBSHP_mv_ISO_reg4 psub_term NBL netlist model shnnblpsubshp_dio_mv_iso [
   property a,pj
   a = area(SHNNBLPSUBSHP_mv_ISO_reg4)
   pj = perimeter(SHNNBLPSUBSHP_mv_ISO_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_mv_iso) LAYOUT OPEN

DEVICE D(ppshnnblpsubshp_dio_mv_iso_ac) SHNNBLPSUBSHP_mv_ISO_ac_reg4 psub_term NBL netlist model shnnblpsubshp_dio_mv_iso_ac [
   property a,pj
   a = area(SHNNBLPSUBSHP_mv_ISO_ac_reg4)
   pj = perimeter(SHNNBLPSUBSHP_mv_ISO_ac_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_mv_iso_ac) LAYOUT OPEN

DEVICE D(ppshpnblshn_dio_hv_iso) shpdpwnblshn_iso_hv_reg4 psub_under_ANWEL NBL netlist model shpnblshn_dio_hv_iso [
   property a,pj
   a = area(shpdpwnblshn_iso_hv_reg4)
   pj = perimeter(shpdpwnblshn_iso_hv_reg4)
]
LVS FILTER D(ppshpnblshn_dio_hv_iso) LAYOUT OPEN

DEVICE D(ppshpnblshn_dio_hv_iso_ac) shpdpwnblshn_iso_hv_ac_reg4 psub_under_ANWEL NBL netlist model shpnblshn_dio_hv_iso_ac [
   property a,pj
   a = area(shpdpwnblshn_iso_hv_ac_reg4)
   pj = perimeter(shpdpwnblshn_iso_hv_ac_reg4)
]
LVS FILTER D(ppshpnblshn_dio_hv_iso_ac) LAYOUT OPEN

DEVICE D(ppshpnblshn_dio_iso) shpdpwnblshn_iso_reg4 psub_under_ANWEL NBL netlist model shpnblshn_dio_iso [
   property a,pj
   a = area(shpdpwnblshn_iso_reg4)
   pj = perimeter(shpdpwnblshn_iso_reg4)
]
LVS FILTER D(ppshpnblshn_dio_iso) LAYOUT OPEN

DEVICE D(ppshpnblshn_dio_iso_ac) shpdpwnblshn_iso_ac_reg4 psub_under_ANWEL NBL netlist model shpnblshn_dio_iso_ac [
   property a,pj
   a = area(shpdpwnblshn_iso_ac_reg4)
   pj = perimeter(shpdpwnblshn_iso_ac_reg4)
]
LVS FILTER D(ppshpnblshn_dio_iso_ac) LAYOUT OPEN

DEVICE D(ppshpnblshn_dio_mv_iso) shpdpwnblshn_iso_mv_reg4 psub_under_ANWEL NBL netlist model shpnblshn_dio_mv_iso [
   property a,pj
   a = area(shpdpwnblshn_iso_mv_reg4)
   pj = perimeter(shpdpwnblshn_iso_mv_reg4)
]
LVS FILTER D(ppshpnblshn_dio_mv_iso) LAYOUT OPEN

DEVICE D(ppshpnblshn_dio_mv_iso_ac) shpdpwnblshn_iso_mv_ac_reg4 psub_under_ANWEL NBL netlist model shpnblshn_dio_mv_iso_ac [
   property a,pj
   a = area(shpdpwnblshn_iso_mv_ac_reg4)
   pj = perimeter(shpdpwnblshn_iso_mv_ac_reg4)
]
LVS FILTER D(ppshpnblshn_dio_mv_iso_ac) LAYOUT OPEN

#IFDEF extract_parasitic_diodes
DEVICE D(pwnblshn_dio_5_iso) pwnblhvnw_5_iso_reg12 psub_under_ANWEL NBL netlist model pwnblshn_dio_5_iso [
   property a,pj
   a = area(pwnblhvnw_5_iso_reg12)
   pj = perimeter(pwnblhvnw_5_iso_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(pwnblshn_dio_5_iso) a a 0
#ENDIF
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(pwnblshn_dio_iso) pwnblhvnw_iso_reg12 psub_under_ANWEL NBL netlist model pwnblshn_dio_iso [
   property a,pj
   a = area(pwnblhvnw_iso_reg12)
   pj = perimeter(pwnblhvnw_iso_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(pwnblshn_dio_iso) a a 0
#ENDIF
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(pwndddpwnblshn_dio_5_iso) pwndddpwnblshn_5_iso_reg12 psub_under_ANWEL NBL netlist model pwndddpwnblshn_dio_5_iso [
   property a,pj
   a = area(pwndddpwnblshn_5_iso_reg12)
   pj = perimeter(pwndddpwnblshn_5_iso_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(pwndddpwnblshn_dio_5_iso) a a 0
#ENDIF
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(pwnddnblshn_dio_5_iso) pwnddnblhvnw_5_iso_reg12 psub_under_ANWEL NBL netlist model pwnddnblshn_dio_5_iso [
   property a,pj
   a = area(pwnddnblhvnw_5_iso_reg12)
   pj = perimeter(pwnddnblhvnw_5_iso_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(pwnddnblshn_dio_5_iso) a a 0
#ENDIF
#ENDIF

DEVICE rnod_m rnodip_3t tndiff(PLUS) tndiff(MINUS) psub(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rnodip_3t,tndiff)/2
   lr = area(rnodip_3t)/wr
]
   TRACE PROPERTY rnod_m lr lr 0
   TRACE PROPERTY rnod_m wr wr 0

LVS REDUCE rnod_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnod_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnodrpo_m nrdop_3t tndiff(PLUS) tndiff(MINUS) psub(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(nrdop_3t,tndiff)/2
   lr = area(nrdop_3t)/wr
]
   TRACE PROPERTY rnodrpo_m lr lr 0
   TRACE PROPERTY rnodrpo_m wr wr 0

LVS REDUCE rnodrpo_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnodrpo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnodrpo_pure5v nrdop_p5 tndiff(PLUS) tndiff(MINUS) (PLUS MINUS) [
   property l,w
   w = perimeter_coincide(nrdop_p5,tndiff)/2
   l = area(nrdop_p5)/w
]
   TRACE PROPERTY rnodrpo_pure5v l l 0
   TRACE PROPERTY rnodrpo_pure5v w w 0

LVS REDUCE rnodrpo_pure5v PARALLEL YES
[  TOLERANCE l 0
   EFFECTIVE w,l
   l = SUM(l)/COUNT()
   w = SUM(w)
]

LVS REDUCE rnodrpo_pure5v SERIES PLUS MINUS YES
[ TOLERANCE w 0
  EFFECTIVE w,l
  w = SUM(w)/COUNT()
  l = SUM(l)
]

DEVICE rnodrpo_pure5v_m nrdop_3t_p5 tndiff(PLUS) tndiff(MINUS) psub(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(nrdop_3t_p5,tndiff)/2
   lr = area(nrdop_3t_p5)/wr
]
   TRACE PROPERTY rnodrpo_pure5v_m lr lr 0
   TRACE PROPERTY rnodrpo_pure5v_m wr wr 0

LVS REDUCE rnodrpo_pure5v_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnodrpo_pure5v_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnodw_m rnodipw_3t tndiff(PLUS) tndiff(MINUS) psub(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rnodipw_3t,tndiff)/2
   lr = area(rnodipw_3t)/wr
]
   TRACE PROPERTY rnodw_m lr lr 0
   TRACE PROPERTY rnodw_m wr wr 0

LVS REDUCE rnodw_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnodw_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnpo1_dis rnpoip_3t poly(PLUS) poly(MINUS) poly_term(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rnpoip_3t,poly)/2
   lr = area(rnpoip_3t)/wr
]
   TRACE PROPERTY rnpo1_dis lr lr 0
   TRACE PROPERTY rnpo1_dis wr wr 0

LVS REDUCE rnpo1_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnpo1_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnpo1rpo_dis rnporpo_3t poly(PLUS) poly(MINUS) poly_term(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rnporpo_3t,poly)/2
   lr = area(rnporpo_3t)/wr
]
   TRACE PROPERTY rnpo1rpo_dis lr lr 0
   TRACE PROPERTY rnpo1rpo_dis wr wr 0

LVS REDUCE rnpo1rpo_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnpo1rpo_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnpo1rpo_pure5v rnporpo_p5 poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w
   w = perimeter_coincide(rnporpo_p5,poly)/2
   l = area(rnporpo_p5)/w
]
   TRACE PROPERTY rnpo1rpo_pure5v l l 0
   TRACE PROPERTY rnpo1rpo_pure5v w w 0

LVS REDUCE rnpo1rpo_pure5v PARALLEL YES
[  TOLERANCE l 0
   EFFECTIVE w,l
   l = SUM(l)/COUNT()
   w = SUM(w)
]

LVS REDUCE rnpo1rpo_pure5v SERIES PLUS MINUS YES
[ TOLERANCE w 0
  EFFECTIVE w,l
  w = SUM(w)/COUNT()
  l = SUM(l)
]

DEVICE rnpo1rpo_pure5v_dis rnporpo_3t_p5 poly(PLUS) poly(MINUS) poly_term(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rnporpo_3t_p5,poly)/2
   lr = area(rnporpo_3t_p5)/wr
]
   TRACE PROPERTY rnpo1rpo_pure5v_dis lr lr 0
   TRACE PROPERTY rnpo1rpo_pure5v_dis wr wr 0

LVS REDUCE rnpo1rpo_pure5v_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnpo1rpo_pure5v_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnpo1w_dis rnpoipw_3t poly(PLUS) poly(MINUS) poly_term(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rnpoipw_3t,poly)/2
   lr = area(rnpoipw_3t)/wr
]
   TRACE PROPERTY rnpo1w_dis lr lr 0
   TRACE PROPERTY rnpo1w_dis wr wr 0

LVS REDUCE rnpo1w_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnpo1w_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnwod_m nwod_3t nxwell(PLUS) nxwell(MINUS) psub(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(nwod_3t,nxwell)/2
   lr = area(nwod_3t)/wr
]
   TRACE PROPERTY rnwod_m lr lr 0
   TRACE PROPERTY rnwod_m wr wr 0

LVS REDUCE rnwod_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnwod_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnwod_pure5v nwod_p5 nxwell(PLUS) nxwell(MINUS) (PLUS MINUS) [
   property l,w
   w = perimeter_coincide(nwod_p5,nxwell)/2
   l = area(nwod_p5)/w
]
   TRACE PROPERTY rnwod_pure5v l l 0
   TRACE PROPERTY rnwod_pure5v w w 0

LVS REDUCE rnwod_pure5v PARALLEL YES
[  TOLERANCE l 0
   EFFECTIVE w,l
   l = SUM(l)/COUNT()
   w = SUM(w)
]

LVS REDUCE rnwod_pure5v SERIES PLUS MINUS YES
[ TOLERANCE w 0
  EFFECTIVE w,l
  w = SUM(w)/COUNT()
  l = SUM(l)
]

DEVICE rnwod_pure5v_m nwod_3t_p5 nxwell(PLUS) nxwell(MINUS) psub(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(nwod_3t_p5,nxwell)/2
   lr = area(nwod_3t_p5)/wr
]
   TRACE PROPERTY rnwod_pure5v_m lr lr 0
   TRACE PROPERTY rnwod_pure5v_m wr wr 0

LVS REDUCE rnwod_pure5v_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnwod_pure5v_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnwsti_m nwsti_3t nxwell(PLUS) nxwell(MINUS) psub(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(nwsti_3t,nxwell)/2
   lr = area(nwsti_3t)/wr
]
   TRACE PROPERTY rnwsti_m lr lr 0
   TRACE PROPERTY rnwsti_m wr wr 0

LVS REDUCE rnwsti_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnwsti_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rnwsti_pure5v nwsti_p5 nxwell(PLUS) nxwell(MINUS) (PLUS MINUS) [
   property l,w
   w = perimeter_coincide(nwsti_p5,nxwell)/2
   l = area(nwsti_p5)/w
]
   TRACE PROPERTY rnwsti_pure5v l l 0
   TRACE PROPERTY rnwsti_pure5v w w 0

LVS REDUCE rnwsti_pure5v PARALLEL YES
[  TOLERANCE l 0
   EFFECTIVE w,l
   l = SUM(l)/COUNT()
   w = SUM(w)
]

LVS REDUCE rnwsti_pure5v SERIES PLUS MINUS YES
[ TOLERANCE w 0
  EFFECTIVE w,l
  w = SUM(w)/COUNT()
  l = SUM(l)
]

DEVICE rnwsti_pure5v_m nwsti_3t_p5 nxwell(PLUS) nxwell(MINUS) psub(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(nwsti_3t_p5,nxwell)/2
   lr = area(nwsti_3t_p5)/wr
]
   TRACE PROPERTY rnwsti_pure5v_m lr lr 0
   TRACE PROPERTY rnwsti_pure5v_m wr wr 0

LVS REDUCE rnwsti_pure5v_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rnwsti_pure5v_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rpod_m rpodip_3t tpdiff(PLUS) tpdiff(MINUS) nxwell(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rpodip_3t,tpdiff)/2
   lr = area(rpodip_3t)/wr
]
   TRACE PROPERTY rpod_m lr lr 0
   TRACE PROPERTY rpod_m wr wr 0

LVS REDUCE rpod_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rpod_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rpodrpo_m prdop_3t tpdiff(PLUS) tpdiff(MINUS) nxwell(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(prdop_3t,tpdiff)/2
   lr = area(prdop_3t)/wr
]
   TRACE PROPERTY rpodrpo_m lr lr 0
   TRACE PROPERTY rpodrpo_m wr wr 0

LVS REDUCE rpodrpo_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rpodrpo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rpodrpo_pure5v prdop_p5 tpdiff(PLUS) tpdiff(MINUS) (PLUS MINUS) [
   property l,w
   w = perimeter_coincide(prdop_p5,tpdiff)/2
   l = area(prdop_p5)/w
]
   TRACE PROPERTY rpodrpo_pure5v l l 0
   TRACE PROPERTY rpodrpo_pure5v w w 0

LVS REDUCE rpodrpo_pure5v PARALLEL YES
[  TOLERANCE l 0
   EFFECTIVE w,l
   l = SUM(l)/COUNT()
   w = SUM(w)
]

LVS REDUCE rpodrpo_pure5v SERIES PLUS MINUS YES
[ TOLERANCE w 0
  EFFECTIVE w,l
  w = SUM(w)/COUNT()
  l = SUM(l)
]

DEVICE rpodrpo_pure5v_m prdop_3t_p5 tpdiff(PLUS) tpdiff(MINUS) nxwell(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(prdop_3t_p5,tpdiff)/2
   lr = area(prdop_3t_p5)/wr
]
   TRACE PROPERTY rpodrpo_pure5v_m lr lr 0
   TRACE PROPERTY rpodrpo_pure5v_m wr wr 0

LVS REDUCE rpodrpo_pure5v_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rpodrpo_pure5v_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rpodw_m rpodipw_3t tpdiff(PLUS) tpdiff(MINUS) nxwell(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rpodipw_3t,tpdiff)/2
   lr = area(rpodipw_3t)/wr
]
   TRACE PROPERTY rpodw_m lr lr 0
   TRACE PROPERTY rpodw_m wr wr 0

LVS REDUCE rpodw_m PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rpodw_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rppo1_dis rppoip_3t poly(PLUS) poly(MINUS) poly_term(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rppoip_3t,poly)/2
   lr = area(rppoip_3t)/wr
]
   TRACE PROPERTY rppo1_dis lr lr 0
   TRACE PROPERTY rppo1_dis wr wr 0

LVS REDUCE rppo1_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rppo1_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rppo1rpo_dis rpporpo_3t poly(PLUS) poly(MINUS) poly_term(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rpporpo_3t,poly)/2
   lr = area(rpporpo_3t)/wr
]
   TRACE PROPERTY rppo1rpo_dis lr lr 0
   TRACE PROPERTY rppo1rpo_dis wr wr 0

LVS REDUCE rppo1rpo_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rppo1rpo_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rppo1rpo_pure5v rpporpo_p5 poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w
   w = perimeter_coincide(rpporpo_p5,poly)/2
   l = area(rpporpo_p5)/w
]
   TRACE PROPERTY rppo1rpo_pure5v l l 0
   TRACE PROPERTY rppo1rpo_pure5v w w 0

LVS REDUCE rppo1rpo_pure5v PARALLEL YES
[  TOLERANCE l 0
   EFFECTIVE w,l
   l = SUM(l)/COUNT()
   w = SUM(w)
]

LVS REDUCE rppo1rpo_pure5v SERIES PLUS MINUS YES
[ TOLERANCE w 0
  EFFECTIVE w,l
  w = SUM(w)/COUNT()
  l = SUM(l)
]

DEVICE rppo1rpo_pure5v_dis rpporpo_3t_p5 poly(PLUS) poly(MINUS) poly_term(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rpporpo_3t_p5,poly)/2
   lr = area(rpporpo_3t_p5)/wr
]
   TRACE PROPERTY rppo1rpo_pure5v_dis lr lr 0
   TRACE PROPERTY rppo1rpo_pure5v_dis wr wr 0

LVS REDUCE rppo1rpo_pure5v_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rppo1rpo_pure5v_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rppo1rpo_serp rpporpo_2t_serp poly(PLUS) poly(MINUS) <rpporpo_2t_serp_aux> [
	property W,L
	w=perimeter_coincide(rpporpo_2t_serp,poly)/2
	l=area(rpporpo_2t_serp_aux)/w
]
TRACE PROPERTY rppo1rpo_serp w w 0
TRACE PROPERTY rppo1rpo_serp l l 0
LVS REDUCE rppo1rpo_serp PARALLEL YES
[
	TOLERANCE l 0
	EFFECTIVE l,w
	l = SUM(l)/COUNT()
	w = SUM(w)
]
LVS REDUCE rppo1rpo_serp SERIES PLUS MINUS YES
[
	TOLERANCE w 0
	EFFECTIVE l,w
	w = SUM(w)/COUNT()
	l = SUM(l)
]

DEVICE rppo1rpo_serp_dis rpporpo_3t_serp poly(PLUS) poly(MINUS) poly_term(B) <rpporpo_3t_serp_aux> [
	property WR,LR
	wr=perimeter_coincide(rpporpo_3t_serp,poly)/2
	lr=area(rpporpo_3t_serp_aux)/wr
]
TRACE PROPERTY rppo1rpo_serp_dis wr wr 0
TRACE PROPERTY rppo1rpo_serp_dis lr lr 0
LVS REDUCE rppo1rpo_serp_dis PARALLEL YES
[
	TOLERANCE lr 0
	EFFECTIVE lr,wr
	lr = SUM(lr)/COUNT()
	wr = SUM(wr)
]
LVS REDUCE rppo1rpo_serp_dis SERIES PLUS MINUS YES
[
	TOLERANCE wr 0
	EFFECTIVE lr,wr
	wr = SUM(wr)/COUNT()
	lr = SUM(lr)
]

DEVICE rppo1w_dis rppoipw_3t poly(PLUS) poly(MINUS) poly_term(B)  (PLUS MINUS) [
   property lr,wr
   wr = perimeter_coincide(rppoipw_3t,poly)/2
   lr = area(rppoipw_3t)/wr
]
   TRACE PROPERTY rppo1w_dis lr lr 0
   TRACE PROPERTY rppo1w_dis wr wr 0

LVS REDUCE rppo1w_dis PARALLEL YES 
[  TOLERANCE lr 0  
   EFFECTIVE wr,lr
   lr = SUM(lr)/COUNT()
   wr = SUM(wr)
]

LVS REDUCE rppo1w_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  EFFECTIVE wr,lr
  wr = SUM(wr)/COUNT()
  lr = SUM(lr)
]
   

DEVICE rppolyhri1k hrpo1k_2t poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(hrpo1k_2t,poly)/2
   l = area(hrpo1k_2t)/w
]
TRACE PROPERTY rppolyhri1k l l 0
TRACE PROPERTY rppolyhri1k w w 0

LVS REDUCE rppolyhri1k PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rppolyhri1k SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]

DEVICE rppolyhri1k_dis hrpo1k_3t poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(hrpo1k_3t,poly)/2
   lr = area(hrpo1k_3t)/wr
]
TRACE PROPERTY rppolyhri1k_dis lr lr 0
TRACE PROPERTY rppolyhri1k_dis wr wr 0
LVS REDUCE rppolyhri1k_dis PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rppolyhri1k_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]

DEVICE rppolyhri3d3k hrpo3d3k_2t poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(hrpo3d3k_2t,poly)/2
   l = area(hrpo3d3k_2t)/w
]
TRACE PROPERTY rppolyhri3d3k l l 0
TRACE PROPERTY rppolyhri3d3k w w 0

LVS REDUCE rppolyhri3d3k PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rppolyhri3d3k SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]

DEVICE rppolyhri3d3k_dis hrpo3d3k_3t poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(hrpo3d3k_3t,poly)/2
   lr = area(hrpo3d3k_3t)/wr
]
TRACE PROPERTY rppolyhri3d3k_dis lr lr 0
TRACE PROPERTY rppolyhri3d3k_dis wr wr 0
LVS REDUCE rppolyhri3d3k_dis PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rppolyhri3d3k_dis SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]

DEVICE rppolyhri3d3k_serp hrpo3d3k_2t_serp poly(PLUS) poly(MINUS) <hrpo3d3k_2t_serp_aux> [
	property W,L
	w=perimeter_coincide(hrpo3d3k_2t_serp,poly)/2
	l=area(hrpo3d3k_2t_serp_aux)/w
]
TRACE PROPERTY rppolyhri3d3k_serp w w 0
TRACE PROPERTY rppolyhri3d3k_serp l l 0
LVS REDUCE rppolyhri3d3k_serp PARALLEL YES
[
	TOLERANCE l 0
	EFFECTIVE l,w
	l = SUM(l)/COUNT()
	w = SUM(w)
]
LVS REDUCE rppolyhri3d3k_serp SERIES PLUS MINUS YES
[
	TOLERANCE w 0
	EFFECTIVE l,w
	w = SUM(w)/COUNT()
	l = SUM(l)
]

DEVICE rppolyhri3d3k_serp_dis hrpo3d3k_3t_serp poly(PLUS) poly(MINUS) poly_term(BULK) <hrpo3d3k_3t_serp_aux> [
	property WR,LR
	wr=perimeter_coincide(hrpo3d3k_3t_serp,poly)/2
	lr=area(hrpo3d3k_3t_serp_aux)/wr
]
TRACE PROPERTY rppolyhri3d3k_serp_dis wr wr 0
TRACE PROPERTY rppolyhri3d3k_serp_dis lr lr 0
LVS REDUCE rppolyhri3d3k_serp_dis PARALLEL YES
[
	TOLERANCE lr 0
	EFFECTIVE lr,wr
	lr = SUM(lr)/COUNT()
	wr = SUM(wr)
]
LVS REDUCE rppolyhri3d3k_serp_dis SERIES PLUS MINUS YES
[
	TOLERANCE wr 0
	EFFECTIVE lr,wr
	wr = SUM(wr)/COUNT()
	lr = SUM(lr)
]

#IFDEF RC_DECK
DEVICE sbd_dio_ga_12_v2_3t sbd_hv_dio_12_r sbd_hv_dio_gen2_dio(PLUS) NDD(MINUS) psub_term_ac(SUB) netlist model sbd_dio_ga_12_v2_3t [
   property nddshp_area,nddshp_pj,shnnblpsubshp_area,shnnblpsubshp_pj
   nddshp_area = 0
   nddshp_pj = 0
   shnnblpsubshp_area = 0
   shnnblpsubshp_pj = 0
]
#ELSE
DEVICE sbd_dio_ga_12_v2_3t sbd_hv_dio_12_r sbd_hv_dio_gen2_dio(PLUS) NDD(MINUS) psub_term_ac(SUB) netlist model sbd_dio_ga_12_v2_3t 
#ENDIF

#IFDEF RC_DECK
DEVICE sbd_dio_ga_16_v2_3t sbd_hv_dio_16_r sbd_hv_dio_gen2_dio(PLUS) NDD(MINUS) psub_term_ac(SUB) netlist model sbd_dio_ga_16_v2_3t [
   property nddshp_area,nddshp_pj,shnnblpsubshp_area,shnnblpsubshp_pj
   nddshp_area = 0
   nddshp_pj = 0
   shnnblpsubshp_area = 0
   shnnblpsubshp_pj = 0
]
#ELSE
DEVICE sbd_dio_ga_16_v2_3t sbd_hv_dio_16_r sbd_hv_dio_gen2_dio(PLUS) NDD(MINUS) psub_term_ac(SUB) netlist model sbd_dio_ga_16_v2_3t 
#ENDIF

#IFDEF RC_DECK
DEVICE sbd_dio_ga_24_v2_3t sbd_hv_dio_24_r sbd_hv_dio_gen2_dio(PLUS) NDD(MINUS) psub_term_ac(SUB) netlist model sbd_dio_ga_24_v2_3t [
   property nddshp_area,nddshp_pj,shnnblpsubshp_area,shnnblpsubshp_pj
   nddshp_area = 0
   nddshp_pj = 0
   shnnblpsubshp_area = 0
   shnnblpsubshp_pj = 0
]
#ELSE
DEVICE sbd_dio_ga_24_v2_3t sbd_hv_dio_24_r sbd_hv_dio_gen2_dio(PLUS) NDD(MINUS) psub_term_ac(SUB) netlist model sbd_dio_ga_24_v2_3t 
#ENDIF

#IFDEF extract_parasitic_diodes
DEVICE D(shnnblpsubshp_dio_29_iso) HVNWNBLPSUBSHP_29_ISO_reg12 psub_term_ac NBL netlist model shnnblpsubshp_dio_29_iso [
   property a,pj
   a = area(HVNWNBLPSUBSHP_29_ISO_reg12)
   pj = perimeter(HVNWNBLPSUBSHP_29_ISO_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(shnnblpsubshp_dio_29_iso) a a 0
#ENDIF
#ENDIF

DEVICE D(ppshnnblpsubshp_dio_29_iso) SHNWNBLPSUBSHP_29_ISO_reg4 psub_term_ac NBL netlist model shnnblpsubshp_dio_29_iso [
   property a,pj
   a = area(SHNWNBLPSUBSHP_29_ISO_reg4)
   pj = perimeter(SHNWNBLPSUBSHP_29_ISO_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_29_iso) LAYOUT OPEN

#IFDEF extract_parasitic_diodes
DEVICE D(shnnblpsubshp_dio_45_iso) HVNWNBLPSUBSHP_45_ISO_reg12 psub_term_ac NBL netlist model shnnblpsubshp_dio_45_iso [
   property a,pj
   a = area(HVNWNBLPSUBSHP_45_ISO_reg12)
   pj = perimeter(HVNWNBLPSUBSHP_45_ISO_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(shnnblpsubshp_dio_45_iso) a a 0
#ENDIF
#ENDIF

DEVICE D(ppshnnblpsubshp_dio_45_iso) SHNWNBLPSUBSHP_45_ISO_reg4 psub_term_ac NBL netlist model shnnblpsubshp_dio_45_iso [
   property a,pj
   a = area(SHNWNBLPSUBSHP_45_ISO_reg4)
   pj = perimeter(SHNWNBLPSUBSHP_45_ISO_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_45_iso) LAYOUT OPEN

#IFDEF extract_parasitic_diodes
DEVICE D(shnnblpsubshp_dio_9_iso) HVNWNBLPSUBSHP_9_ISO_reg12 psub_term_ac NBL netlist model shnnblpsubshp_dio_9_iso [
   property a,pj
   a = area(HVNWNBLPSUBSHP_9_ISO_reg12)
   pj = perimeter(HVNWNBLPSUBSHP_9_ISO_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(shnnblpsubshp_dio_9_iso) a a 0
#ENDIF
#ENDIF

DEVICE D(ppshnnblpsubshp_dio_9_iso) HVNWNBLPSUBSHP_9_ISO_reg4 psub_term_ac NBL netlist model shnnblpsubshp_dio_9_iso [
   property a,pj
   a = area(HVNWNBLPSUBSHP_9_ISO_reg4)
   pj = perimeter(HVNWNBLPSUBSHP_9_ISO_reg4)
]
LVS FILTER D(ppshnnblpsubshp_dio_9_iso) LAYOUT OPEN

#IFDEF extract_parasitic_diodes
DEVICE D(shpdpwnblshn_dio_iso) shpdpwnblshn_dio_iso_reg12 psub_under_ANWEL NBL netlist model shpdpwnblshn_dio_iso [
   property a,pj
   a = area(shpdpwnblshn_dio_iso_reg12)
   pj = perimeter(shpdpwnblshn_dio_iso_reg12)
]
#IFDEF compare_parasitic_diodes
   TRACE PROPERTY D(shpdpwnblshn_dio_iso) a a 0
#ENDIF
#ENDIF

#IFDEF RC_DECK
DEVICE shpnblshn_dio_shp_gb_3t shpnblshn_dio_3t_reg tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <SH_P> [
    property area,pj,shnnblpsubshp_area,shnnblpsubshp_pj
    area = area(SH_P)
    pj = perimeter(SH_P)
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE shpnblshn_dio_shp_gb_3t shpnblshn_dio_3t_reg tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) <SH_P> [
    property area,pj
    area = area(SH_P)
    pj = perimeter(SH_P)
]
#ENDIF
TRACE PROPERTY shpnblshn_dio_shp_gb_3t "area" "area" 0
LVS DEVICE TYPE DIODE shpnblshn_dio_shp_gb_3t [POS=PLUS NEG=MINUS]
LVS REDUCE shpnblshn_dio_shp_gb_3t PARALLEL YES 
[  
   EFFECTIVE area
   area = sum( area )  
]

#IFDEF RC_DECK
DEVICE shpshnnbl_esd_dio_shp_ga_3t shpshnnbl_esd tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l,shnnblpsubshp_area,shnnblpsubshp_pj
    l = area(shpshnnbl_esd)/2.0e-6
    shnnblpsubshp_area = 0
    shnnblpsubshp_pj = 0
]
#ELSE
DEVICE shpshnnbl_esd_dio_shp_ga_3t shpshnnbl_esd tpdiff(PLUS) NBL(MINUS) psub_term_ac(SUB) [
    property l
    l = area(shpshnnbl_esd)/2.0e-6
]
#ENDIF
TRACE PROPERTY shpshnnbl_esd_dio_shp_ga_3t l l 0

#IFDEF RC_DECK
DEVICE zd_dio_ga_nbl_v2_4t zd_dio_ga_nbl_4t_reg psub(PLUS) tndiff(MINUS) NBL(NBL_ISO) psub_term_ac(SUB) netlist model zd_dio_ga_nbl_v2_4t [
   property w,shnnblpsubshp_area,shnnblpsubshp_pj,shpnblshn_area,shpnblshn_pj
   l = 0.8e-6
   w = area(zd_dio_ga_nbl_4t_reg)/l
   shnnblpsubshp_area = 0
   shnnblpsubshp_pj = 0
   shpnblshn_area = 0
   shpnblshn_pj = 0
]
#ELSE
DEVICE zd_dio_ga_nbl_v2_4t zd_dio_ga_nbl_4t_reg psub(PLUS) tndiff(MINUS) NBL(NBL_ISO) psub_term_ac(SUB) netlist model zd_dio_ga_nbl_v2_4t [
   property w
   l = 0.8e-6
   w = area(zd_dio_ga_nbl_4t_reg)/l
]
#ENDIF

TRACE PROPERTY  zd_dio_ga_nbl_v2_4t w w 0

TVF FUNCTION device_function [/*

    package require CalibreLVS_DEVICE_DFM
    namespace import device::*
    proc catching_expr { arg } {
      	#puts "called catching_expr"
      	set rtval 0.0
      	if { [ catch {
            set rtval [ expr $arg ]
      	} result ] } {
            global errorCode
            set tmpError $errorCode
            #puts $result
            if { [ string match "ARITH UNDERFLOW *" $errorCode ] } {
            	#puts "$errorCode error caught during expr"
            	set rtval 0.0
            } elseif { [ string match "ARITH OVERFLOW *" $errorCode ] } {
	    	#puts "$errorCode error caught during expr"
            	set rtval 1e200
            } else {
            	#puts "error propagated during expr"
            	error $result $tmpError
            }
      	}
      	return $rtval
    }

    proc calc_sca { SCH SCV W L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set sca_sum1 0.0
  	set sca_sum2 0.0
  	set SCref 1.0
  	set slice_count1 [ $SCH slice_count ]
  	set slice_count2 [ $SCV slice_count ]

  	for { set i 0 } { $i < $slice_count1} { incr i } {
       	    set sca_sum1 [ expr { $sca_sum1 + ( ([$SCALE]*[$SCH w $i]) * ( ($SCref * $SCref/([$SCALE]*([$SCH a $i]+[$LR_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))) +  ($SCref * $SCref/([$SCALE]*([$SCH b $i]+[$LR_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))))) }]
       	}

  	for { set i 0 } { $i < $slice_count2} { incr i } {
            set sca_sum2 [ expr { $sca_sum2 + ( ([$SCALE]*[$SCV w $i]) * ( ($SCref * $SCref/([$SCALE]*([$SCV a $i]+[$BOT_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))) + ($SCref * $SCref/([$SCALE]*([$SCV b $i]+[$TOP_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))))) }]
       	}

  	return [ expr { ($sca_sum1 + $sca_sum2) / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) * 1e12) }]
    }

    proc calc_scb {  SCH SCV W  L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set scb_sum1 0.0
	set scb_sum2 0.0
  	set SCref 1.0
  	set slice_count1 [ $SCH slice_count ]
  	set slice_count2 [ $SCV slice_count ]
  	for { set i 0 } { $i < $slice_count1} { incr i } {
  	    set exp_term1 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term2 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term3 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
    	    set exp_term4 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
   	    set exp_term5 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term6 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set scb_sum1 [ expr { $scb_sum1 + ( ([$SCALE]*[ $SCH w $i ])*1e6 * (   (([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6*( $exp_term1/10)) +   ($SCref*($exp_term2/100)) - (([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6*($exp_term3/10)) - (($SCref*($exp_term4/100))) + (([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6*( $exp_term5/10)) +   ($SCref*($exp_term6/100)) - (([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6*($exp_term7/10)) - ($SCref*($exp_term8/100))       )) } ]
     	}
   	for { set i 0 } { $i < $slice_count2} { incr i } {
	    set exp_term1 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set scb_sum2 [ expr { $scb_sum2 + ( ([$SCALE]*[$SCV w $i])*1e6 * (   (([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6*( $exp_term1/10)) +   ($SCref*($exp_term2/100)) - (([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6*($exp_term3/10)) - ($SCref*($exp_term4/100)) + (([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6*( $exp_term5/10)) +   ($SCref*($exp_term6/100)) - (([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6*($exp_term7/10)) - ($SCref*($exp_term8/100))       )) } ]
     	}
	return [ expr { ( $scb_sum1 + $scb_sum2)  / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) *1e12) }]
    }

    proc calc_scc { SCH SCV W L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set scc_sum1 0.0
	set scc_sum2 0.0
	set SCref 1.0
	set slice_count1 [ $SCH slice_count ]
	set slice_count2 [ $SCV slice_count ]
	for { set i 0 } { $i < $slice_count1} { incr i } { 
	    set exp_term1 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set scc_sum1 [ expr { $scc_sum1 + ( ([$SCALE]*[$SCH w $i])*1e6 * (   (([$SCALE]*([$SCH a $i]+ [$LR_EXT]))*1e6*( $exp_term1/20)) +   ($SCref*($exp_term2/400)) - (([$SCALE]*([$SCH a $i]+[$L]+ [$LR_EXT]))*1e6*($exp_term3/20)) - ($SCref*($exp_term4/400)) + (([$SCALE]*([$SCH b $i]+ [$LR_EXT]))*1e6*( $exp_term5/20)) +   ($SCref*($exp_term6/400)) - (([$SCALE]*([$SCH b $i]+[$L]+ [$LR_EXT]))*1e6*($exp_term7/20)) - ($SCref*($exp_term8/400))       )) } ]
	}
	for { set i 0 } { $i < $slice_count2} { incr i } {
	    set exp_term1 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set scc_sum2 [ expr { $scc_sum2 + ( ([$SCALE]*[$SCV w $i])*1e6 * (   (([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6*( $exp_term1/20)) +   ($SCref*($exp_term2/400)) - (([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6*($exp_term3/20)) - ($SCref*($exp_term4/400)) + (([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6*( $exp_term5/20)) +   ($SCref*($exp_term6/400)) - (([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6*($exp_term7/20)) - ($SCref*($exp_term8/400))       )) } ]
	}
	return [ expr { ( $scc_sum1 + $scc_sum2)  / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) *1e12) }]
    }
*/]
// Serve X-resistor as an built-in resistor (for PATHCHK)
LVS DEVICE TYPE RESISTOR rnod_m rnodrpo_m rnodrpo_pure5v rnodrpo_pure5v_m rnodw_m rnpo1_dis rnpo1rpo_dis rnpo1rpo_pure5v rnpo1rpo_pure5v_dis rnpo1w_dis rnwod_m rnwod_pure5v rnwod_pure5v_m rnwsti_m rnwsti_pure5v rnwsti_pure5v_m rpod_m rpodrpo_m rpodrpo_pure5v rpodrpo_pure5v_m rpodw_m rppo1_dis rppo1rpo_dis rppo1rpo_pure5v rppo1rpo_pure5v_dis rppo1rpo_serp rppo1rpo_serp_dis rppo1w_dis rppolyhri1k rppolyhri1k_dis rppolyhri3d3k rppolyhri3d3k_dis rppolyhri3d3k_serp rppolyhri3d3k_serp_dis [POS=PLUS NEG=MINUS]

#IFDEF RC_DECK
//=============================
//======= Setup for PEX =======
//=============================
MASK SVDB DIRECTORY "svdb" XRC
//PEX MAGNIFY 1.0
//PEX DELAY                      none   //PENFIELD 0.7 MASK DIRECT
PEX EXCLUDE DISTRIBUTED        "VDD" "AVDD" "VD33" "VDDSA" "VDDPST" "VDD5V" MASK DIRECT
PEX EXCLUDE LUMPED             "VDD" "AVDD" "VD33" "VDDSA" "VDDPST" "VDD5V" MASK DIRECT
PEX NETLIST DISTRIBUTED        "net.dist" HSPICE LAYOUT GROUND VSS MASK DIRECT LOCATION RCNAMED
PEX NETLIST LUMPED             "temp.spi" HSPICE LAYOUT GROUND VSS MASK DIRECT LOCATION RCNAMED
PEX NETLIST SIMPLE             "net.simple" HSPICE LAYOUT MASK DIRECT LOCATION RCNAMED
//Back-annotation xcalibre flow
//PEX NETLIST DISTRIBUTED        "net.dist" HSPICE SOURCE GROUND VSS MASK DIRECT LOCATION RCNAMED
//PEX NETLIST LUMPED             "temp.spi" HSPICE SOURCE GROUND VSS MASK DIRECT LOCATION RCNAMED
//PEX NETLIST SIMPLE             "net.simple" HSPICE SOURCE MASK DIRECT LOCATION RCNAMED

PEX REPORT DISTRIBUTED         none  //"report.dist" ASCII LAYOUT MASK DIRECT
PEX REPORT LUMPED              none  //"report.lump" LAYOUT MASK DIRECT
//PEX RESISTANCE LUMPED          YES MASK DIRECT
//PEX REDUCE LUMPED C            < 10000000
PEX IDEAL XCELL                YES

// xcalibre capacitance and resistance file 
UNIT CAPACITANCE ff
UNIT RESISTANCE OHM
// Unzip RC techfile and include "rules" file here.
include ./rules

PEX ALIAS tndiff  hnemit shpemit_poly hvndfs shpemit_7t_e1 shpemit_7t_e8 tndiff_woR schottky_n
PEX ALIAS tpdiff  emit_rpo hvpdfs ioemit ioemit_poly nddemit phvnwemit stack_esd_plus tpdiff_woR schottky_p sbd_hv_dio_gen2_dio tpdiff_s
PEX IGNORE RESISTANCE tndiff_woR
PEX IGNORE RESISTANCE tpdiff_woR sbd_hv_dio_gen2_dio

#ELSE

//#############################################
//# ERC CHECK                                 #
//#############################################
// Reports regions on a mim_term layer that connect to more than one node.
LVS SOFTCHK mim_term CONTACT
// Reports regions on a poly_term layer that connect to more than one node.
LVS SOFTCHK poly_term CONTACT
// Reports regions on a DPW layer that connect to more than one node.
LVS SOFTCHK DPW CONTACT
// Reports regions on a HVNW layer that connect to more than one node.
LVS SOFTCHK HVNW CONTACT
// Reports regions on a NBL layer that connect to more than one node.
LVS SOFTCHK NBL CONTACT
// Reports regions on a NDD layer that connect to more than one node.
LVS SOFTCHK NDD CONTACT
// Reports regions on a SH_N layer that connect to more than one node.
LVS SOFTCHK SH_N CONTACT
// Reports regions on a hncol layer that connect to more than one node.
LVS SOFTCHK hncol CONTACT
// Reports regions on a hncol_shp layer that connect to more than one node.
LVS SOFTCHK hncol_shp CONTACT
// Reports regions on a hncol_shp_7t_c1 layer that connect to more than one node.
LVS SOFTCHK hncol_shp_7t_c1 CONTACT
// Reports regions on a hncol_shp_7t_c8 layer that connect to more than one node.
LVS SOFTCHK hncol_shp_7t_c8 CONTACT
// Reports regions on a hnwbase layer that connect to more than one node.
LVS SOFTCHK hnwbase CONTACT
// Reports regions on a hnwbase_lat layer that connect to more than one node.
LVS SOFTCHK hnwbase_lat CONTACT
// Reports regions on a hvndfd layer that connect to more than one node.
LVS SOFTCHK hvndfd CONTACT
// Reports regions on a hvndfd_ndd layer that connect to more than one node.
LVS SOFTCHK hvndfd_ndd CONTACT
// Reports regions on a hvndfd_shn layer that connect to more than one node.
LVS SOFTCHK hvndfd_shn CONTACT
// Reports regions on a hvndfd_shn_ndd layer that connect to more than one node.
LVS SOFTCHK hvndfd_shn_ndd CONTACT
// Reports regions on a ionbase layer that connect to more than one node.
LVS SOFTCHK ionbase CONTACT
// Reports regions on a iso_hvnw layer that connect to more than one node.
LVS SOFTCHK iso_hvnw CONTACT
// Reports regions on a nbase layer that connect to more than one node.
LVS SOFTCHK nbase CONTACT
// Reports regions on a nddbase layer that connect to more than one node.
LVS SOFTCHK nddbase CONTACT
// Reports regions on a nxwell layer that connect to more than one node.
LVS SOFTCHK nxwell CONTACT
// Reports regions on a phvnwbase layer that connect to more than one node.
LVS SOFTCHK phvnwbase CONTACT
// Reports regions on a s_hvnw layer that connect to more than one node.
LVS SOFTCHK s_hvnw CONTACT
// Reports regions on a stack_esd_minus layer that connect to more than one node.
LVS SOFTCHK stack_esd_minus CONTACT
// Reports regions on a HVPBi layer that connect to more than one node.
LVS SOFTCHK HVPBi CONTACT
// Reports regions on a HVPW layer that connect to more than one node.
LVS SOFTCHK HVPW CONTACT
// Reports regions on a PDD layer that connect to more than one node.
LVS SOFTCHK PDD CONTACT
// Reports regions on a SH_P layer that connect to more than one node.
LVS SOFTCHK SH_P CONTACT
// Reports regions on a coll layer that connect to more than one node.
LVS SOFTCHK coll CONTACT
// Reports regions on a hpbase layer that connect to more than one node.
LVS SOFTCHK hpbase CONTACT
// Reports regions on a hpwcol layer that connect to more than one node.
LVS SOFTCHK hpwcol CONTACT
// Reports regions on a hvpdfd layer that connect to more than one node.
LVS SOFTCHK hvpdfd CONTACT
// Reports regions on a hvpdfd_hvpb layer that connect to more than one node.
LVS SOFTCHK hvpdfd_hvpb CONTACT
// Reports regions on a hvpdfd_pdd layer that connect to more than one node.
LVS SOFTCHK hvpdfd_pdd CONTACT
// Reports regions on a hvpdfd_shp layer that connect to more than one node.
LVS SOFTCHK hvpdfd_shp CONTACT
// Reports regions on a hvpsf_shp layer that connect to more than one node.
LVS SOFTCHK hvpsf_shp CONTACT
// Reports regions on a hvpwbase_7t_ga_b1 layer that connect to more than one node.
LVS SOFTCHK hvpwbase_7t_ga_b1 CONTACT
// Reports regions on a hvpwbase_7t_ga_b8 layer that connect to more than one node.
LVS SOFTCHK hvpwbase_7t_ga_b8 CONTACT
// Reports regions on a hvpwbase_ga layer that connect to more than one node.
LVS SOFTCHK hvpwbase_ga CONTACT
// Reports regions on a hvpwbase_gb layer that connect to more than one node.
LVS SOFTCHK hvpwbase_gb CONTACT
// Reports regions on a iocoll layer that connect to more than one node.
LVS SOFTCHK iocoll CONTACT
// Reports regions on a n_psub layer that connect to more than one node.
#IFNDEF NW_RING
	LVS SOFTCHK n_psub CONTACT
#ENDIF
// Reports regions on a nddcol layer that connect to more than one node.
LVS SOFTCHK nddcol CONTACT
// Reports regions on a phvnwcol layer that connect to more than one node.
LVS SOFTCHK phvnwcol CONTACT
// Reports regions on a psub layer that connect to more than one node.
LVS SOFTCHK psub CONTACT
// Reports regions on a psub_term layer that connect to more than one node.
LVS SOFTCHK psub_term CONTACT
// Reports regions on a psub_term_ac layer that connect to more than one node.
LVS SOFTCHK psub_term_ac CONTACT
// Reports regions on a psub_term_nw layer that connect to more than one node.
LVS SOFTCHK psub_term_nw CONTACT
// Reports regions on a psub_under_ANWEL layer that connect to more than one node.
LVS SOFTCHK psub_under_ANWEL CONTACT
// Reports regions on a psub_under_DPW_co_imp layer that connect to more than one node.
LVS SOFTCHK psub_under_DPW_co_imp CONTACT
// Reports regions on a pw_iso layer that connect to more than one node.
LVS SOFTCHK pw_iso CONTACT
// Reports regions on a shpcol_hvnw layer that connect to more than one node.
LVS SOFTCHK shpcol_hvnw CONTACT
#IFDEF FLOATING_GATE_CHECK
GROUP ERC_FLOATING_GATE_CHECK  floating
ERC SELECT CHECK ERC_FLOATING_GATE_CHECK
#ENDIF

#IFDEF WELL_TO_PG_CHECK
GROUP ERC_WELL_TO_PG_CHECK  npvss49 ppvdd49
ERC SELECT CHECK ERC_WELL_TO_PG_CHECK
#ENDIF

#IFDEF GATE_TO_PG_CHECK
GROUP ERC_GATE_TO_PG_CHECK  npvss150 ppvdd150
ERC SELECT CHECK ERC_GATE_TO_PG_CHECK
#ENDIF

#IFDEF DS_TO_PG_CHECK
GROUP ERC_DS_TO_PG_CHECK  mnpg mppg mnpg_ldd mppg_ldd
ERC SELECT CHECK ERC_DS_TO_PG_CHECK
#ENDIF

#IFDEF FLOATING_WELL_CHECK
GROUP ERC_FLOATING_WELL_CHECK  floating.HVNW_float floating.nxwell_float floating.psub_float
ERC SELECT CHECK ERC_FLOATING_WELL_CHECK
#ENDIF

//MOS erc_nmos_gates S/D connect to POWER&GROUND --mnpg*/
N1tndiff = NET tndiff POWER_NAME
T1tndiff = erc_nmos_gates TOUCH N1tndiff
N2tndiff = NET tndiff GROUND_NAME
T2tndiff = erc_nmos_gates TOUCH N2tndiff

#IFDEF DS_TO_PG_CHECK
mnpg { @ MOS connected to both power and ground
  T1tndiff AND T2tndiff
}
#ENDIF

//MOS erc_pmos_gates S/D connect to POWER&GROUND --mppg*/
N1tpdiff = NET tpdiff POWER_NAME
T1tpdiff = erc_pmos_gates TOUCH N1tpdiff
N2tpdiff = NET tpdiff GROUND_NAME
T2tpdiff = erc_pmos_gates TOUCH N2tpdiff

#IFDEF DS_TO_PG_CHECK
mppg { @ MOS connected to both power and ground
  T1tpdiff AND T2tpdiff
}
#ENDIF

//MOS erc_nmos_gates S/D connect to POWER&GROUND --mnpg_ldd*/
N1hvndfs_mnpg_lddA = NET hvndfs POWER_NAME
T1hvndfs_mnpg_lddA = erc_nmos_gates TOUCH N1hvndfs_mnpg_lddA
N2hvndfd_mnpg_lddA = NET hvndfd GROUND_NAME
T2hvndfd_mnpg_lddA = erc_nmos_gates TOUCH N2hvndfd_mnpg_lddA

N1hvndfd_mnpg_lddB = NET hvndfd POWER_NAME
T1hvndfd_mnpg_lddB = erc_nmos_gates TOUCH N1hvndfd_mnpg_lddB
N2hvndfs_mnpg_lddB = NET hvndfs GROUND_NAME
T2hvndfs_mnpg_lddB = erc_nmos_gates TOUCH N2hvndfs_mnpg_lddB

#IFDEF DS_TO_PG_CHECK
mnpg_ldd { @ MOS connected to both power and ground
  (T1hvndfs_mnpg_lddA AND T2hvndfd_mnpg_lddA ) OR (T1hvndfd_mnpg_lddB AND T2hvndfs_mnpg_lddB )
}
#ENDIF

//MOS erc_pmos_gates S/D connect to POWER&GROUND --mppg_ldd*/
N1hvpdfs_mppg_lddA = NET hvpdfs POWER_NAME
T1hvpdfs_mppg_lddA = erc_pmos_gates TOUCH N1hvpdfs_mppg_lddA
N2hvpdfd_mppg_lddA = NET hvpdfd GROUND_NAME
T2hvpdfd_mppg_lddA = erc_pmos_gates TOUCH N2hvpdfd_mppg_lddA

N1hvpdfd_mppg_lddB = NET hvpdfd POWER_NAME
T1hvpdfd_mppg_lddB = erc_pmos_gates TOUCH N1hvpdfd_mppg_lddB
N2hvpdfs_mppg_lddB = NET hvpdfs GROUND_NAME
T2hvpdfs_mppg_lddB = erc_pmos_gates TOUCH N2hvpdfs_mppg_lddB

#IFDEF DS_TO_PG_CHECK
mppg_ldd { @ MOS connected to both power and ground
  (T1hvpdfs_mppg_lddA AND T2hvpdfd_mppg_lddA ) OR (T1hvpdfd_mppg_lddB AND T2hvpdfs_mppg_lddB )
}
#ENDIF

#IFDEF FLOATING_GATE_CHECK
// Floating gate no any CONT interact with the poly_nohvfpo.
floating { @ Please check the floating gate
  poly_nohvfpo_no_CONT = poly_nohvfpo NOT INTERACT CONT
  gate_no_co = poly_nohvfpo_no_CONT AND diff
  poly_nohvfpo_no_CONT INTERACT gate_no_co
}
#ENDIF

#IFDEF FLOATING_WELL_CHECK
SCONNECT tndiff HVNW_float by nplug
SCONNECT schottky_n HVNW_float by nplug
SCONNECT shpemit_7t_e1 HVNW_float by nplug
SCONNECT shpemit_7t_e8 HVNW_float by nplug
SCONNECT hvndfs HVNW_float by nplug
SCONNECT shpemit_poly HVNW_float by nplug
SCONNECT hnemit HVNW_float by nplug
SCONNECT tndiff_woR HVNW_float by nplug
floating.HVNW_float { @ HVNW_float is not connected to POWER
  no_power_path = PATHCHK !POWER HVNW_float PORTS ALSO
  direct_connect_ground = NET HVNW_float GROUND_NAME
  no_power_path or direct_connect_ground
}
#ENDIF

#IFDEF FLOATING_WELL_CHECK
SCONNECT tndiff nxwell_float by nplug
SCONNECT schottky_n nxwell_float by nplug
SCONNECT shpemit_7t_e1 nxwell_float by nplug
SCONNECT shpemit_7t_e8 nxwell_float by nplug
SCONNECT hvndfs nxwell_float by nplug
SCONNECT shpemit_poly nxwell_float by nplug
SCONNECT hnemit nxwell_float by nplug
SCONNECT tndiff_woR nxwell_float by nplug
floating.nxwell_float { @ nxwell_float is not connected to POWER
  no_power_path = PATHCHK !POWER nxwell_float PORTS ALSO
  direct_connect_ground = NET nxwell_float GROUND_NAME
  no_power_path or direct_connect_ground
}
#ENDIF

#IFDEF FLOATING_WELL_CHECK
SCONNECT tpdiff psub_float by pplug
SCONNECT tpdiff_woR psub_float by pplug
SCONNECT phvnwemit psub_float by pplug
SCONNECT sbd_hv_dio_gen2_dio psub_float by pplug
SCONNECT schottky_p psub_float by pplug
SCONNECT ioemit_poly psub_float by pplug
SCONNECT nddemit psub_float by pplug
SCONNECT ioemit psub_float by pplug
SCONNECT tpdiff_s psub_float by pplug
SCONNECT emit_rpo psub_float by pplug
SCONNECT stack_esd_plus psub_float by pplug
SCONNECT hvpdfs psub_float by pplug
floating.psub_float { @ psub_float is not connected to GROUND
  no_ground_path = PATHCHK !GROUND psub_float PORTS ALSO
  direct_connect_power = NET psub_float POWER_NAME
  no_ground_path or direct_connect_power
}
#ENDIF
gate1_not_IO1_GND = NET gate1_not_IO1_not_IO1 GROUND_NAME

#IFDEF GATE_TO_PG_CHECK
// gate1_not_IO1 connect to ground 
npvss150 { @ gate1_not_IO1 connected to GROUND
  gate1_not_IO1_GND1 = gate1_not_IO1_GND INTERACT N2tndiff == 2
  gate1_not_IO1_GND NOT gate1_not_IO1_GND1
}
#ENDIF

#IFDEF WELL_TO_PG_CHECK
// ntap connect to ground 
npvss49 { @ ntap connected to GROUND
  ntap_not_var = ntap NOT VARDMY
  NET ntap_not_var GROUND_NAME
}
#ENDIF

#IFDEF PATH_CHECK
// Nodes with a path to ground but not power 
ERC PATHCHK GROUND && !POWER
#ENDIF

#IFDEF PATH_CHECK
// Nodes with a path to power but not ground 
ERC PATHCHK POWER && !GROUND
#ENDIF

#IFDEF PATH_CHECK
// Nodes without a path to power and ground 
ERC PATHCHK !POWER && !GROUND NOFLOAT
#ENDIF

#IFDEF PATH_CHECK
ERC PATHCHK !LABELED NOFLOAT
#ENDIF
gate1_not_IO1_not_IO1 = gate1_not_IO1 NOT OD2
CONNECT gate1_not_IO1_not_IO1 poly
gate1_not_IO1_PWR = NET gate1_not_IO1_not_IO1 POWER_NAME

#IFDEF GATE_TO_PG_CHECK
// gate1_not_IO1 connect to power 
ppvdd150 { @ gate1_not_IO1 connected to POWER
  gate1_not_IO1_PWR1 = gate1_not_IO1_PWR INTERACT N1tpdiff == 2
  gate1_not_IO1_PWR NOT gate1_not_IO1_PWR1
}
#ENDIF

#IFDEF WELL_TO_PG_CHECK
// ptap connect to power 
ppvdd49 { @ ptap connected to POWER
  NET ptap POWER_NAME
}
#ENDIF

#ENDIF
